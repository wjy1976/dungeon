<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>無盡之淵 - Infinite Dungeon (Ultimate v5)</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: #000; color: #dcdcdc;
            font-family: 'Noto Serif TC', serif; user-select: none; -webkit-user-select: none;
            display: flex; flex-direction: column; height: 100vh;
        }

        #game-viewport { position: relative; flex-grow: 1; overflow: hidden; cursor: crosshair; background: #050505; }
        
        #ui-panel {
            height: 140px; background: #111; border-top: 4px solid #333;
            display: flex; justify-content: center; align-items: center;
            padding: 5px 20px; box-sizing: border-box; z-index: 20;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.9);
            position: relative;
        }

        canvas { display: block; }

        .globe-wrapper { position: relative; width: 90px; height: 90px; margin: 0 10px; flex-shrink: 0; }
        .globe-container {
            width: 100%; height: 100%; background: #000; border-radius: 50%; border: 3px solid #555;
            box-shadow: inset 0 0 20px #000; overflow: hidden; position: relative;
        }
        .globe-liquid { position: absolute; bottom: 0; left: 0; width: 100%; transition: height 0.3s ease-out; }
        .globe-glass {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3) 0%, transparent 20%, rgba(0,0,0,0.4) 80%);
            border-radius: 50%; pointer-events: none;
        }
        #hp-globe .globe-liquid { background: linear-gradient(to top, #700, #f00); box-shadow: 0 0 15px #f00 inset; }
        #mp-globe .globe-liquid { background: linear-gradient(to top, #007, #0af); box-shadow: 0 0 15px #00f inset; }
        .globe-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-weight: bold; font-size: 16px; text-shadow: 1px 1px 2px #000; color: #fff; z-index: 5;
        }
        
        /* Spell Orb Style */
        .spell-orb-wrapper {
            position: absolute; width: 50px; height: 50px; right: -30px; bottom: 0px;
            z-index: 10;
        }
        .spell-orb-container {
            width: 100%; height: 100%; background: #111; border-radius: 50%; border: 2px solid #d4af37;
            overflow: hidden; position: relative; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 10px #d4af37; cursor: pointer;
        }
        #current-spell-icon { font-size: 24px; z-index: 2; }
        #current-spell-lvl { 
            position: absolute; bottom: 2px; right: 8px; font-size: 10px; color: #0ff; 
            font-weight: bold; text-shadow: 1px 1px 0 #000; z-index: 3;
        }

        #center-controls { flex-grow: 1; max-width: 800px; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px; }
        #xp-bar-container { width: 100%; height: 6px; background: #222; border: 1px solid #555; border-radius: 4px; overflow: hidden; }
        #xp-bar-fill { height: 100%; background: #a3f; width: 0%; transition: width 0.2s; }

        .hotbar { display: flex; gap: 8px; margin: 5px 0; align-items: center; background: #000; padding: 5px; border-radius: 8px; border: 1px solid #333; }
        .hotkey-slot {
            width: 42px; height: 42px; background: #1a1a1a; border: 2px solid #444; border-radius: 4px;
            position: relative; cursor: pointer; display: flex; justify-content: center; align-items: center;
            font-size: 22px; transition: 0.1s;
        }
        .hotkey-slot:hover { border-color: #d4af37; background: #222; }
        .hotkey-slot.active-spell { border-color: #0af; box-shadow: 0 0 10px #0af; }
        .key-label { position: absolute; top: -6px; left: -6px; background: #333; color: #fff; font-size: 10px; padding: 1px 4px; border-radius: 4px; border: 1px solid #555; z-index: 2; }
        .qty-label { position: absolute; bottom: 1px; right: 2px; color: #fff; font-size: 11px; font-weight: bold; text-shadow: 1px 1px 0 #000; z-index: 2; }
        .spell-lvl-label { position: absolute; top: 1px; right: 2px; color: #0ff; font-size: 10px; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        .hotbar-separator { width: 2px; height: 40px; background: #333; margin: 0 5px; }

        .system-btns { position: absolute; right: 20px; bottom: 20px; display: flex; flex-direction: column; gap: 8px; }

        .game-window {
            position: absolute; background: rgba(15, 15, 20, 0.98); border: 2px solid #555;
            box-shadow: 0 0 50px #000; display: none; flex-direction: column; pointer-events: auto; z-index: 200;
            max-height: 85vh; border-radius: 4px;
        }
        
        #inventory-window { width: 660px; height: 520px; top: 10%; right: 10%; left: auto; transform: none; display: none; }
        .inv-container { display: flex; flex-direction: row; flex-grow: 1; min-height: 0; overflow: hidden; }
        
        .stats-sidebar { 
            width: 140px; background: rgba(0,0,0,0.3); border-right: 1px solid #444; padding: 15px; 
            font-size: 13px; color: #aaa; flex-shrink: 0; overflow-y: auto;
        }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 6px; align-items: center; }
        .plus-btn { 
            color: #444; cursor: default; font-weight: bold; padding: 0 4px; border: 1px solid #333; border-radius: 3px; background: #111; user-select: none;
        }
        .plus-btn.active { color: #f00; cursor: pointer; border-color: #600; background: #200; }
        .plus-btn.active:hover { background: #400; color: #fff; }
        
        .paper-doll-container { 
            width: 200px; position: relative; background: radial-gradient(circle at center, #222 0%, #080808 80%); 
            border-right: 1px solid #444; flex-shrink: 0;
        }
        
        .inv-grid-container { 
            flex-grow: 1; padding: 10px; overflow-y: auto; 
            background-color: #0b0b0b;
            background-image: 
                linear-gradient(#1a1a1a 1px, transparent 1px),
                linear-gradient(90deg, #1a1a1a 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex; flex-direction: column;
        }
        .inventory-grid { 
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; 
            align-content: start; grid-auto-rows: min-content;
        }
        
        .doll-slot {
            width: 40px; height: 40px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 4px;
            position: absolute; display: flex; justify-content: center; align-items: center; font-size: 20px; color: #333; cursor: pointer;
        }
        .doll-slot.equipped { border-color: #d4af37; box-shadow: 0 0 10px rgba(212, 175, 55, 0.3); color: #fff; }
        .doll-label { position: absolute; font-size: 8px; color: #666; bottom: 0; width: 100%; text-align: center; pointer-events: none; }

        #slot-helm { top: 20px; left: 80px; }
        #slot-necklace { top: 70px; left: 130px; width: 30px; height: 30px; }
        #slot-armor { top: 70px; left: 80px; height: 60px; }
        #slot-mainhand { top: 80px; left: 20px; height: 80px; width: 40px; }
        #slot-offhand { top: 80px; left: 140px; height: 80px; width: 40px; }
        #slot-earring1 { top: 30px; left: 30px; width: 28px; height: 28px; }
        #slot-earring2 { top: 30px; left: 142px; width: 28px; height: 28px; }
        #slot-ring1 { top: 180px; left: 30px; width: 28px; height: 28px; }
        #slot-ring2 { top: 180px; left: 142px; width: 28px; height: 28px; }
        #slot-pants { top: 140px; left: 80px; height: 50px; }
        #slot-boots { top: 200px; left: 80px; height: 40px; }
        #slot-gloves { top: 140px; left: 20px; height: 40px; width: 40px; }

        .inv-slot { width: 100%; aspect-ratio: 1; background: #151515; border: 1px solid #333; border-radius: 3px; display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer; z-index: 2; }

        #shop-window { width: 350px; height: 500px; top: 10%; left: 5%; right: auto; transform: none; }
        .shop-items { flex-grow: 1; overflow-y: auto; padding: 10px; min-height: 0; }
        .shop-item { background: #1a1a1a; border: 1px solid #333; padding: 10px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; cursor: grab; border-radius: 4px; }
        .shop-item:hover { border-color: #d4af37; background: #252525; }
        .shop-item:active { cursor: grabbing; }

        #spellbook-window { width: 400px; height: 500px; top: 15%; left: 15%; right: auto; }
        .spell-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; padding: 10px; }
        .spell-icon { width: 100%; aspect-ratio: 1; border: 1px solid #444; background: #111; display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; position: relative; }
        .spell-icon:hover { border-color: #0af; background: #222; }
        .spell-lvl { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: #fff; }

        .window-header { background: #222; color: #d4af37; padding: 8px 12px; font-weight: bold; display: flex; justify-content: space-between; border-bottom: 2px solid #444; font-size: 16px; flex-shrink: 0; }
        .close-btn { cursor: pointer; color: #f55; font-size: 20px; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; display: none; z-index: 50; touch-action: none;
        }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.2); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }

        #minimap-container {
            position: absolute; top: 10px; right: 10px; width: 150px; height: 150px;
            background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 4px; overflow: hidden; cursor: pointer; z-index: 50;
        }
        #minimap { display: block; width: 100%; height: 100%; }
        
        #dialogue-box {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 600px; background: rgba(0,0,0,0.9); border: 2px solid #d4af37;
            padding: 20px; color: #fff; font-size: 18px; display: none; z-index: 250;
            border-radius: 8px; box-shadow: 0 0 20px #000;
        }
        #dialogue-name { color: #d4af37; font-weight: bold; margin-bottom: 10px; font-size: 20px; }
        #dialogue-text { line-height: 1.5; min-height: 60px; }
        #dialogue-close { position: absolute; top: 10px; right: 15px; cursor: pointer; color: #888; }

        #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.9); z-index: 9999;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #death-title { font-size: 80px; color: #f00; text-shadow: 0 0 20px #000; margin-bottom: 50px; font-family: 'serif'; }
        .death-btn {
            background: #111; border: 2px solid #555; color: #ddd;
            font-size: 24px; padding: 15px 40px; margin: 10px; cursor: pointer;
            transition: 0.2s; width: 300px;
        }
        .death-btn:hover { border-color: #f00; color: #fff; background: #300; }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        .char-create-panel { background: #111; border: 2px solid #444; padding: 30px; width: 900px; display: flex; gap: 30px; border-radius: 8px; box-shadow: 0 0 100px rgba(0,0,0,0.8); max-height: 90vh; }
        .race-btn { padding: 12px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; width: 100%; margin-bottom: 8px; text-align: left; font-size: 18px; border-radius: 4px; transition: 0.2s; }
        .race-btn.selected { background: #500; color: #fff; border-color: #f00; box-shadow: 0 0 15px rgba(255,0,0,0.3); }
        .gender-select { display: flex; gap: 10px; margin-bottom: 20px; }
        .gender-btn { flex: 1; padding: 10px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; text-align: center; border-radius: 4px; }
        .gender-btn.selected { background: #0055aa; color: #fff; border-color: #0af; }
        
        .stat-bar { background: #222; height: 8px; width: 100%; margin: 6px 0; border-radius: 2px; }
        .stat-fill { height: 100%; background: #d4af37; transition: width 0.3s; }
        .btn-back { position: absolute; top: 20px; left: 20px; background: #333; border: 1px solid #555; color: #aaa; padding: 10px 20px; cursor: pointer; font-size: 16px; border-radius: 4px; }
        .action-btn { background: #222; border: 1px solid #444; color: #dcdcdc; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-family: 'Noto Serif TC', serif; font-size: 14px; width: 100px; text-align: center; }
        .action-btn:hover { background: #333; border-color: #666; }

        .item-tooltip { position: absolute; background: rgba(10, 10, 15, 0.98); border: 1px solid #666; padding: 12px; pointer-events: none; display: none; z-index: 9999; width: 260px; box-shadow: 0 5px 20px #000; }
        .floating-text { position: absolute; font-weight: bold; pointer-events: none; animation: floatUp 1s forwards ease-out; text-shadow: 2px 2px 0 #000; font-family: sans-serif; font-size: 22px; z-index: 50; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-70px) scale(1.2); opacity: 0; } }
        #cast-bar { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 12px; background: rgba(0,0,0,0.8); border: 1px solid #aaa; display: none; border-radius: 6px; overflow: hidden; }
        #cast-fill { height: 100%; background: #0af; width: 0%; }
        
        #monster-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-weight: bold; text-shadow: 2px 2px 4px #000;
            font-size: 20px; pointer-events: none; display: none; z-index: 150;
            background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 10px;
        }
        
        #guide-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 700px; max-height: 80vh; background: #151515; border: 2px solid #d4af37;
            padding: 30px; z-index: 1000; display: none; overflow-y: auto; color: #ccc;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        #guide-modal h2 { color: #d4af37; border-bottom: 1px solid #444; padding-bottom: 10px; }
        #guide-modal h3 { color: #eee; margin-top: 20px; }
        #guide-modal p { line-height: 1.6; margin-bottom: 10px; }
        #guide-modal ul { padding-left: 20px; }
        #guide-modal li { margin-bottom: 5px; }
    </style>
</head>
<body onload="init()">

<div id="game-viewport">
    <canvas id="gameCanvas" ondragover="event.preventDefault();" ondrop="handleDropToWorld(event)"></canvas>
    <div id="floating-text-container" style="position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden;"></div>
    <div id="joystick-container"><div id="joystick-knob"></div></div>
    <div id="cast-bar"><div id="cast-fill"></div></div>
    <div id="minimap-container" title="點擊以移動"><canvas id="minimap" width="150" height="150"></canvas></div>
    <div id="monster-hud"></div>
    
    <div id="dialogue-box">
        <div id="dialogue-close" onclick="closeDialogue()">✕</div>
        <div id="dialogue-name">NPC Name</div>
        <div id="dialogue-text">Dialogue text goes here...</div>
    </div>

    <div id="inventory-window" class="game-window">
        <div class="window-header"><span>英雄裝備</span><span class="close-btn" onclick="toggleInventory()">✕</span></div>
        <div class="inv-container">
            <div class="stats-sidebar">
                <div style="margin-bottom:10px; color:#d4af37; font-weight:bold;">屬性點: <span id="stat-points">0</span></div>
                <div class="stat-row">力量 <span id="stat-str">0</span> <span id="plus-str" class="plus-btn" onclick="addStat('str')">[+]</span></div>
                <div class="stat-row">敏捷 <span id="stat-dex">0</span> <span id="plus-dex" class="plus-btn" onclick="addStat('dex')">[+]</span></div>
                <div class="stat-row">魔力 <span id="stat-mag">0</span> <span id="plus-mag" class="plus-btn" onclick="addStat('mag')">[+]</span></div>
                <div class="stat-row">體質 <span id="stat-vit">0</span> <span id="plus-vit" class="plus-btn" onclick="addStat('vit')">[+]</span></div>
                
                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                <div>攻擊力 <span id="stat-atk">0</span></div>
                <div>防禦力 <span id="stat-def">0</span></div>
                <div style="margin-top:5px; color:#888; font-size:11px;">爆擊率: <span id="stat-crit">0</span>%</div>
                <div style="color:#888; font-size:11px;">必殺率: <span id="stat-kill">0</span>%</div>
                <div style="color:#8af; font-size:11px;">格擋率: <span id="stat-block">0</span>%</div>
                <div style="color:#6d6; font-size:11px;">閃避率: <span id="stat-evade">0</span>%</div>
                <div style="margin-top:5px; color:#0f0;">HP回: <span id="stat-hpregen">0</span>/s</div>
                <div style="color:#0af;">MP回: <span id="stat-mpregen">0</span>/s</div>
                <div style="margin-top:10px; font-weight:bold; color:#ffd700;">💰 <span id="ui-gold-inv">0</span></div>
                <div style="margin-top:5px; font-size:12px; color:#888;">物品: <span id="inv-count">0</span>/40</div>
            </div>
            
            <div class="paper-doll-container">
                <div class="doll-slot" id="slot-helm" ondblclick="unequip('helm')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'helm')"><span class="doll-label">頭部</span></div>
                <div class="doll-slot" id="slot-necklace" ondblclick="unequip('necklace')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'necklace')"><span class="doll-label">項鍊</span></div>
                <div class="doll-slot" id="slot-earring1" ondblclick="unequip('earring1')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'earring1')"><span class="doll-label">耳</span></div>
                <div class="doll-slot" id="slot-earring2" ondblclick="unequip('earring2')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'earring2')"><span class="doll-label">耳</span></div>
                <div class="doll-slot" id="slot-armor" ondblclick="unequip('armor')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'armor')"><span class="doll-label">身體</span></div>
                <div class="doll-slot" id="slot-mainhand" ondblclick="unequip('mainhand')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'mainhand')"><span class="doll-label">右手</span></div>
                <div class="doll-slot" id="slot-offhand" ondblclick="unequip('offhand')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'offhand')"><span class="doll-label">左手</span></div>
                <div class="doll-slot" id="slot-ring1" ondblclick="unequip('ring1')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'ring1')"><span class="doll-label">戒</span></div>
                <div class="doll-slot" id="slot-ring2" ondblclick="unequip('ring2')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'ring2')"><span class="doll-label">戒</span></div>
                <div class="doll-slot" id="slot-pants" ondblclick="unequip('pants')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'pants')"><span class="doll-label">腿部</span></div>
                <div class="doll-slot" id="slot-boots" ondblclick="unequip('boots')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'boots')"><span class="doll-label">腳部</span></div>
                <!-- New Gloves Slot -->
                <div class="doll-slot" id="slot-gloves" ondblclick="unequip('gloves')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'gloves')"><span class="doll-label">手套</span></div>
            </div>

            <div class="inv-grid-container">
                <div class="inventory-grid" id="inventory-grid" ondragover="event.preventDefault();" ondrop="handleDropToInventory(event)"></div>
            </div>
        </div>
    </div>

    <div id="spellbook-window" class="game-window">
        <div class="window-header"><span>法術書</span><span class="close-btn" onclick="toggleSpellBook()">✕</span></div>
        <div style="padding:10px; color:#aaa; font-size:12px;">將法術拖曳至快捷列 5-8 以快速使用</div>
        <div class="spell-grid" id="spell-grid"></div>
    </div>

    <div id="shop-window" class="game-window" ondragover="event.preventDefault();" ondrop="handleDropToShop(event)">
        <div class="window-header"><span id="shop-title">商店 (雙擊購買/拖曳出售)</span><span class="close-btn" onclick="closeShop()">✕</span></div>
        <div class="shop-items" id="shop-items"></div>
    </div>
</div>

<div id="ui-panel">
    <div class="globe-wrapper">
        <div class="globe-container" id="hp-globe"><div class="globe-liquid" id="hp-fill"></div><div class="globe-glass"></div></div>
        <div class="globe-text" id="hp-text">100</div>
    </div>
    <div id="center-controls">
        <div style="width:100%; display:flex; justify-content:space-between; align-items:baseline;">
            <div id="level-info" style="font-size:18px; color:#d4af37; font-weight:bold;">營地</div>
            <div style="font-size:14px; color:#aaa;">Lv <span id="ui-level">1</span></div>
        </div>
        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
        
        <div class="hotbar">
            <!-- Items 1-4 -->
            <div class="hotkey-slot" ondrop="handleDropToHotbar(event, 0)" ondragover="event.preventDefault()" onclick="useHotbar(0)"><div class="key-label">1</div><span id="hb-icon-0"></span><div class="qty-label" id="hb-qty-0"></div></div>
            <div class="hotkey-slot" ondrop="handleDropToHotbar(event, 1)" ondragover="event.preventDefault()" onclick="useHotbar(1)"><div class="key-label">2</div><span id="hb-icon-1"></span><div class="qty-label" id="hb-qty-1"></div></div>
            <div class="hotkey-slot" ondrop="handleDropToHotbar(event, 2)" ondragover="event.preventDefault()" onclick="useHotbar(2)"><div class="key-label">3</div><span id="hb-icon-2"></span><div class="qty-label" id="hb-qty-2"></div></div>
            <div class="hotkey-slot" ondrop="handleDropToHotbar(event, 3)" ondragover="event.preventDefault()" onclick="useHotbar(3)"><div class="key-label">4</div><span id="hb-icon-3"></span><div class="qty-label" id="hb-qty-3"></div></div>
            
            <div class="hotbar-separator"></div>
            
            <!-- Spells 5-8 -->
            <div class="hotkey-slot" id="slot-spell-0" ondrop="handleDropToHotbar(event, 4)" ondragover="event.preventDefault()" onclick="useHotbar(4)" onmouseenter="showSpellTip(4, event)" onmouseleave="hideTip()"><div class="key-label">5</div><span id="hb-icon-4"></span><div class="spell-lvl-label" id="hb-lvl-4"></div></div>
            <div class="hotkey-slot" id="slot-spell-1" ondrop="handleDropToHotbar(event, 5)" ondragover="event.preventDefault()" onclick="useHotbar(5)" onmouseenter="showSpellTip(5, event)" onmouseleave="hideTip()"><div class="key-label">6</div><span id="hb-icon-5"></span><div class="spell-lvl-label" id="hb-lvl-5"></div></div>
            <div class="hotkey-slot" id="slot-spell-2" ondrop="handleDropToHotbar(event, 6)" ondragover="event.preventDefault()" onclick="useHotbar(6)" onmouseenter="showSpellTip(6, event)" onmouseleave="hideTip()"><div class="key-label">7</div><span id="hb-icon-6"></span><div class="spell-lvl-label" id="hb-lvl-6"></div></div>
            <div class="hotkey-slot" id="slot-spell-3" ondrop="handleDropToHotbar(event, 7)" ondragover="event.preventDefault()" onclick="useHotbar(7)" onmouseenter="showSpellTip(7, event)" onmouseleave="hideTip()"><div class="key-label">8</div><span id="hb-icon-7"></span><div class="spell-lvl-label" id="hb-lvl-7"></div></div>
        </div>
    </div>
    
    <div class="system-btns">
        <button class="action-btn" onclick="toggleInventory()">背包 (I)</button>
        <button class="action-btn" onclick="toggleSpellBook()">法術 (K)</button>
        <button class="action-btn" onclick="saveGame()">存檔</button>
        <button class="action-btn" onclick="toggleMusic()" id="btn-music">🔇 音樂</button>
    </div>

    <div class="globe-wrapper">
        <div class="globe-container" id="mp-globe"><div class="globe-liquid" id="mp-fill"></div><div class="globe-glass"></div></div>
        <div class="globe-text" id="mp-text">50</div>
        
        <!-- Spell Orb -->
        <div class="spell-orb-wrapper" title="當前法術">
            <div class="spell-orb-container" onclick="toggleSpellBook()">
                <div id="current-spell-icon"></div>
                <div id="current-spell-lvl"></div>
            </div>
        </div>
    </div>
</div>

<div class="item-tooltip" id="tooltip">
    <div id="tip-title" style="font-weight:bold; font-size:18px;"></div>
    <div id="tip-body" style="font-size:13px; margin-top:8px;"></div>
</div>

<div id="guide-modal">
    <h2>遊戲指南</h2>
    <button class="close-btn" style="position:absolute; top:20px; right:20px;" onclick="closeGuide()">✕</button>
    <h3>🎮 操作方式</h3>
    <p><b>移動：</b>點擊地面移動。點擊小地圖可自動尋路。</p>
    <p><b>攻擊：</b>點擊怪物進行普攻。面對怪物 60 度角內點擊為攻擊，否則為調整位置。</p>
    <p><b>施法：</b>右鍵點擊目標方向。快捷鍵 5-8 可切換或施放法術。</p>
    <p><b>互動：</b>點擊 NPC 交易/對話，點擊寶箱開啟。</p>
    <h3>🎒 物品與裝備</h3>
    <p><b>裝備：</b>雙擊背包中的裝備可穿戴。裝備分為普通(白)、魔法(藍)、稀有(黃)、傳奇(橘)。</p>
    <p><b>格擋與閃避：</b>盾牌提供格擋(STR相關)，敏捷提供閃避(DEX相關)。</p>
    <h3>✨ 法術系統</h3>
    <p>法術分為：<b>攻擊系</b>、<b>回復系</b>、<b>輔助系</b>、<b>召喚系</b>。</p>
    <p>法術傷害隨等級提升，且為浮動數值。法術<b>不會爆擊</b>，也<b>不觸發</b>裝備特效。</p>
    <p><b>新法術：</b>噴火龍頭(砲塔)、落雷術。</p>
</div>

<div id="start-screen">
    <h1 style="font-size: 80px; color: #8b0000; text-shadow: 0 0 30px red; margin-bottom: 40px; font-family:'serif'; text-align: center;">無盡之淵<br><span style="font-size: 40px;">Infinite Dungeon</span></h1>
    <div class="char-create-panel" id="char-create" style="display:none;">
        <button class="btn-back" onclick="showMainMenu()">⬅ 返回主選單</button>
        <div style="width:250px; display:flex; flex-direction:column;" id="race-list"></div>
        <div style="flex-grow:1; padding-left:45px; border-left:1px solid #333;">
            <div class="gender-select">
                <div class="gender-btn selected" id="btn-male" onclick="selectGender('MALE')">♂ 男</div>
                <div class="gender-btn" id="btn-female" onclick="selectGender('FEMALE')">♀ 女</div>
            </div>
            <h2 id="preview-race" style="color:#d4af37; font-size:36px; margin-top:0;">人類</h2>
            <div id="preview-icon" style="font-size:60px; margin-bottom:10px;">🧑</div>
            <p id="preview-desc" style="color:#888; height:70px; font-size:16px;">描述...</p>
            <div style="width:100%;">
                <div>力量</div><div class="stat-bar"><div id="bar-str" class="stat-fill"></div></div>
                <div>敏捷</div><div class="stat-bar"><div id="bar-dex" class="stat-fill"></div></div>
                <div>魔力</div><div class="stat-bar"><div id="bar-mag" class="stat-fill"></div></div>
                <div>體質</div><div class="stat-bar"><div id="bar-vit" class="stat-fill"></div></div>
            </div>
            <button class="action-btn" style="margin-top:40px; font-size:24px; border-color:#d00; width:100%; padding:20px; font-weight:bold;" onclick="startGame()">踏入黑暗</button>
        </div>
    </div>
    <div id="main-menu">
        <button class="action-btn" style="font-size:28px; padding:25px 80px; margin-bottom:20px; display:block; width:350px;" onclick="showCharCreate()">新遊戲</button>
        <button class="action-btn" id="btn-load" style="font-size:28px; padding:25px 80px; margin-bottom:20px; display:block; width:350px;" onclick="tryLoadGame()">讀取進度</button>
        <button class="action-btn" style="font-size:28px; padding:25px 80px; display:block; width:350px;" onclick="openGuide()">遊戲指南</button>
    </div>
</div>

<div id="death-screen">
    <div id="death-title">你死掉了</div>
    <button class="death-btn" onclick="resurrect('town')">靈魂轉生 (掉落裝備保留等級)</button>
    <button class="death-btn" onclick="showMainMenu()">重新開始</button>
</div>

<script>
// Helmet Image Data URI (Gray helmet with red plume)
const HELM_ICON_SRC = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath d='M32 6 C20 6 10 16 10 32 V54 L18 60 L32 54 L46 60 L54 54 V32 C54 16 44 6 32 6 Z' fill='%2395a5a6' stroke='%232c3e50' stroke-width='2'/%3E%3Crect x='30' y='2' width='4' height='10' fill='%23c0392b'/%3E%3Cpath d='M32 2 Q40 2 42 10 Q32 8 32 10' fill='%23e74c3c'/%3E%3Cpath d='M20 32 L20 46 L32 54 L44 46 V32' fill='none' stroke='%232c3e50' stroke-width='3'/%3E%3Cpath d='M32 32 V54' fill='none' stroke='%232c3e50' stroke-width='2'/%3E%3C/svg%3E";
const helmImg = new Image();
helmImg.src = HELM_ICON_SRC;

const game = {
    running: false, map: [], visited: [], visibleTiles: [], entities: [], items: [], projs: [], shopItems: [],
    cam: {x:0, y:0}, player: null, floor: 0, uiDirty: false, transitionCooldown: 0, bossActive: false,
    dungeonCache: null, dead: false, currentNPC: null, savedPlayerPos: null,
    theme: { floor: '#181818', wall: '#1d1d1d' }, shopOpen: false
};
const joystick = { active: false, startX: 0, startY: 0, vector: {x:0,y:0} };
const mouse = { wx: 0, wy: 0 };
let gameCanvas, gameCtx, minimapCanvas, minimapCtx, selRace = 'HUMAN', selGender = 'MALE';
const MAP_W = 100, MAP_H = 100;

const RACES = {
    HUMAN: { name: '人類', desc: '能力平均。', stats: { str: 5, dex: 5, mag: 5, vit: 5 }, startSpells: { 'FIREBALL': 1 }, critBonus:0, killBonus:0, iconM: '🧑', iconF: '👧' },
    ELF:   { name: '精靈', desc: '身手敏捷，精通魔法。', stats: { str: 3, dex: 8, mag: 7, vit: 3 }, startSpells: { 'FIREBALL': 1, 'HASTE': 1 }, critBonus:5, killBonus:0, iconM: '🧝', iconF: '🧝‍♀️' },
    DWARF: { name: '矮人', desc: '體質強健，擅長暴擊。', stats: { str: 7, dex: 3, mag: 2, vit: 9 }, startSpells: { 'STONE_SKIN': 1 }, critBonus:10, killBonus:2, iconM: '🧔', iconF: '👩' },
    ORC:   { name: '獸人', desc: '力量強大，容易一擊必殺。', stats: { str: 9, dex: 4, mag: 1, vit: 7 }, startSpells: { 'MIGHT': 1 }, critBonus:5, killBonus:5, iconM: '🦁', iconF: '🐯' },
    UNDEAD:{ name: '亡靈', desc: '魔力強大，免疫毒素。', stats: { str: 2, dex: 4, mag: 10, vit: 5 }, startSpells: { 'FIREBALL': 1, 'CHARGED_BOLT': 1 }, critBonus:0, killBonus:1, iconM: '💀', iconF: '💀' }
};

const ITEM_TYPES = {
    SWORD_1H:{icon:'🗡️',name:'單手劍',slot:'mainhand',hands:1,range:55, speed:0.4, scale:1.0}, 
    SWORD_2H:{icon:'🔱',name:'雙手巨劍',slot:'mainhand',hands:2,range:75, speed:0.7, scale:1.4}, 
    AXE_1H:{icon:'🪓',name:'單手斧',slot:'mainhand',hands:1,range:55, speed:0.5, scale:1.0}, 
    AXE_2H:{icon:'🪓',name:'雙手戰斧',slot:'mainhand',hands:2,range:75, speed:0.8, scale:1.6}, 
    BOW:{icon:'🏹',name:'短弓',slot:'mainhand',hands:2,range:350, speed:0.6, scale:1.0}, 
    CROSSBOW:{icon:'🏹',name:'十字弓',slot:'mainhand',hands:2,range:320, speed:0.9, scale:1.1},
    STAFF:{icon:'🦯',name:'法杖',slot:'mainhand',hands:2,range:65, speed:0.5, scale:1.1},
    DAGGER:{icon:'🔪',name:'匕首',slot:'offhand',hands:1,range:40, speed:0.25, scale:0.8},
    SHIELD:{icon:'🛡️',name:'盾牌',slot:'offhand',hands:1}, 
    HELM:{icon:'🧢',name:'頭盔',slot:'helm'},
    ARMOR:{icon:'👕',name:'護甲',slot:'armor'}, 
    PANTS:{icon:'👖',name:'護腿',slot:'pants'}, 
    BOOTS:{icon:'👢',name:'長靴',slot:'boots'}, 
    GLOVES:{icon:'🧤',name:'手套',slot:'gloves'}, // 新增裝備
    AMULET:{icon:'📿',name:'護符',slot:'necklace'}, 
    EARRING:{icon:'🔗',name:'耳環',slot:'earring'}, 
    RING:{icon:'💍',name:'戒指',slot:'ring'},
    GOLD:{icon:'💰',name:'金幣'}, POTION:{icon:'💊',name:'生命藥水'}, MANA_POTION:{icon:'🧪',name:'魔力藥水'}, SCROLL_TP:{icon:'📜',name:'回城卷軸'}, SPELL_BOOK:{icon:'📘',name:'法術書'}
};

const SPELLS = {
    // Attack
    FIREBALL:{name:'火球術',icon:'🔥',cost:15,dmgBase:20,dmgLvl:5,cd:0.8,type:'projectile', cat:'ATK', desc:'發射一團火球攻擊單一敵人。'},
    ICEBOLT:{name:'冰箭術',icon:'❄️',cost:12,dmgBase:15,dmgLvl:4,cd:0.6,type:'projectile', cat:'ATK', effect:'slow', desc:'發射冰箭，造成傷害並緩速。'},
    CHARGED_BOLT:{name:'電網',icon:'⚡',cost:18,dmgBase:8,dmgLvl:3,cd:0.6,type:'multishot', cat:'ATK', desc:'發射多個帶電的電球。'},
    POISON_DART:{name:'毒鏢',icon:'🤢',cost:15,dmgBase:10,dmgLvl:3,cd:1.0,type:'projectile', cat:'ATK', effect:'poison', desc:'使敵人中毒持續扣血。'},
    METEOR:{name:'隕石術',icon:'☄️',cost:60,dmgBase:60,dmgLvl:15,cd:4.0,type:'aoe', cat:'ATK', desc:'延遲後召喚隕石造成大範圍傷害。'},
    WIND_BLADE:{name:'風刃',icon:'🍃',cost:20,dmgBase:25,dmgLvl:6,cd:0.7,type:'projectile', cat:'ATK', desc:'快速的風刃攻擊。'},
    LIGHTNING_STRIKE:{name:'落雷',icon:'🌩️',cost:50,dmgBase:50,dmgLvl:10,cd:3.0,type:'aoe_instant', cat:'ATK', desc:'在鼠標處召喚落雷。'},

    // Recovery
    HEAL:{name:'治癒術',icon:'💗',cost:30,dmgBase:40,dmgLvl:10,cd:2.0,type:'self', cat:'REC', desc:'恢復自身生命值。'},
    REGEN:{name:'再生術',icon:'🌿',cost:40,dmgBase:5,dmgLvl:2,cd:15.0,type:'buff', buff:'regen', desc:'一段時間內持續恢復生命。'},
    PURIFY:{name:'淨化',icon:'✨',cost:20,dmgBase:0,dmgLvl:0,cd:5.0,type:'self', cat:'REC', desc:'移除所有負面狀態。'},
    FULL_HEAL:{name:'神聖之光',icon:'✝️',cost:100,dmgBase:999,dmgLvl:0,cd:60.0,type:'self', cat:'REC', desc:'完全恢復生命值。'},
    MANA_TAP:{name:'魔力轉換',icon:'🔄',cost:0,dmgBase:0,dmgLvl:0,cd:10.0,type:'self', cat:'REC', desc:'消耗20%生命值轉換為魔力。'},

    // Support
    STONE_SKIN:{name:'石化皮膚',icon:'🗿',cost:40,dmgBase:0,dmgLvl:0,cd:30.0,type:'buff', buff:'def', desc:'暫時增加防禦力。'},
    HASTE:{name:'急速',icon:'🥾',cost:30,dmgBase:0,dmgLvl:0,cd:20.0,type:'buff', buff:'speed', desc:'暫時增加移動速度。'},
    MIGHT:{name:'力量強化',icon:'💪',cost:40,dmgBase:0,dmgLvl:0,cd:30.0,type:'buff', buff:'atk', desc:'暫時增加物理攻擊力。'},
    MAGIC_SHIELD:{name:'魔力盾',icon:'🛡️',cost:50,dmgBase:0,dmgLvl:0,cd:40.0,type:'buff', buff:'shield', desc:'用魔力抵擋受到的傷害。'},
    INVISIBILITY:{name:'隱形',icon:'👻',cost:60,dmgBase:0,dmgLvl:0,cd:20.0,type:'buff', buff:'invis', desc:'暫時讓敵人無法發現你。'},

    // Effect/Summon
    SUMMON_SKELETON:{name:'召喚骷髏',icon:'💀',cost:50,dmgBase:0,dmgLvl:0,cd:5.0,type:'summon', sumType:'SKELETON', desc:'召喚一隻骷髏為你作戰。'},
    SUMMON_GOLEM:{name:'召喚魔像',icon:'🗿',cost:80,dmgBase:0,dmgLvl:0,cd:10.0,type:'summon', sumType:'GOLEM', desc:'召喚一隻強大的岩石魔像。'},
    SUMMON_HYDRA:{name:'噴火龍頭',icon:'🐲',cost:70,dmgBase:15,dmgLvl:5,cd:12.0,type:'summon', sumType:'HYDRA', desc:'召喚一個噴火龍頭砲塔。'},
    FIREWALL:{name:'火牆',icon:'🌋',cost:35,dmgBase:10,dmgLvl:2,cd:5.0,type:'ground', cat:'EFF', desc:'在地面創造一道持續傷害的火牆。'},
    CONFUSE:{name:'迷惑術',icon:'💫',cost:25,dmgBase:0,dmgLvl:0,cd:8.0,type:'debuff', effect:'confused', desc:'使敵人混亂隨機移動。'},
    CHARM:{name:'魅惑術',icon:'💞',cost:40,dmgBase:0,dmgLvl:0,cd:15.0,type:'debuff', effect:'charmed', desc:'暫時使敵人倒戈為你作戰。'}
};

const MONSTERS = {
    RAT: {name:'巨鼠', icon:'🐀', hp:30, dmg:8, def:0, ranged:false, tier: 1}, 
    BAT: {name:'蝙蝠', icon:'🦇', hp:25, dmg:10, def:0, ranged:false, tier: 1},
    SNAKE: {name:'巨毒蛇', icon:'🐍', hp:40, dmg:12, def:1, ranged:false, poison:true, tier: 1}, // 新增
    SKELETON_SOLDIER: {name:'骷髏兵', icon:'💀', hp:50, dmg:15, def:2, ranged:false, tier: 1}, 
    SKELETON_SHIELD: {name:'骷髏盾衛', icon:'💀', subIcon:'🛡️', hp:110, dmg:10, def:10, ranged:false, tier: 2}, 
    SKELETON_SWORD: {name:'骷髏劍士', icon:'💀', subIcon:'🗡️', hp:70, dmg:22, def:4, ranged:false, tier: 2},
    SKELETON_ARCHER: {name:'骷髏射手', icon:'💀', subIcon:'🏹', hp:60, dmg:20, def:1, ranged:true, projIcon:'🏹', range:200, tier: 2},
    GOBLIN_MAGE: {name:'哥布林法師', icon:'👹', subIcon:'🔥', hp:55, dmg:25, def:1, ranged:true, projIcon:'🔥', range:220, tier: 2},
    ORC_WARRIOR: {name:'獸人戰士', icon:'🐗', hp:150, dmg:45, def:5, ranged:false, tier: 3},
    OGRE: {name:'食人魔', icon:'👹', hp:250, dmg:50, def:8, ranged:false, tier: 3}, // 新增
    EYE: {name:'眼魔', icon:'👁️', subIcon:'⚡', hp:100, dmg:35, def:3, ranged:true, projIcon:'⚡', range:180, tier: 3},
    GHOST: {name:'幽靈', icon:'👻', hp:70, dmg:30, def:8, speed:110, ranged:false, tier: 3},
    ASSASSIN: {name:'刺客', icon:'🥷', hp:90, dmg:55, def:2, speed:140, ranged:false, tier: 3},
    TENGU: {name:'天狗', icon:'👺', hp:120, dmg:40, def:5, speed:120, ranged:false, tier: 4}, // 新增
    GOLEM_MOB: {name:'巨魔象', icon:'🗿', hp:400, dmg:60, def:20, speed:50, ranged:false, tier: 4}, // 新增
    DEMON: {name:'惡魔', icon:'👿', hp:300, dmg:70, def:10, ranged:false, tier: 4},
    SPIDER: {name:'巨蜘蛛', icon:'🕷️', hp:60, dmg:20, def:2, speed:110, ranged:false, tier: 2}, 
    SCORPION: {name:'毒蠍', icon:'🦂', hp:80, dmg:25, def:5, ranged:false, tier: 2}, 
    DARK_ELF: {name:'黑暗精靈', icon:'🧕', subIcon:'🏹', hp:70, dmg:30, def:2, ranged:true, projIcon:'🏹', range:250, tier: 3}, 
    BANDIT: {name:'土匪', icon:'🦹', hp:100, dmg:40, def:3, ranged:false, tier: 2},
    BANDIT_LEADER: {name:'強盜頭目', icon:'🦹', subIcon:'👑', hp:180, dmg:50, def:8, ranged:false, tier: 3},
    SUCCUBUS: {name:'魅魔', icon:'👩‍🎤', hp:150, dmg:30, def:5, ranged:true, projIcon:'❤️', range:180, special:'confuse', tier: 4}, // 新增
    VAMPIRE: {name:'吸血鬼', icon:'🧛‍♂️', hp:200, dmg:40, def:8, ranged:false, special:'lifesteal', tier: 4}, // 新增
    LICH: {name:'妖巫', icon:'🧙‍♂️', hp:180, dmg:45, def:5, ranged:true, projIcon:'🟣', range:250, special:'magic', tier: 4}, // 新增
    HIGH_LICH: {name:'高級妖巫', icon:'🧙‍♀️', subIcon:'✨', hp:300, dmg:60, def:10, ranged:true, projIcon:'🔴', range:280, special:'high_magic', tier: 5}, // 新增
    DRAGON: {name:'龍', icon:'🐉', hp:2000, dmg:100, def:30, ranged:true, projIcon:'🔥', range:300, speed:80, tier: 6} // 新增
};

const AudioSys = {
    ctx: null, isMuted: false, bgmTimer: null,
    init: function() { 
        if(!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            this.playBGM();
        }
    },
    sfx: function(type) {
        if(!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        
        if(type === 'hit') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.1); 
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
            osc.start(t); osc.stop(t+0.1);
        }
        else if (type === 'coin') { 
            osc.type = 'sine'; osc.frequency.setValueAtTime(1500, t); osc.frequency.setValueAtTime(2000, t+0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
            osc.start(t); osc.stop(t+0.2);
        }
        else if (type === 'magic') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(600, t+0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.3);
            osc.start(t); osc.stop(t+0.3);
        }
        else if (type === 'level') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.setValueAtTime(600, t+0.2); osc.frequency.setValueAtTime(800, t+0.4);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.6);
            osc.start(t); osc.stop(t+0.6);
        }
        else if (type === 'die') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.5);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
            osc.start(t); osc.stop(t+0.5);
        }
        else if (type === 'portal') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(800, t+1.0);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+1.0);
            osc.start(t); osc.stop(t+1.0);
        }
    },
    playBGM: function() {
        if (!this.ctx || this.isMuted) return;
        const now = this.ctx.currentTime;
        const tone = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        tone.connect(gain); gain.connect(this.ctx.destination);
        const freqs = [146.83, 174.61, 196.00, 220.00, 261.63, 130.81];
        let f = freqs[Math.floor(Math.random()*freqs.length)];
        if(Math.random() > 0.7) f *= 0.5; 
        tone.type = 'sine';
        tone.frequency.setValueAtTime(f, now);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.03, now + 1);
        gain.gain.linearRampToValueAtTime(0, now + 4);
        tone.start(now);
        tone.stop(now + 4);
        this.bgmTimer = setTimeout(() => this.playBGM(), 3000);
    },
    stopBGM: function() { clearTimeout(this.bgmTimer); }
};

class ItemClass {
    constructor(lvl, x, y, forceRare=false) {
        this.x = x; this.y = y; this.lvl = Math.max(1, lvl); this.isItem = true;
        const types = ['SWORD_1H','SWORD_2H','BOW','CROSSBOW','STAFF','AXE_1H','AXE_2H','SHIELD','HELM','ARMOR','PANTS','BOOTS','AMULET','EARRING','RING','DAGGER','GLOVES'];
        const consumables = ['POTION','MANA_POTION','SCROLL_TP','SPELL_BOOK']; 
        
        if (!forceRare && Math.random() < 0.3) {
            this.type = consumables[randInt(0, consumables.length)];
            this.rarity = { name: '普通', col: '#fff', mul: 1 };
            if (this.type === 'SPELL_BOOK') {
                const spellKeys = Object.keys(SPELLS); this.spellKey = spellKeys[randInt(0, spellKeys.length)];
                this.name = `法術書: ${SPELLS[this.spellKey].name}`; this.rarity = { name: '魔法', col: '#44f', mul: 1 };
            } else {
                this.name = ITEM_TYPES[this.type].name;
            }
        } else {
            this.type = types[randInt(0, types.length)];
            let rRoll = Math.random();
            if (forceRare) rRoll = 0.99; 

            if (rRoll < 0.7 && !forceRare) this.rarity = { name: '普通', col: '#bbb', mul: 1 };
            else if (rRoll < 0.9 && !forceRare) this.rarity = { name: '魔法', col: '#44f', mul: 1.3 };
            else if (rRoll < 0.98) this.rarity = { name: '稀有', col: '#fe0', mul: 1.8 };
            else this.rarity = { name: '傳奇', col: '#f80', mul: 2.5 };
            
            // Naming System
            this.name = ITEM_TYPES[this.type].name;
            if (this.rarity.name !== '普通') {
                const pre = ['殘酷','迅捷','神聖','野蠻','遠古','黑暗','光輝','致命'];
                const prefix = pre[randInt(0, pre.length)];
                this.name = prefix + "的" + this.name;
            }
        }
        
        if (this.type !== 'SPELL_BOOK') {
            const baseVal = ITEM_TYPES[this.type].slot ? 50 : 10;
            this.price = Math.floor(baseVal * this.lvl * (this.rarity.mul || 1));
        } else { this.price = 200; }
        
        this.effects = [];
        if (this.type !== 'SPELL_BOOK' && this.rarity.mul > 1) {
            if(Math.random() < 0.15) this.effects.push({type:'燃燒', chance:0.2, val:this.lvl*2});
            if(Math.random() < 0.15) this.effects.push({type:'中毒', chance:0.2, val:this.lvl*1});
            if(Math.random() < 0.15) this.effects.push({type:'暈眩', chance:0.1, val:1.0});
            if(Math.random() < 0.15) this.effects.push({type:'緩速', chance:0.2, val:2.0});
            if(this.type === 'BOOTS') this.effects.push({type:'加速', chance:1.0, val: 10 + this.lvl * 2});
        }

        this.stats = {};
        if (ITEM_TYPES[this.type].slot) {
            let variance = randInt(0, 3);
            let mul = this.rarity.mul;
            this.stats.atk = (['SWORD_1H','SWORD_2H','AXE_1H','AXE_2H','BOW','CROSSBOW','DAGGER','GLOVES'].includes(this.type)) ? Math.floor((10 + this.lvl * 3 + variance) * mul) : 0;
            if(this.type === 'GLOVES') this.stats.atk = Math.floor(this.stats.atk * 0.3); // Gloves give less ATK
            if(this.type.includes('2H') || this.type === 'CROSSBOW') this.stats.atk = Math.floor(this.stats.atk * 1.6); 
            this.stats.def = (['ARMOR','SHIELD','HELM','PANTS','BOOTS','GLOVES'].includes(this.type)) ? Math.floor((2 + this.lvl * 1.5 + variance) * mul) : 0;
            if (this.type === 'STAFF') this.stats.mag = Math.floor((8 + this.lvl * 3 + variance) * mul);
            if(['AMULET','RING','EARRING'].includes(this.type)) {
                this.stats.str = randInt(0, this.lvl); this.stats.dex = randInt(0, this.lvl); this.stats.mag = randInt(0, this.lvl); this.stats.vit = randInt(0, this.lvl);
            }
            if(mul > 1.2) this.stats.str = (this.stats.str||0) + randInt(1, this.lvl);
            if(mul > 1.5) this.stats.vit = (this.stats.vit||0) + randInt(1, this.lvl);
        }
    }
}

class PlayerClass {
    constructor(raceKey, gender) {
        this.raceKey = raceKey; this.race = RACES[raceKey]; this.gender = gender;
        this.x = 0; this.y = 0; this.lvl = 1; this.xp = 0; this.pts = 0;
        this.baseStats = { ...this.race.stats }; this.stats = { ...this.baseStats, atk: 0, def: 0 };
        this.hp = 100; this.maxHp = 100; this.mp = 50; this.maxMp = 50; this.gold = 50;
        this.icon = this.gender === 'MALE' ? this.race.iconM : this.race.iconF;
        this.inv = []; 
        this.equip = { helm:null, necklace:null, earring1:null, earring2:null, armor:null, mainhand:null, offhand:null, ring1:null, ring2:null, pants:null, boots:null, gloves:null };
        
        // Hotbar: 0-3 Items (Potions/Scrolls), 4-7 Spells (Keys)
        this.hotbar = new Array(8).fill(null);
        // Default items
        this.inv.push({type:'POTION', name:'生命藥水', count:2});
        this.inv.push({type:'MANA_POTION', name:'魔力藥水', count:1});
        this.inv.push({type:'SCROLL_TP', name:'回城卷軸', count:1});
        // Auto-assign to hotbar if possible (simple logic for start)
        this.hotbar[0] = {type:'POTION', name:'生命藥水', count:2};
        this.hotbar[1] = {type:'MANA_POTION', name:'魔力藥水', count:1};
        this.hotbar[2] = {type:'SCROLL_TP', name:'回城卷軸', count:1};

        this.spells = JSON.parse(JSON.stringify(this.race.startSpells));
        const sKeys = Object.keys(this.spells);
        // Assign first spell to hotbar 5 (index 4)
        if(sKeys.length > 0) this.hotbar[4] = sKeys[0];
        if(sKeys.length > 1) this.hotbar[5] = sKeys[1];
        
        this.activeSpell = sKeys.length > 0 ? sKeys[0] : null;
        this.atkCd = 0; this.path = []; this.targetEntity = null; this.attackRequested = false; 
        this.attackAnimTimer = 0;
        this.moveSpeed = 90; 
        this.buffs = [];
        this.confusedTimer = 0; // confusion state
        this.recalc();
    }
    recalc() {
        this.stats = { ...this.baseStats, atk: 0, def: 0, mag: 0, str: 0, vit: 0, dex: 0 };
        this.stats.str += this.baseStats.str; this.stats.dex += this.baseStats.dex; this.stats.mag += this.baseStats.mag; this.stats.vit += this.baseStats.vit;
        let bonusSpeed = 0;
        for (let key in this.equip) {
            if (this.equip[key]) {
                const s = this.equip[key].stats;
                if(s.atk) this.stats.atk += s.atk; if(s.def) this.stats.def += s.def; if(s.mag) this.stats.mag += s.mag; if(s.str) this.stats.str += s.str; if(s.vit) this.stats.vit += s.vit; if(s.dex) this.stats.dex += s.dex;
                if(this.equip[key].effects) { this.equip[key].effects.forEach(e => { if(e.type==='加速') bonusSpeed += e.val; }); }
            }
        }
        
        // Apply buffs
        this.buffs.forEach(b => {
            if(b.type === 'speed') bonusSpeed += 50;
            if(b.type === 'atk') this.stats.atk += 20;
            if(b.type === 'def') this.stats.def += 20;
        });

        this.stats.atk += this.stats.str * 2; 
        this.maxHp = 50 + this.stats.vit * 10 + this.lvl * 10; this.maxMp = 20 + this.stats.mag * 8 + this.lvl * 5;
        this.critChance = 0.05 + this.stats.str * 0.005 + (this.race.critBonus/100);
        this.killChance = 0.00 + (this.stats.str + this.stats.dex) * 0.001 + (this.race.killBonus/100);
        
        // Evasion (DEX based, capped at 60%)
        this.evasion = Math.min(0.60, 0.0 + this.stats.dex * 0.005); 
        // Block Chance (STR based, capped at 50%, only with shield)
        this.blockChance = 0;
        if (this.equip.offhand && this.equip.offhand.type === 'SHIELD') {
            this.blockChance = Math.min(0.50, 0.05 + this.stats.str * 0.005);
        }

        this.moveSpeed = 90 + (this.stats.dex * 1.5) + bonusSpeed;
    }
    equipItem(it, invIdx, targetSlot = null) {
        if(it.type === 'SPELL_BOOK') {
            if(this.spells[it.spellKey]) { this.spells[it.spellKey] = Math.min(100, this.spells[it.spellKey] + 1); spawnText(this.x, this.y, `法術升級! Lv ${this.spells[it.spellKey]}`, "#0af"); }
            else { this.spells[it.spellKey] = 1; if(!this.activeSpell) this.activeSpell = it.spellKey; spawnText(this.x, this.y, `習得 ${SPELLS[it.spellKey].name}!`, "#0af"); }
            this.inv.splice(invIdx, 1); AudioSys.sfx('level'); game.uiDirty = true; return;
        }
        // Handle consumables logic separately now via hotbar/direct use
        if(['POTION','MANA_POTION','SCROLL_TP'].includes(it.type)) {
            // Try to stack in hotbar first
            let added = false;
            for(let i=0; i<4; i++) {
                if(this.hotbar[i] && this.hotbar[i].type === it.type) {
                    this.hotbar[i].count++; added = true; break;
                }
            }
            if(!added) {
                // Find empty hotbar slot
                for(let i=0; i<4; i++) {
                    if(!this.hotbar[i]) {
                        this.hotbar[i] = {type:it.type, name:it.name, count:1}; added = true; break;
                    }
                }
            }
            if(!added) {
                alert("快捷列已滿，無法裝備此消耗品"); return; 
            }
            this.inv.splice(invIdx, 1); game.uiDirty=true; return; 
        }
        
        let slot = targetSlot || ITEM_TYPES[it.type].slot;
        if (!slot) return;
        
        if (ITEM_TYPES[it.type].hands === 2) {
             let reqStr = it.lvl * 3;
             if (this.stats.str < reqStr) { alert(`力量不足! 需要: ${reqStr}`); return; }
        }

        if (slot === 'ring' && !targetSlot) { slot = !this.equip.ring1 ? 'ring1' : (!this.equip.ring2 ? 'ring2' : 'ring1'); }
        if (slot === 'earring' && !targetSlot) { slot = !this.equip.earring1 ? 'earring1' : (!this.equip.earring2 ? 'earring2' : 'earring1'); }

        if (this.equip[slot]) this.inv.push(this.equip[slot]);
        
        if (ITEM_TYPES[it.type].hands === 2) { 
            if((it.type === 'BOW' || it.type === 'CROSSBOW') && this.equip.offhand && this.equip.offhand.type === 'DAGGER') {
            } else {
                if(this.equip.offhand) { this.inv.push(this.equip.offhand); this.equip.offhand = null; }
            }
            if(slot === 'offhand') slot = 'mainhand'; 
        }
        if (slot === 'offhand' && this.equip.mainhand && ITEM_TYPES[this.equip.mainhand.type].hands === 2) { 
            if ((this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW') && it.type === 'DAGGER') {
            } else {
                this.inv.push(this.equip.mainhand); this.equip.mainhand = null; 
            }
        }
        
        if (!targetSlot && ITEM_TYPES[it.type].hands === 1 && slot === 'mainhand' && this.equip.mainhand && !this.equip.offhand && it.type !== 'SHIELD') { slot = 'offhand'; }
        if (!targetSlot && it.type === 'DAGGER' && this.equip.mainhand && (this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW')) { slot = 'offhand'; }
        
        if (slot === 'offhand' && this.equip.mainhand && ITEM_TYPES[this.equip.mainhand.type].hands === 2) {
             if (!((this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW') && it.type === 'DAGGER')) {
                 this.inv.push(this.equip.mainhand); this.equip.mainhand = null;
             }
        }

        this.equip[slot] = it; this.inv.splice(invIdx, 1); this.recalc(); game.uiDirty = true; AudioSys.sfx('coin');
    }
}

function randInt(min,max){return Math.floor(Math.random()*(max-min)+min);}

function isSolid(x,y){ 
    const tx=Math.floor(x/40), ty=Math.floor(y/40); 
    if(tx<0||tx>=MAP_W||ty<0||ty>=MAP_H) return true;
    return game.map[ty][tx]===1; 
}

function hasLineOfSight(x1, y1, x2, y2) {
    if (x1<0||x1>=MAP_W||y1<0||y1>=MAP_H||x2<0||x2>=MAP_W||y2<0||y2>=MAP_H) return false;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1); let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1; let err = dx - dy;
    let maxIter = 200; 
    while (maxIter-- > 0) {
        if (x1 === x2 && y1 === y2) return true; 
        if (game.map[y1][x1] === 1) return false;
        let e2 = 2 * err; if (e2 > -dy) { err -= dy; x1 += sx; } if (e2 < dx) { err += dx; y1 += sy; }
        if (x1<0||x1>=MAP_W||y1<0||y1>=MAP_H) return false;
    }
    return false;
}

function isBlocked(x, y, self) {
    if(isSolid(x, y)) return true;
    return false;
}

function findPath(sx, sy, tx, ty) {
    let startNode = {x: Math.floor(sx/40), y: Math.floor(sy/40)};
    let endNode = {x: Math.floor(tx/40), y: Math.floor(ty/40)};
    if (endNode.x < 0 || endNode.x >= MAP_W || endNode.y < 0 || endNode.y >= MAP_H) return [];
    
    if (game.map[endNode.y][endNode.x] === 1) {
        let best = null; let minD = 999;
        [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d=>{
            let nx=endNode.x+d.x, ny=endNode.y+d.y;
            if(nx>=0 && nx<MAP_W && ny>=0 && ny<MAP_H && game.map[ny][nx] !== 1) {
                let d = Math.hypot(nx-startNode.x, ny-startNode.y);
                if(d < minD) { minD = d; best = {x:nx, y:ny}; }
            }
        });
        if(best) { endNode = best; } else return [];
    }

    if (hasLineOfSight(startNode.x, startNode.y, endNode.x, endNode.y)) {
        return [{x: endNode.x*40+20, y: endNode.y*40+20}];
    }

    let queue = [startNode]; let cameFrom = {}; let key = (n) => n.x + ',' + n.y; cameFrom[key(startNode)] = null;
    let current = null; let maxSteps = 2000;
    while(queue.length > 0 && maxSteps-- > 0) {
        current = queue.shift();
        if (current.x === endNode.x && current.y === endNode.y) break;
        [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d => {
            let next = {x: current.x + d.x, y: current.y + d.y};
            if (next.x >= 0 && next.x < MAP_W && next.y >= 0 && next.y < MAP_H && game.map[next.y][next.x] !== 1) {
                if (cameFrom[key(next)] === undefined) { queue.push(next); cameFrom[key(next)] = current; }
            }
        });
    }
    
    if (!current || (current.x !== endNode.x && current.y !== endNode.y)) return [];
    let path = []; let curr = endNode;
    while (curr && (curr.x !== startNode.x || curr.y !== startNode.y)) {
        path.push({x: curr.x * 40 + 20, y: curr.y * 40 + 20});
        curr = cameFrom[key(curr)];
        if(!curr && path.length > 0) break;
    }
    return path.reverse();
}

function computeFOV(px, py, radius) {
    let visible = []; for(let y=0; y<MAP_H; y++) visible[y] = []; 
    if(px>=0 && px<MAP_W && py>=0 && py<MAP_H) visible[py][px] = true;
    const rays = 360;
    for (let i = 0; i < rays; i++) {
        let angle = (i * Math.PI) / 180; let dx = Math.cos(angle); let dy = Math.sin(angle); let ox = px + 0.5, oy = py + 0.5;
        for (let j = 0; j < radius; j++) {
            ox += dx; oy += dy; let tx = Math.floor(ox), ty = Math.floor(oy);
            if (tx < 0 || tx >= MAP_W || ty < 0 || ty >= MAP_H) break;
            visible[ty][tx] = true; if (game.map[ty][tx] === 1) break;
        }
    }
    return visible;
}

function createRoomsAndCorridors(lvl) {
    let map = []; for(let y=0;y<MAP_H;y++){ let r=[]; for(let x=0;x<MAP_W;x++) r.push(1); map.push(r); }
    let rooms = []; const numRooms = 25 + Math.floor(Math.random() * 10);
    for (let i = 0; i < numRooms; i++) {
        let w = randInt(6, 14); let h = randInt(6, 14); let x = randInt(2, MAP_W - w - 2); let y = randInt(2, MAP_H - h - 2);
        let overlap = false; for (let r of rooms) { if (x < r.x + r.w + 1 && x + w + 1 > r.x && y < r.y + r.h + 1 && y + h + 1 > r.y) { overlap = true; break; } }
        if (!overlap) { rooms.push({x, y, w, h, cx: Math.floor(x + w / 2), cy: Math.floor(y + h / 2)}); for (let ry = y; ry < y + h; ry++) for (let rx = x; rx < x + w; rx++) map[ry][rx] = 0; }
    }
    for (let i = 1; i < rooms.length; i++) {
        let r1 = rooms[i-1], r2 = rooms[i]; let cx1 = r1.cx, cy1 = r1.cy, cx2 = r2.cx, cy2 = r2.cy;
        if (Math.random() < 0.5) {
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy1][x] = 0; map[cy1+1][x] = 0; }
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx2] = 0; map[y][cx2+1] = 0; }
        } else {
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx1] = 0; map[y][cx1+1] = 0; }
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy2][x] = 0; map[cy2+1][x] = 0; }
        }
    }
    return {map, rooms};
}

function genFloor(lvl) {
    game.floor = lvl;
    game.map=[]; game.visited=[]; game.visibleTiles=[]; game.entities=[]; game.items=[]; game.projs=[];
    game.transitionCooldown = 2.0; game.bossActive = (lvl > 0 && lvl % 5 === 0);
    const themes = [{f:'#181818', w:'#222'}, {f:'#1a1f1a', w:'#203020'}, {f:'#221010', w:'#331111'}];
    game.theme = themes[Math.floor((lvl-1)/3) % 3] || themes[0];

    for(let y=0;y<MAP_H;y++){ let v=[]; let vt=[]; for(let x=0;x<MAP_W;x++) { v.push(false); vt.push(false); } game.visited.push(v); game.visibleTiles.push(vt); }

    if(lvl===0){ 
        for(let y=0;y<MAP_H;y++){ let r=[]; for(let x=0;x<MAP_W;x++) r.push(1); game.map.push(r); }
        for(let y=40;y<60;y++) for(let x=40;x<60;x++) game.map[y][x]=0;
        if(game.savedPlayerPos) {
            game.player.x=game.savedPlayerPos.x; game.player.y=game.savedPlayerPos.y;
            game.savedPlayerPos = null;
        } else {
             game.player.x=50*40+20; game.player.y=50*40+20;
        }
        game.entities.push({x:45*40+20,y:45*40+20,size:22,type:'NPC_ELDER',icon:'👴',name:'長老', dead:false});
        game.entities.push({x:55*40+20,y:45*40+20,size:22,type:'NPC_GENERAL',icon:'👳‍♂️',name:'商人', dead:false});
        if(game.dungeonCache) {
             game.entities.push({x:50*40+20, y:48*40+20, type:'PORTAL_DUNGEON', icon:'🌀', name:'回城傳送門', dead:false, size:30});
        }
        game.map[55][50]=2; // Down stairs to Floor 1
        spawnText(game.player.x, game.player.y - 50, "城鎮", "#ffd700");
        
        game.visibleTiles = computeFOV(Math.floor(game.player.x/40), Math.floor(game.player.y/40), 10);
        for(let y=0; y<MAP_H; y++) for(let x=0; x<MAP_W; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;

    } else {
        const dungeon = createRoomsAndCorridors(lvl);
        game.map = dungeon.map;
        const rooms = dungeon.rooms;
        let startRoom = rooms[0];
        game.map[startRoom.cy][startRoom.cx] = 6;
        if(game.savedPlayerPos) {
            game.player.x=game.savedPlayerPos.x; game.player.y=game.savedPlayerPos.y;
            game.savedPlayerPos = null;
        } else {
            game.player.x = (startRoom.cx + 1) * 40 + 20; game.player.y = startRoom.cy * 40 + 20;
        }
        
        let endRoom = rooms[rooms.length - 1];
        if (game.bossActive) {
            let bossKey = lvl >= 10 ? 'DRAGON' : 'DEMON'; // Deep levels dragon
            let template = MONSTERS[bossKey];
            game.entities.push({
                x: endRoom.cx*40+20, y: endRoom.cy*40+20, isEnemy: true, isBoss: true, 
                hp: template.hp + lvl * 100, maxHp: template.hp + lvl * 100, 
                dmg: template.dmg + lvl * 5, def: template.def + lvl, 
                icon: template.icon, name: template.name, ranged: template.ranged, projIcon: template.projIcon,
                dead: false, size: 40
            });
            spawnText(game.player.x, game.player.y - 100, `警告：${template.name} 出現！`, "#f00");
        } else { game.map[endRoom.cy][endRoom.cx] = 2; }
        
        // Town portal if created
        if (game.dungeonCache && game.dungeonCache.floor === lvl) {
             game.entities.push({x:game.dungeonCache.x, y:game.dungeonCache.y, type:'PORTAL_TOWN', icon:'🌀', name:'前往城鎮', dead:false, size:30});
        }

        if(Math.random() < 0.3) { let r = rooms[randInt(1, rooms.length-1)]; game.entities.push({x:r.cx*40+20, y:r.cy*40+20, type:'NPC_ADVENTURER', icon:'🤕', name:'受傷冒險者', dead:false, size:20}); }

        for (let i = 1; i < rooms.length - 1; i++) {
            let r = rooms[i];
            if(Math.random() < 0.2) {
                let tx, ty, tries=0;
                do { tx = randInt(r.x, r.x+r.w) * 40 + 20; ty = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(tx, ty) && tries < 50);
                game.entities.push({x:tx, y:ty, type:'TRAP', icon:'⚠️', name:'陷阱', dead:false, size:20, hidden:true, triggered:false});
            }
            let numMobs = randInt(5, 8 + Math.floor(lvl/2)); 
            for(let m=0; m<numMobs; m++) {
                let mx, my, tries=0;
                do { mx = randInt(r.x, r.x+r.w) * 40 + 20; my = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(mx, my) && tries < 50);
                let mKeys = Object.keys(MONSTERS).filter(k => MONSTERS[k].tier <= Math.ceil(lvl/3) + 1);
                if (mKeys.length === 0) mKeys = ['RAT'];
                let mKey = mKeys[randInt(0, mKeys.length)];
                let template = MONSTERS[mKey];
                let isElite = Math.random() < 0.05 + (lvl * 0.01);
                let hp = Math.floor(template.hp + lvl * 10); 
                let dmg = Math.floor(template.dmg + lvl * 2);
                let def = Math.floor((template.def || 0) + lvl * 0.5);
                if (isElite) { hp = Math.floor(hp * 2.5); dmg = Math.floor(dmg * 1.5); def += 5; }
                game.entities.push({
                    x:mx, y:my, isEnemy:true, 
                    hp:hp, maxHp:hp, 
                    dmg:dmg, def:def, icon:template.icon, subIcon:template.subIcon, name:template.name,
                    ranged: template.ranged, projIcon: template.projIcon, range: template.range || 50,
                    speed: template.speed || 75,
                    dead:false, size:20, lvl: lvl,
                    pushX: 0, pushY: 0,
                    isElite: isElite,
                    poison: template.poison,
                    special: template.special,
                    tier: template.tier
                });
            }
            if (Math.random() < 0.3) {
                let cx, cy, tries=0;
                do { cx = randInt(r.x, r.x+r.w) * 40 + 20; cy = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(cx, cy) && tries < 50);
                let isTrapped = Math.random() < 0.25;
                game.entities.push({x:cx, y:cy, type:'CHEST', icon:'📦', name:'寶箱', dead:false, size:20, trapped: isTrapped});
            }
        }
        spawnText(game.player.x, game.player.y - 50, "地下城 第 " + lvl + " 層", "#f00");
        
        // 初始更新視野
        game.visibleTiles = computeFOV(Math.floor(game.player.x/40), Math.floor(game.player.y/40), 10);
        for(let y=0; y<MAP_H; y++) for(let x=0; x<MAP_W; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;
    }
}

function update() {
    try {
        if(game.dead) return;
        if(!game.running) return;
        const p=game.player; const dt=0.016; 
        p.atkCd-=dt; p.attackAnimTimer -= dt;
        if(game.transitionCooldown > 0) game.transitionCooldown -= dt;
        if(p.confusedTimer > 0) p.confusedTimer -= dt;

        const tx=Math.floor(p.x/40), ty=Math.floor(p.y/40);
        game.visibleTiles = computeFOV(tx, ty, 10);
        for(let y=0; y<MAP_H; y++) for(let x=0; x<MAP_W; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;

        let regenMult = (p.path.length > 0 || joystick.active) ? 0.2 : 1.0; 
        let hpRegenBase = p.maxHp * 0.002 * regenMult; let mpRegenBase = p.maxMp * 0.005;
        p.hp = Math.min(p.maxHp, p.hp + hpRegenBase * (1 + p.stats.vit * 0.2) * dt);
        p.mp = Math.min(p.maxMp, p.mp + mpRegenBase * (1 + p.stats.mag * 0.2) * dt);
        p.regenInfo = { hp: hpRegenBase * (1 + p.stats.vit * 0.2), mp: mpRegenBase * (1 + p.stats.mag * 0.2) };
        
        // Buff Timer Update
        for(let i=p.buffs.length-1; i>=0; i--) {
            p.buffs[i].time -= dt;
            if(p.buffs[i].type === 'regen') { p.hp = Math.min(p.maxHp, p.hp + 5 * dt); }
            if(p.buffs[i].type === 'mana_shield' && p.mp <= 0) { p.buffs[i].time = 0; spawnText(p.x, p.y-40, "魔力盾破裂!", "#aaf"); }
            if(p.buffs[i].time <= 0) { p.buffs.splice(i, 1); p.recalc(); }
        }

        if(p.poisonTimer > 0) {
            p.poisonTimer -= dt; p.hp -= p.poisonDmg * dt;
            if(Math.random() < 0.05) spawnText(p.x, p.y-30, "中毒!", "#0f0");
            if(p.poisonTimer <= 0) p.poisonDmg = 0;
        }

        // Input Handling with Confusion
        let inputVec = {x:0, y:0};
        if(joystick.active) {
            inputVec = {...joystick.vector};
        } else if (p.targetEntity || p.path.length > 0) {
            // Path movement handled below
        }

        if(p.confusedTimer > 0) {
            // Randomize input slightly or reverse
            if(Math.random() < 0.1) {
                inputVec.x = (Math.random() - 0.5) * 2;
                inputVec.y = (Math.random() - 0.5) * 2;
            } else {
                inputVec.x *= -1; inputVec.y *= -1; // Reverse controls
            }
        }

        if(joystick.active || p.confusedTimer > 0) {
            let speed=p.moveSpeed; 
            if (p.confusedTimer > 0 && !joystick.active && p.path.length === 0) speed = 0; // Dont move if not trying to

            let nx=p.x + (inputVec.x * speed) * dt; 
            let ny=p.y + (inputVec.y * speed) * dt;
            
            if(!isBlocked(nx,p.y,p)) p.x=nx; 
            if(!isBlocked(p.x,ny,p)) p.y=ny; 
            
            p.path=[]; p.targetEntity=null; 
            if(inputVec.x!==0 || inputVec.y!==0) p.facing=Math.atan2(inputVec.y,inputVec.x);
        } else if(p.targetEntity && !p.targetEntity.dead) {
            const dist=Math.hypot(p.targetEntity.x-p.x, p.targetEntity.y-p.y);
            p.facing = Math.atan2(p.targetEntity.y - p.y, p.targetEntity.x - p.x);
            let dx=p.targetEntity.x-p.x, dy=p.targetEntity.y-p.y; 
            
            if (!p.targetEntity.isEnemy && !p.targetEntity.charmed) {
                 if(dist < 40) {
                    if(p.targetEntity.type === 'CHEST') openChest(p.targetEntity);
                    else if(p.targetEntity.type && p.targetEntity.type.startsWith('NPC')) interactNPC(p.targetEntity); 
                    else if(p.targetEntity.type === 'PORTAL_TOWN') useTownPortal(false); // Go Town
                    else if(p.targetEntity.type === 'PORTAL_DUNGEON') useTownPortal(true); // Go Dungeon (cached)
                    else if(p.targetEntity.isItem) pickup(p.targetEntity);
                    p.targetEntity = null; p.path = [];
                 } else {
                    let moveS = p.moveSpeed*dt; 
                    let mx = (dx/dist*moveS);
                    let my = (dy/dist*moveS);
                    if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                 }
            } else if (p.targetEntity.isEnemy && !p.targetEntity.charmed) {
                let range = (p.equip.mainhand ? ITEM_TYPES[p.equip.mainhand.type].range : 35);
                if (dist <= range) {
                     if(p.attackRequested) { attack(p.targetEntity); p.attackRequested = false; }
                     p.path = [];
                } else {
                     let moveS = p.moveSpeed*dt; 
                     let mx = (dx/dist*moveS);
                     let my = (dy/dist*moveS);
                     if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                }
            }

        } else if(p.path.length>0) {
            let next=p.path[0]; let dx=next.x-p.x, dy=next.y-p.y; let dist=Math.sqrt(dx*dx+dy*dy);
            if(dist<8) p.path.shift(); else { 
                let s=p.moveSpeed; 
                let mx = (dx/dist*s)*dt; 
                let my = (dy/dist*s)*dt;
                if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                if(dx!==0||dy!==0) p.facing=Math.atan2(dy,dx); 
            }
        }

        game.entities.forEach(e=>{
            if(e.type === 'TRAP' && !e.triggered && Math.hypot(e.x-p.x, e.y-p.y) < 20) {
                 e.triggered = true; e.hidden = false; e.icon = '🩸';
                 let dmg = 25 + game.floor * 10; p.hp -= dmg; spawnText(p.x, p.y, `陷阱! -${dmg}`, "red"); AudioSys.sfx('hit');
            }
            if(e.slowTimer > 0) e.slowTimer -= dt;
            if(e.effectTimer > 0) { 
                e.effectTimer -= dt;
                if(e.effectType === 'confused') {
                     if(Math.random() < 0.05) {
                         let victim = game.entities.concat([game.player]).find(v => v!==e && !v.dead && Math.hypot(v.x-e.x, v.y-e.y) < 150);
                         if(victim) {
                             e.target = victim; 
                             let ang = Math.atan2(victim.y - e.y, victim.x - e.x);
                             game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*250, vy:Math.sin(ang)*250, life:1.0, dmg:e.dmg, enemyProj:true}); 
                         }
                     }
                     e.vx = (Math.random()-0.5)*100; e.vy = (Math.random()-0.5)*100;
                     let nx = e.x + e.vx * dt; let ny = e.y + e.vy * dt;
                     if(!isBlocked(nx, ny, e)) { e.x = nx; e.y = ny; }
                }
                if(e.effectTimer <= 0) { e.effectType = null; if(e.charmed) { e.charmed = false; e.isEnemy = true; } }
            }
            
            if(e.isEnemy && !e.dead && !e.charmed && e.effectType !== 'confused'){
                const dist = Math.hypot(p.x-e.x,p.y-e.y);
                const ex = Math.floor(e.x/40), ey = Math.floor(e.y/40);
                const playerVisible = hasLineOfSight(ex, ey, tx, ty);
                if (e.hp < e.maxHp && !e.target) e.target = p; 
                
                // Advanced AI: Evasion for Ranged Attacks (Mid-High Tier)
                if (e.tier >= 2) {
                     // Look for incoming projectiles
                     let incoming = game.projs.find(pr => !pr.enemyProj && Math.hypot(pr.x - e.x, pr.y - e.y) < 60);
                     if (incoming) {
                         // Move perpendicular to projectile velocity
                         let angle = Math.atan2(incoming.vy, incoming.vx);
                         let dodgeAngle = angle + Math.PI / 2;
                         if (Math.random() < 0.5) dodgeAngle = angle - Math.PI / 2;
                         
                         let dodgeSpeed = (e.speed || 75) * 1.5;
                         let dx = Math.cos(dodgeAngle) * dodgeSpeed * dt;
                         let dy = Math.sin(dodgeAngle) * dodgeSpeed * dt;
                         if(!isBlocked(e.x+dx, e.y+dy, e)) { e.x += dx; e.y += dy; }
                     }
                }

                // Advanced AI: Fleeing & Dodging
                let isFleeing = false;
                if (e.hp < e.maxHp * 0.2 && Math.random() < 0.02) { // Low HP Flee Chance
                    e.target = null; 
                    let ang = Math.atan2(e.y - p.y, e.x - p.x); 
                    let fleeX = Math.cos(ang) * 100 * dt;
                    let fleeY = Math.sin(ang) * 100 * dt;
                    if(!isBlocked(e.x + fleeX, e.y + fleeY, e)) { e.x += fleeX; e.y += fleeY; }
                    isFleeing = true;
                }

                if(!isFleeing && ((playerVisible && dist < 300) || e.target === p)) {
                    let stopDist = e.ranged ? (e.range || 200) * 0.8 : 45; // Melee stop dist

                    if (dist > stopDist) {
                        const a=Math.atan2(p.y-e.y,p.x-e.x); 
                        let currentSpeed = (e.speed || 75) * (e.slowTimer > 0 ? 0.5 : 1);
                        let nx=e.x+Math.cos(a)*currentSpeed*dt, ny=e.y+Math.sin(a)*currentSpeed*dt; 
                        if(!isBlocked(nx,e.y, e)) e.x=nx; if(!isBlocked(e.x,ny, e)) e.y=ny;
                    }

                    if (e.ranged && dist < (e.range || 200)) {
                        e.atkCd = (e.atkCd || 0) - dt;
                        if (e.atkCd <= 0) {
                            let ang = Math.atan2(p.y - e.y, p.x - e.x);
                            game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*250, vy:Math.sin(ang)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:e.projIcon, poison: e.poison});
                            e.atkCd = 2.0;
                            if(e.special === 'magic') {
                                game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang+0.3)*250, vy:Math.sin(ang+0.3)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:'🟣'});
                                game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang-0.3)*250, vy:Math.sin(ang-0.3)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:'🟣'});
                            }
                            if(e.special === 'confuse') {
                                // Succubus projectile logic handled in projectile collision
                            }
                        }
                    } else if (!e.ranged && dist < 60) {
                         e.atkCd = (e.atkCd || 0) - dt;
                         if (e.atkCd <= 0) {
                             // Check Evasion
                             if (Math.random() < p.evasion) {
                                 spawnText(p.x, p.y-40, "閃避!", "#6d6");
                             } 
                             // Check Block
                             else if (Math.random() < p.blockChance) {
                                 spawnText(p.x, p.y-40, "格擋!", "#fff");
                                 AudioSys.sfx('hit'); // Block sound
                             }
                             else {
                                 let incDmg = Math.max(1, e.dmg-p.stats.def);
                                 let hasShield = p.buffs.find(b=>b.type==='shield');
                                 if(hasShield) {
                                     if(p.mp >= incDmg) { p.mp -= incDmg; incDmg = 0; }
                                     else { incDmg -= p.mp; p.mp = 0; }
                                 }
                                 if(incDmg > 0) {
                                     p.hp-=incDmg; 
                                     AudioSys.sfx('hit'); 
                                     spawnText(p.x,p.y-30,"-"+Math.floor(incDmg),"red"); 
                                     if(e.poison) { p.poisonTimer = 5.0; p.poisonDmg = 5; spawnText(p.x, p.y, "中毒!", "#0f0"); }
                                     if(e.special === 'lifesteal') { e.hp = Math.min(e.maxHp, e.hp + incDmg); spawnText(e.x, e.y, "+"+incDmg, "#f00"); }
                                 } else {
                                     spawnText(p.x,p.y-30,"吸收", "#0af");
                                 }
                             }
                             game.uiDirty=true;
                             e.atkCd = 1.0;
                         }
                    }
                } else if (!isFleeing && !e.isBoss && !e.target && Math.random() < 0.005) { 
                    let ang = Math.random() * 6.28; e.vx = Math.cos(ang) * 20; e.vy = Math.sin(ang) * 20; e.wanderTime = 1.0 + Math.random(); 
                }
                
                if(e.wanderTime > 0) { let nx = e.x + e.vx * dt; let ny = e.y + e.vy * dt; if(!isBlocked(nx, ny, e)) { e.x = nx; e.y = ny; } e.wanderTime -= dt; }
            }
            
            if((e.type === 'MINION' || e.charmed || e.type === 'TURRET') && !e.dead) {
                if(e.type === 'MINION' || e.type === 'TURRET') { e.life -= dt; if(e.life <= 0) e.dead = true; }
                let target = game.entities.find(t => t.isEnemy && !t.dead && !t.charmed && Math.hypot(t.x-e.x, t.y-e.y) < (e.type==='TURRET'?300:300) && game.visibleTiles[Math.floor(t.y/40)][Math.floor(t.x/40)]);
                
                if(e.type === 'TURRET') { // Hydra
                    if(target) {
                        e.atkCd = (e.atkCd || 0) - dt;
                        if(e.atkCd <= 0) {
                             let ang = Math.atan2(target.y - e.y, target.x - e.x);
                             game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*350, vy:Math.sin(ang)*350, life:1.5, dmg:15 + e.lvl*5, isFireball:true, icon:'🔥'});
                             e.atkCd = 0.8;
                        }
                    }
                } else {
                    let isRangedMinion = e.name.includes('射手') || e.name.includes('巫妖') || e.name.includes('精靈');
                    if(target) { 
                        let dx = target.x - e.x, dy = target.y - e.y; let d = Math.hypot(dx,dy); 
                        let stopDist = isRangedMinion ? 150 : 30;

                        if(d > stopDist) { 
                            e.x += dx/d * 90 * dt; e.y += dy/d * 90 * dt; 
                        } else { 
                            e.atkCd = (e.atkCd || 0) - dt;
                            if(e.atkCd <= 0) {
                                if (isRangedMinion) {
                                    let ang = Math.atan2(target.y - e.y, target.x - e.x);
                                    game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*300, vy:Math.sin(ang)*300, life:1.5, dmg:(e.dmg||15), isArrow: true});
                                } else {
                                    target.hp -= (e.dmg || 10); spawnText(target.x, target.y, (e.dmg||10), "#eee");
                                    if(target.hp<=0) killEnemy(target); 
                                }
                                e.atkCd = 1.0;
                            }
                        } 
                    } else { 
                        let dx = p.x - e.x, dy = p.y - e.y; let d = Math.hypot(dx,dy); 
                        if(d > 80) { e.x += dx/d * 100 * dt; e.y += dy/d * 100 * dt; } 
                    }
                }
            }
        });

        for(let i=game.projs.length-1;i>=0;i--){ 
            const pr=game.projs[i]; 
            if(pr.delay) { 
                pr.delay -= dt; if(pr.delay <= 0) { pr.delay = 0; pr.life = 0.2; AudioSys.sfx('hit'); game.entities.forEach(e => { if(e.isEnemy && !e.dead && Math.hypot(e.x-pr.x, e.y-pr.y) < 60) { e.hp -= pr.dmg; spawnText(e.x, e.y, pr.dmg, "#f00"); if(e.hp<=0) killEnemy(e); } }); } continue;
            }
            if(pr.isStatic) { 
                pr.life -= dt;
                if(pr.life<=0) game.projs.splice(i,1); else { game.entities.forEach(e => { if(e.isEnemy && !e.dead && Math.hypot(e.x-pr.x, e.y-pr.y) < 30 && Math.random() < 0.1) { e.hp -= pr.dmg; spawnText(e.x, e.y, pr.dmg, "#f60"); if(e.hp<=0) killEnemy(e); } }); } continue; 
            }
            
            pr.x+=pr.vx*dt; pr.y+=pr.vy*dt; pr.life-=dt; 
            if(pr.life<=0||isSolid(pr.x,pr.y)){game.projs.splice(i,1);continue;} 
            
            if (pr.enemyProj) {
                if (Math.hypot(p.x - pr.x, p.y - pr.y) < 20) {
                     // Check Evasion/Block for projectiles
                     if (Math.random() < p.evasion) { spawnText(p.x, p.y-40, "閃避!", "#6d6"); }
                     else if (Math.random() < p.blockChance) { spawnText(p.x, p.y-40, "格擋!", "#fff"); AudioSys.sfx('hit'); }
                     else {
                        p.hp -= Math.max(1, pr.dmg - p.stats.def);
                        spawnText(p.x, p.y-30, "-"+Math.floor(Math.max(1, pr.dmg - p.stats.def)), "red");
                        if(pr.icon === '❤️') { // Succubus charm/confuse
                            p.confusedTimer = 4.0; spawnText(p.x, p.y-50, "魅惑!", "#f0f");
                        }
                        if(pr.poison) { p.poisonTimer = 5.0; p.poisonDmg = 5; spawnText(p.x, p.y, "中毒!", "#0f0"); }
                        AudioSys.sfx('hit'); game.uiDirty=true;
                     }
                     game.projs.splice(i,1);
                }
            } else {
                let hit=game.entities.find(e=>e.isEnemy && !e.charmed && !e.dead && Math.hypot(e.x-pr.x,e.y-pr.y)<35); 
                if(hit){ 
                    let finalDmg = pr.dmg;
                    // Spells don't crit or kill chance, physics only
                    if(pr.isArrow) {
                        if(Math.random() < p.critChance) { finalDmg *= 2; spawnText(hit.x, hit.y-50, "爆擊!", "#ff0"); }
                        if(!hit.isBoss && Math.random() < p.killChance) { finalDmg = hit.hp + 999; spawnText(hit.x, hit.y-60, "必殺!", "#f00"); }
                    }
                    
                    finalDmg = Math.max(1, finalDmg - (hit.def || 0));

                    hit.hp-=finalDmg; hit.target = p; 
                    if(pr.isIce) hit.slowTimer = 3.0;
                    if(pr.effect === 'poison') { hit.poisonTimer = 5.0; hit.poisonDmg = 5; } 
                    if(pr.effect === 'confused') { hit.effectType = 'confused'; hit.effectTimer = 5.0; spawnText(hit.x, hit.y-40, "混亂!", "#f0f"); }
                    if(pr.effect === 'charmed') { 
                        hit.effectType = 'charmed'; hit.charmed = true; hit.isEnemy = false; hit.effectTimer = 8.0; 
                        spawnText(hit.x, hit.y-40, "魅惑!", "#f66"); 
                        if(game.player.targetEntity === hit) { game.player.targetEntity = null; game.player.path = []; }
                    }
                    AudioSys.sfx('hit'); spawnText(hit.x,hit.y-30,Math.floor(finalDmg), pr.isIce?"#0af":"#fff"); 
                    if(hit.hp<=0) killEnemy(hit); game.projs.splice(i,1); 
                } 
            }
        }
        if(p.hp <= 0 && !game.dead) { handlePlayerDeath(); }
        game.cam.x+=(p.x-game.cam.x)*0.12; game.cam.y+=(p.y-game.cam.y)*0.12; 
        updateUI(); 
        if(typeof drawMinimap === 'function') drawMinimap();
    } catch(e) { console.log(e); }
}

function drawMinimap() {
    if(!minimapCtx || !game.running) return;
    minimapCtx.fillStyle = '#000'; 
    minimapCtx.fillRect(0,0,150,150); 
    const cw = 150/60; // Scale based on view window (60x60)
    
    // Center view on player
    let pcx = Math.floor(game.player.x / 40);
    let pcy = Math.floor(game.player.y / 40);
    let startX = pcx - 30;
    let startY = pcy - 30;
    
    for(let dy=0; dy<60; dy++) {
        for(let dx=0; dx<60; dx++) {
            let tx = startX + dx;
            let ty = startY + dy;
            
            if(tx >= 0 && tx < MAP_W && ty >= 0 && ty < MAP_H) {
                if(game.visited[ty] && game.visited[ty][tx]) { 
                    if(game.map[ty][tx] === 1) {
                        minimapCtx.fillStyle = '#444'; // Wall
                    } else {
                        minimapCtx.fillStyle = '#888'; // Floor
                    }
                    
                    if(game.map[ty][tx] === 2) minimapCtx.fillStyle = '#0f0'; // Down (Green)
                    if(game.map[ty][tx] === 6) minimapCtx.fillStyle = '#aaf'; // Up (Blue)
                    
                    minimapCtx.fillRect(dx*cw, dy*cw, cw, cw); 
                }
            }
        }
    }
    
    // Player dot (Always center)
    minimapCtx.fillStyle = '#0af'; minimapCtx.beginPath(); minimapCtx.arc(75, 75, 3, 0, Math.PI*2); minimapCtx.fill();
    
    // Entities relative to window
    game.entities.forEach(e => { 
        if (e.hidden) return;
        let ex = Math.floor(e.x/40);
        let ey = Math.floor(e.y/40);
        
        // Check if entity is within the window
        if(ex >= startX && ex < startX + 60 && ey >= startY && ey < startY + 60) {
            if(!e.dead && game.visited[ey] && game.visited[ey][ex]) { 
                let dcx = (ex - startX) * cw; 
                let dcy = (ey - startY) * cw; 
                
                if(e.isEnemy && !e.charmed) { minimapCtx.fillStyle = '#f00'; if(e.isBoss) { minimapCtx.fillStyle = '#a0f'; minimapCtx.beginPath(); minimapCtx.arc(dcx,dcy,4,0,Math.PI*2); minimapCtx.fill(); } else minimapCtx.fillRect(dcx-1, dcy-1, 2, 2); } 
                else if(e.type === 'CHEST') { minimapCtx.fillStyle = '#fd0'; minimapCtx.fillRect(dcx-1, dcy-1, 3, 3); } 
                else if(e.type === 'MINION' || e.charmed || e.type === 'TURRET') { minimapCtx.fillStyle = '#0ff'; minimapCtx.fillRect(dcx-1, dcy-1, 2, 2); }
                else if(e.type === 'PORTAL_TOWN' || e.type === 'PORTAL_DUNGEON') { minimapCtx.fillStyle = '#fff'; minimapCtx.beginPath(); minimapCtx.arc(dcx,dcy,3,0,Math.PI*2); minimapCtx.fill(); } // White portal
                else if(e.type && e.type.startsWith('NPC')) { minimapCtx.fillStyle = '#fa0'; minimapCtx.fillRect(dcx-1, dcy-1, 3, 3); }
            } 
        }
    });
}

function draw() {
    try {
        if(!game.running || !gameCtx) return;
        gameCtx.fillStyle = game.floor === 0 ? '#223322' : '#000';
        gameCtx.fillRect(0,0,gameCanvas.width,gameCanvas.height);
        gameCtx.save(); gameCtx.translate(gameCanvas.width/2-game.cam.x, gameCanvas.height/2-game.cam.y);
        for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
            if(Math.abs(x*40 - game.cam.x) > gameCanvas.width/2 + 60) continue; 
            if(Math.abs(y*40 - game.cam.y) > gameCanvas.height/2 + 60) continue;
            let visible = game.floor === 0 ? true : (game.visibleTiles[y] && game.visibleTiles[y][x]); 
            let visited = game.floor === 0 ? true : (game.visited[y] && game.visited[y][x]);
            if (!visible && !visited) continue; 
            const t=game.map[y][x]; 
            if (visible) {
                if(t===1){ gameCtx.fillStyle=game.theme.w; gameCtx.beginPath(); gameCtx.arc(x*40+20,y*40+20,24,0,Math.PI*2); gameCtx.fill(); }
                else { 
                    gameCtx.fillStyle = (game.floor === 0) ? ((x%2==y%2)?'#284020':'#253a20') : game.theme.f; 
                    gameCtx.fillRect(x*40,y*40,40,40); gameCtx.strokeStyle='#000'; gameCtx.strokeRect(x*40,y*40,40,40); 
                    if(t===2) { gameCtx.font='22px serif'; gameCtx.fillStyle='#aaa'; gameCtx.fillText('⬇️', x*40+5,y*40+30); } 
                    if(t===6) { gameCtx.font='22px serif'; gameCtx.fillStyle='#aaa'; gameCtx.fillText('⬆️', x*40+5,y*40+30); } 
                }
            } else if (visited) {
                if(t===1){ gameCtx.fillStyle='#111'; gameCtx.beginPath(); gameCtx.arc(x*40+20,y*40+20,24,0,Math.PI*2); gameCtx.fill(); }
                else { gameCtx.fillStyle='#050505'; gameCtx.fillRect(x*40,y*40,40,40); gameCtx.strokeStyle='#111'; gameCtx.strokeRect(x*40,y*40,40,40); }
            }
        }
        game.items.forEach(i=>{ if(game.floor===0 || (game.visibleTiles[Math.floor(i.y/40)] && game.visibleTiles[Math.floor(i.y/40)][Math.floor(i.x/40)])) { gameCtx.font='22px serif'; gameCtx.fillStyle='#fd0'; gameCtx.fillText(i.type==='GOLD'?'💰':ITEM_TYPES[i.type].icon, i.x-10, i.y+5); } });
        game.entities.forEach(e=>{ 
            if(e.hidden) return;
            let ex = Math.floor(e.x/40), ey = Math.floor(e.y/40);
            if(!e.dead && (game.floor === 0 || (game.visibleTiles[ey] && game.visibleTiles[ey][ex]))){ 
                if (e.isElite) {
                    gameCtx.save();
                    gameCtx.fillStyle = 'rgba(200, 0, 255, 0.3)';
                    gameCtx.beginPath();
                    gameCtx.arc(e.x, e.y, 25, 0, Math.PI * 2);
                    gameCtx.fill();
                    gameCtx.restore();
                }
                gameCtx.font=(e.size?e.size+4:26)+'px serif'; gameCtx.fillText(e.icon, e.x-13,e.y+9); 
                if(e.subIcon) { gameCtx.font='14px serif'; gameCtx.fillText(e.subIcon, e.x+5, e.y+15); } 
                if(e.slowTimer > 0) { gameCtx.globalAlpha = 0.5; gameCtx.fillStyle = '#0af'; gameCtx.beginPath(); gameCtx.arc(e.x,e.y,20,0,Math.PI*2); gameCtx.fill(); gameCtx.globalAlpha = 1; } 
                if(e.effectType === 'confused') { gameCtx.font='16px serif'; gameCtx.fillText('?', e.x, e.y-30); }
                if(e.effectType === 'charmed') { gameCtx.font='16px serif'; gameCtx.fillText('❤️', e.x, e.y-30); }
                if(e.isEnemy && !e.charmed){ gameCtx.fillStyle='red'; gameCtx.fillRect(e.x-15,e.y-25,30,4); gameCtx.fillStyle='#0f0'; gameCtx.fillRect(e.x-15,e.y-25,30*(e.hp/e.maxHp),4); } 
                else { gameCtx.fillStyle='#fff'; gameCtx.font='12px serif'; gameCtx.fillText(e.name, e.x-15, e.y-25); }
                if(e.type === 'MINION' || e.charmed || e.type === 'TURRET') { gameCtx.fillStyle='#0ff'; gameCtx.fillRect(e.x-10,e.y-20,20,3); }
            } 
        });
        if(game.player) {
            let p = game.player;
            gameCtx.save(); gameCtx.translate(p.x, p.y);
            gameCtx.font='32px serif'; gameCtx.fillText(p.icon, -16, 12);
            if(p.equip.helm) { 
                gameCtx.drawImage(helmImg, -16, -28, 32, 32); 
            }
            if(p.confusedTimer > 0) { gameCtx.font='16px serif'; gameCtx.fillText('💫', 0, -40); }
            
            // Draw Buff Indicators
            if(p.buffs.length > 0) {
                gameCtx.font='10px serif';
                p.buffs.forEach((b, i) => {
                    gameCtx.fillText(b.icon, -20 + i*12, -30);
                });
            }

            let mainHand = p.equip.mainhand; let offHand = p.equip.offhand;
            if(mainHand) {
                gameCtx.save(); let handOffset = 15;
                gameCtx.rotate(p.facing); gameCtx.translate(handOffset, 5); 
                if (p.attackAnimTimer > 0) { gameCtx.rotate(Math.sin(p.attackAnimTimer * 20) * 1.5); }
                
                // Correct Axe Rotation
                if(mainHand.type.includes('AXE')) {
                    gameCtx.rotate(Math.PI / 2); // 90 degree adjustment for axe
                } else {
                    gameCtx.rotate(Math.PI / 4); 
                }
                
                let scale = ITEM_TYPES[mainHand.type].scale || 1.0;
                gameCtx.scale(scale, scale);
                gameCtx.font='20px serif'; gameCtx.fillText(ITEM_TYPES[mainHand.type].icon, -10, 5); 
                gameCtx.restore();
            }
            if(offHand) {
                gameCtx.save(); gameCtx.rotate(p.facing); gameCtx.translate(10, -5); 
                if (offHand.type === 'DAGGER' && p.attackAnimTimer > 0 && p.targetEntity && Math.hypot(p.targetEntity.x-p.x, p.targetEntity.y-p.y) < 60) {
                     gameCtx.rotate(-Math.sin(p.attackAnimTimer * 20) * 1.5); 
                }
                gameCtx.rotate(Math.PI / 4); let scale = ITEM_TYPES[offHand.type].scale || 1.0;
                gameCtx.scale(scale, scale);
                gameCtx.font='18px serif'; gameCtx.fillText(ITEM_TYPES[offHand.type].icon, -10, 5);
                gameCtx.restore();
            }
            if(p.attackAnimTimer > 0) {
                gameCtx.rotate(p.facing); gameCtx.fillStyle = 'rgba(255,255,255,0.3)'; 
                gameCtx.beginPath(); gameCtx.arc(0, 0, 50, -0.5, 0.5); gameCtx.lineTo(0,0); gameCtx.fill(); 
            }
            if(p.targetEntity) { gameCtx.strokeStyle = 'rgba(255,0,0,0.3)'; gameCtx.beginPath(); gameCtx.moveTo(0, 0); gameCtx.lineTo(p.targetEntity.x - p.x, p.targetEntity.y - p.y); gameCtx.stroke(); }
            gameCtx.restore();
        }
        game.projs.forEach(p=>{ 
            if(game.floor===0 || (game.visibleTiles[Math.floor(p.y/40)] && game.visibleTiles[Math.floor(p.y/40)][Math.floor(p.x/40)])) {
                if(p.delay) { gameCtx.fillStyle='rgba(255,0,0,0.3)'; gameCtx.beginPath(); gameCtx.arc(p.x,p.y,60,0,Math.PI*2); gameCtx.fill(); } 
                else if (p.isStatic) { gameCtx.fillStyle='rgba(255,100,0,0.6)'; gameCtx.beginPath(); gameCtx.arc(p.x,p.y,20,0,Math.PI*2); gameCtx.fill(); } 
                else { 
                    if (p.icon) { 
                        gameCtx.save();
                        gameCtx.translate(p.x, p.y);
                        // Rotate fireball to face direction
                        if(p.isFireball) {
                             gameCtx.rotate(Math.atan2(p.vy, p.vx) + Math.PI/2); // Adjust -90deg to point emoji top
                        }
                        gameCtx.font='20px serif'; 
                        gameCtx.fillText(p.icon, -10, 5);
                        gameCtx.restore();
                    }
                    else if (p.isArrow) { gameCtx.save(); gameCtx.translate(p.x, p.y); gameCtx.rotate(Math.atan2(p.vy, p.vx)); gameCtx.font='20px serif'; gameCtx.fillText('➳', 0, 0); gameCtx.restore(); }
                    else if (p.isIce) { gameCtx.fillStyle='#0af';gameCtx.beginPath();gameCtx.arc(p.x,p.y,5,0,Math.PI*2);gameCtx.fill(); }
                    else { gameCtx.fillStyle='#fa0';gameCtx.beginPath();gameCtx.arc(p.x,p.y,5,0,Math.PI*2);gameCtx.fill(); }
                } 
            }
        });
        
        let hoverTarget = getTargetAt(mouse.wx, mouse.wy);
        let hud = document.getElementById('monster-hud');
        if (hoverTarget && hoverTarget.isEnemy) {
            hud.style.display = 'block';
            let eliteText = hoverTarget.isElite ? "<span style='color:#d0f'>(菁英)</span> " : "";
            let defText = hoverTarget.def > 0 ? ` [防${hoverTarget.def}]` : "";
            hud.innerHTML = `${eliteText}${hoverTarget.name} - HP: ${Math.floor(hoverTarget.hp)}/${hoverTarget.maxHp}${defText}`;
        } else {
            hud.style.display = 'none';
        }
        
        // Draw minimap in game loop to update it
        drawMinimap();
        
        gameCtx.restore();
    } catch(e) { console.log(e); }
}

function getTargetAt(x,y){ 
    let tx = Math.floor(x/40); let ty = Math.floor(y/40);
    if (tx<0||tx>=MAP_W||ty<0||ty>=MAP_H) return null;
    if(game.floor > 0 && (!game.visibleTiles[ty] || !game.visibleTiles[ty][tx])) return null;
    let e = game.entities.find(e => !e.dead && !e.hidden && e.isEnemy && Math.hypot(e.x - x, e.y - y) < 40);
    if (e) return e;
    e = game.entities.find(e => !e.dead && !e.hidden && !e.isEnemy && e.type !== 'MINION' && !e.charmed && e.type !== 'TURRET' && Math.hypot(e.x - x, e.y - y) < 40);
    if (e) return e;
    let i = game.items.find(i => Math.hypot(i.x - x, i.y - y) < 40);
    return i;
}

function handleDropToInventory(e) { e.preventDefault(); if(!game.shopOpen) return; const shopIdx = e.dataTransfer.getData('shopIdx'); if(shopIdx && shopIdx !== "") { let it = game.shopItems[shopIdx]; if(game.player.gold >= it.price && game.player.inv.length < 40){ game.player.gold -= it.price; game.player.inv.push(JSON.parse(JSON.stringify(it))); game.uiDirty=true; AudioSys.sfx('coin'); } else { alert('金幣不足或背包已滿'); } } }
function handleDropToEquip(e, slot) { e.preventDefault(); const idx = e.dataTransfer.getData('idx'); if (idx === "") return; const it = game.player.inv[idx]; if (it) { game.player.equipItem(it, idx, slot); } }
function buyItem(idx) { let it = game.shopItems[idx]; if(game.player.gold >= it.price && game.player.inv.length < 40){ game.player.gold -= it.price; game.player.inv.push(JSON.parse(JSON.stringify(it))); game.uiDirty=true; AudioSys.sfx('coin'); } else { alert('金幣不足或背包已滿'); } }
function handleShopDragStart(e, idx) { e.dataTransfer.setData('shopIdx', idx); e.dataTransfer.effectAllowed = "copy"; }
function killEnemy(e){ 
    e.dead=true; AudioSys.sfx('die'); 
    let xpReq = 100 * Math.pow(2.0, game.player.lvl-1); 
    let levelDiff = Math.max(0, game.player.lvl - (e.lvl||1));
    let xpMult = Math.max(0.1, 1.0 - levelDiff * 0.2);
    let xpGain = (30 + (e.maxHp/3)) * xpMult;
    game.player.xp += xpGain; 
    spawnText(e.x, e.y, "+"+Math.floor(xpGain)+" XP", "#0af"); 
    if(game.player.xp >= xpReq){ game.player.lvl++; game.player.xp=0; game.player.pts+=5; game.player.hp = game.player.maxHp; game.player.mp = game.player.maxMp; game.player.recalc(); AudioSys.sfx('level'); spawnText(game.player.x, game.player.y, "升級!", "#fd0"); } 
    game.items.push({x:e.x,y:e.y,type:'GOLD',val:randInt(15,40), isItem:true}); 
    if(e.isElite) { game.items.push(new ItemClass(game.floor, e.x, e.y, true)); spawnText(e.x, e.y - 20, "菁英掉落!", "#d0f"); } else if(Math.random()<0.30 || e.isBoss) { game.items.push(new ItemClass(game.floor,e.x,e.y)); }
    if(e.isBoss) { spawnText(e.x, e.y, "BOSS 擊殺！", "#f0f"); let bx = Math.floor(e.x/40), by = Math.floor(e.y/40); game.map[by][bx] = 2; } 
    game.uiDirty = true; 
}
function openChest(e) { if(e.dead) return; e.dead = true; e.icon = '📭'; if (e.trapped) { let dmg = 50 + game.floor * 10; game.player.hp -= dmg; spawnText(game.player.x, game.player.y, `爆炸! -${dmg}`, "red"); AudioSys.sfx('hit'); game.projs.push({x:e.x, y:e.y, vx:0, vy:0, life:0.5, dmg:0, isStatic:true, icon:'💥'}); } else { AudioSys.sfx('coin'); spawnText(e.x, e.y, "開啟寶箱!", "#fd0"); } game.items.push({x:e.x,y:e.y,type:'GOLD',val:randInt(50,150), isItem:true}); game.items.push(new ItemClass(game.floor,e.x,e.y)); game.items.push(new ItemClass(game.floor,e.x+10,e.y)); }
function pickup(it){ if(it.type==='GOLD') { game.player.gold+=it.val; } else { if(game.player.inv.length >= 40) { spawnText(game.player.x, game.player.y, "背包已滿!", "#f55"); return; } game.player.inv.push(it); } AudioSys.sfx('coin'); game.items=game.items.filter(x=>x!==it); game.uiDirty=true; }
function attack(e){ 
    if(game.player.atkCd > 0) return; 
    let p=game.player; 
    let mainHand = p.equip.mainhand; let offHand = p.equip.offhand;
    let dist = Math.hypot(e.x - p.x, e.y - p.y);
    let weapon = mainHand; let useDagger = false;
    if (mainHand && (mainHand.type === 'BOW' || mainHand.type === 'CROSSBOW')) {
        if (dist < 60) { if (offHand && offHand.type === 'DAGGER') { useDagger = true; weapon = offHand; } else { spawnText(p.x, p.y-30, "太近了(需匕首)", "#aaa"); return; } }
    }
    let isRanged = mainHand && (mainHand.type === 'BOW' || mainHand.type === 'CROSSBOW') && !useDagger;
    if(isRanged) AudioSys.sfx('step'); else AudioSys.sfx('hit');
    let speed = weapon ? (ITEM_TYPES[weapon.type].speed || 0.5) : 0.4;
    p.atkCd = speed; p.attackAnimTimer = 0.2; 
    for(let key in p.equip) { if(p.equip[key] && p.equip[key].effects) { p.equip[key].effects.forEach(eff => { if(Math.random() < eff.chance) { if(eff.type === '緩速') { e.slowTimer = 3.0; spawnText(e.x, e.y-40, "緩速!", "#0af"); } if(eff.type === '暈眩') { e.atkCd += 2.0; spawnText(e.x, e.y-40, "暈眩!", "#ff0"); } if(eff.type === '中毒') { e.poisonTimer = 5.0; e.poisonDmg = eff.val; spawnText(e.x, e.y, "中毒!", "#0f0"); } if(eff.type === '燃燒') { e.hp -= eff.val; spawnText(e.x, e.y, "燃燒!", "#f60"); } } }); } }
    if(isRanged) { let ang = Math.atan2(e.y - p.y, e.x - p.x); game.projs.push({x:p.x, y:p.y, vx:Math.cos(ang)*400, vy:Math.sin(ang)*400, life:1.5, dmg:p.stats.atk, isArrow:true}); } 
    else if(e) { 
        let dmg = p.stats.atk;
        if (useDagger) { let rangedAtk = (mainHand && mainHand.stats.atk) || 0; let daggerAtk = (offHand && offHand.stats.atk) || 0; dmg = Math.max(1, p.stats.atk - rangedAtk + Math.floor(daggerAtk * 0.5)); }
        if(Math.random() < p.critChance) { dmg *= 2; spawnText(e.x, e.y-40, "爆擊!", "#ff0"); }
        if(!e.isBoss && Math.random() < p.killChance) { dmg = 9999; spawnText(e.x, e.y-50, "必殺!", "#f00"); }
        
        let actualDmg = Math.max(1, dmg - (e.def || 0));
        e.hp -= actualDmg; spawnText(e.x, e.y-20, Math.floor(actualDmg), "#fff"); if(e.hp<=0) killEnemy(e); 
    } 
}
function handleDropToWorld(e) { const idx=e.dataTransfer.getData('idx'); if(idx==="")return; const it=game.player.inv[idx]; game.items.push({...it,x:game.player.x,y:game.player.y}); game.player.inv.splice(idx,1); game.uiDirty=true; }
function handleDropToShop(e) { e.preventDefault(); if(!game.shopOpen) return; const idx = e.dataTransfer.getData('idx'); if(idx==="")return; const it=game.player.inv[idx]; if(it) { game.player.gold += Math.floor(it.price/2); game.player.inv.splice(idx,1); game.uiDirty=true; AudioSys.sfx('coin'); } }
function handleDropToHotbar(e, slotIdx) { 
    e.preventDefault(); 
    // From Inv
    const invIdx = e.dataTransfer.getData('idx'); 
    if (invIdx !== "") {
        const it = game.player.inv[invIdx];
        if(!it) return;
        
        // Items 0-3
        if(slotIdx >= 0 && slotIdx <= 3) {
            if(['POTION','MANA_POTION','SCROLL_TP'].includes(it.type)) {
                // If exists, stack? For now just replace
                if(game.player.hotbar[slotIdx]) {
                    // Logic to swap or stack would go here, keep simple
                    game.player.inv.push(game.player.hotbar[slotIdx]);
                }
                game.player.hotbar[slotIdx] = {type:it.type, name:it.name, count:1}; // Simplified: 1 count from inv
                // Remove from inv
                game.player.inv.splice(invIdx, 1);
            } else { alert("只能放置藥水或卷軸"); }
        }
        game.uiDirty = true;
        return;
    }
}

function useHotbar(idx) {
    if(idx >= 0 && idx <= 3) { // Items
        let item = game.player.hotbar[idx];
        if(item && item.count > 0) {
            if(item.type === 'POTION') game.player.hp = Math.min(game.player.maxHp, game.player.hp + 50);
            if(item.type === 'MANA_POTION') game.player.mp = Math.min(game.player.maxMp, game.player.mp + 50);
            if(item.type === 'SCROLL_TP') useTownPortal(false);
            item.count--;
            if(item.count <= 0) game.player.hotbar[idx] = null;
            game.uiDirty = true; AudioSys.sfx('coin');
        }
    } else if(idx >= 4 && idx <= 7) { // Spells
        let spellKey = game.player.hotbar[idx];
        if(spellKey) {
            game.player.activeSpell = spellKey;
            game.uiDirty = true;
        }
    }
}

function unequip(s){ let p=game.player; if(p.equip[s] && p.inv.length < 40){ p.inv.push(p.equip[s]); p.equip[s]=null; p.recalc(); game.uiDirty=true; } }
function addStat(s){ if(game.player.pts>0){ game.player.baseStats[s]++; game.player.pts--; game.player.recalc(); game.uiDirty=true; } }
function toggleInventory(){ let w=document.getElementById('inventory-window'); w.style.display=w.style.display==='flex'?'none':'flex'; game.uiDirty=true; if(w.style.display==='none') document.getElementById('tooltip').style.display='none'; document.getElementById('shop-window').style.display='none'; document.getElementById('spellbook-window').style.display='none'; }
function toggleSpellBook(){ let w=document.getElementById('spellbook-window'); w.style.display=w.style.display==='block'?'none':'block'; if(w.style.display==='block') renderSpellBook(); else document.getElementById('tooltip').style.display='none'; }
function renderSpellBook() {
    let g = document.getElementById('spell-grid'); g.innerHTML = '';
    Object.keys(game.player.spells).forEach(k => {
        let d = document.createElement('div'); d.className = 'spell-icon'; d.innerText = SPELLS[k].icon;
        let lv = document.createElement('div'); lv.className = 'spell-lvl'; lv.innerText = game.player.spells[k];
        d.appendChild(lv);
        d.draggable = true;
        d.onclick = () => { game.player.activeSpell = k; game.uiDirty = true; };
        d.oncontextmenu = (e) => {
            e.preventDefault();
            for(let i=4; i<8; i++) { if(!game.player.hotbar[i]) { game.player.hotbar[i] = k; game.uiDirty=true; return; } }
            game.player.hotbar[4] = k; game.uiDirty=true;
        };
        d.onmouseenter = (e) => showSpellTip(k, e, true);
        d.onmouseleave = hideTip;
        g.appendChild(d);
    });
}

function openShop(t){ game.shopOpen=t; document.getElementById('shop-window').style.display='flex'; document.getElementById('shop-title').innerText = t.name + "的商店"; let s=document.getElementById('shop-items'); s.innerHTML=''; game.shopItems = []; for(let i=0;i<6;i++){ let it=new ItemClass(game.player.lvl,0,0); game.shopItems.push(it); let d=document.createElement('div'); d.className='shop-item'; d.draggable=true; d.ondragstart=(e)=>handleShopDragStart(e, i); d.ondblclick=()=>buyItem(i); d.onmouseenter=(e)=>showTip(it,e); d.onmouseleave=hideTip; d.innerHTML=`<span style="color:${it.rarity.col}">${ITEM_TYPES[it.type].icon} ${it.name}</span><span>${it.price} G</span>`; s.appendChild(d); } }
function closeShop(){ game.shopOpen=null; document.getElementById('shop-window').style.display='none'; document.getElementById('tooltip').style.display='none'; }
function updateUI() { 
    const p=game.player; if(!p)return; 
    document.getElementById('hp-fill').style.height=(Math.max(0, p.hp)/p.maxHp*100)+'%'; 
    document.getElementById('hp-text').innerText=Math.floor(Math.max(0, p.hp)); 
    document.getElementById('mp-fill').style.height=(Math.max(0, p.mp)/p.maxMp*100)+'%'; 
    document.getElementById('mp-text').innerText=Math.floor(Math.max(0, p.mp)); 
    document.getElementById('xp-bar-fill').style.width=(Math.min(100, (p.xp / (100 * Math.pow(2.0, p.lvl-1))) * 100))+'%'; 
    document.getElementById('ui-level').innerText=p.lvl; 
    
    // Update Hotbar
    for(let i=0; i<4; i++) {
        let it = p.hotbar[i];
        document.getElementById(`hb-icon-${i}`).innerText = it ? ITEM_TYPES[it.type].icon : "";
        document.getElementById(`hb-qty-${i}`).innerText = it ? it.count : "";
    }
    for(let i=4; i<8; i++) {
        let sk = p.hotbar[i];
        let el = document.getElementById(`slot-spell-${i-4}`);
        document.getElementById(`hb-icon-${i}`).innerText = sk ? SPELLS[sk].icon : "";
        document.getElementById(`hb-lvl-${i}`).innerText = sk ? `Lv${p.spells[sk]}` : "";
        if(p.activeSpell === sk && sk) el.classList.add('active-spell'); else el.classList.remove('active-spell');
    }
    
    // Update Spell Orb
    if(p.activeSpell) {
        document.getElementById('current-spell-icon').innerText = SPELLS[p.activeSpell].icon;
        document.getElementById('current-spell-lvl').innerText = p.spells[p.activeSpell];
    } else {
        document.getElementById('current-spell-icon').innerText = "";
        document.getElementById('current-spell-lvl').innerText = "";
    }

    if(game.uiDirty) updateInventoryUI(); 
}
function updateInventoryUI() { 
    const p=game.player; 
    const g=document.getElementById('inventory-grid'); g.innerHTML=''; 
    p.inv.forEach((it,i)=>{ 
        const el=document.createElement('div'); el.className='inv-slot'; el.style.borderColor=it.rarity.col; 
        if(it.type === 'HELM') {
            el.innerHTML = `<img src="${HELM_ICON_SRC}" style="width:32px;height:32px;">`;
        } else {
            el.innerText=it.type==='SPELL_BOOK'?'📘':ITEM_TYPES[it.type].icon; 
        }
        el.draggable=true; el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; el.ondragstart=(e)=>e.dataTransfer.setData('idx',i); el.ondblclick=()=>p.equipItem(it,i); g.appendChild(el); 
    }); 
    
    ['str','dex','mag','vit'].forEach(k=>{ 
        document.getElementById('stat-'+k).innerText=p.stats[k]; 
        let btn = document.getElementById('plus-'+k);
        if(p.pts>0) {
            btn.classList.add('active');
            btn.onclick = () => addStat(k); // Rebind to ensure functionality
        } else {
            btn.classList.remove('active');
            btn.onclick = null;
        }
    }); 
    document.getElementById('stat-hpregen').innerText = p.regenInfo ? p.regenInfo.hp.toFixed(1) : 0; 
    document.getElementById('stat-mpregen').innerText = p.regenInfo ? p.regenInfo.mp.toFixed(1) : 0; 
    document.getElementById('stat-points').innerText=p.pts; 
    document.getElementById('stat-atk').innerText=p.stats.atk; 
    document.getElementById('stat-def').innerText=p.stats.def; 
    document.getElementById('stat-crit').innerText=Math.floor(p.critChance*100); 
    document.getElementById('stat-kill').innerText=(p.killChance*100).toFixed(1); 
    document.getElementById('stat-block').innerText=Math.floor(p.blockChance*100);
    document.getElementById('stat-evade').innerText=Math.floor(p.evasion*100);
    document.getElementById('ui-gold-inv').innerText=p.gold; 
    document.getElementById('inv-count').innerText=p.inv.length; 
    
    for(let k in p.equip){ 
        let el=document.getElementById('slot-'+k), it=p.equip[k]; 
        if(it){
            if(k==='helm') {
                el.innerHTML = `<img src="${HELM_ICON_SRC}" style="width:32px;height:32px;">`;
            } else {
                el.innerText=ITEM_TYPES[it.type].icon;
            }
            el.style.borderColor=it.rarity.col;el.classList.add('equipped'); el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; 
        } else {
            el.innerText='';el.style.borderColor='#444';el.classList.remove('equipped'); el.onmouseenter=null;
            if(k==='helm') el.innerHTML = '<span class="doll-label">頭部</span>';
            if(k==='gloves') el.innerHTML = '<span class="doll-label">手套</span>';
        } 
    } 
    game.uiDirty=false; 
}
function updateSpellIcon() { game.uiDirty = true; }
function showTip(it,e){ let t=document.getElementById('tooltip'); t.style.display='block'; let left = e.clientX + 15; if (left + 240 > window.innerWidth) left = e.clientX - 250; t.style.left=left+'px'; t.style.top=(e.clientY+15)+'px'; document.getElementById('tip-title').innerText=it.name; document.getElementById('tip-title').style.color=it.rarity.col; let statsText = ''; if(it.type === 'SPELL_BOOK') statsText = '點擊兩下以學習/升級'; else if (['POTION','MANA_POTION','SCROLL_TP'].includes(it.type)) { statsText = '消耗品 (可放置於快捷列 1-4)'; } else { statsText = `等級: ${it.lvl}\n售價: ${it.price}G\n`; if(it.stats.atk) statsText += `攻擊: +${it.stats.atk}\n`; if(it.stats.def) statsText += `防禦: +${it.stats.def}\n`; if(it.stats.mag) statsText += `魔力: +${it.stats.mag}\n`; if(it.stats.str) statsText += `力量: +${it.stats.str}\n`; if(it.stats.vit) statsText += `體質: +${it.stats.vit}\n`; if(it.effects && it.effects.length > 0) { statsText += `\n[特效]:\n`; it.effects.forEach(ef => { statsText += `- ${ef.type} (${Math.floor(ef.chance*100)}%)\n`; }); } } document.getElementById('tip-body').innerText=statsText; }
function showSpellTip(idOrKey, e, isKey=false) {
    let key = isKey ? idOrKey : game.player.hotbar[idOrKey];
    if(!key) return;
    let s = SPELLS[key];
    let lvl = game.player.spells[key] || 1;
    let t=document.getElementById('tooltip'); t.style.display='block'; let left = e.clientX + 15; if (left + 240 > window.innerWidth) left = e.clientX - 250; t.style.left=left+'px'; t.style.top=(e.clientY+15)+'px';
    document.getElementById('tip-title').innerText=s.name + ` (Lv.${lvl})`; document.getElementById('tip-title').style.color='#0af';
    
    let minDmg = Math.floor(s.dmgBase + s.dmgLvl * lvl);
    let maxDmg = Math.floor(minDmg * 1.5);
    let cost = s.cost + lvl * 2;
    
    let txt = `類型: ${s.cat === 'ATK' ? '攻擊' : (s.cat === 'REC' ? '回復' : (s.cat === 'EFF' ? '效果' : '輔助'))}\n`;
    txt += `消耗: ${cost} MP\n`;
    if(s.cat === 'ATK') txt += `傷害: ${minDmg} ~ ${maxDmg}\n`;
    txt += `冷卻: ${s.cd}秒\n\n`;
    txt += s.desc;
    
    document.getElementById('tip-body').innerText=txt;
}
function hideTip(){ document.getElementById('tooltip').style.display='none'; }
function useQuickSlot(k){ } // Deprecated, use useHotbar
function toggleSpellMenu(){ toggleSpellBook(); } // Redirect
function castSpell(){ 
    let p=game.player; if(!p.activeSpell)return; let s=SPELLS[p.activeSpell]; 
    let lvl = p.spells[p.activeSpell]; let cost = s.cost + lvl*2; 
    if(p.mp>=cost){ 
        p.mp-=cost; AudioSys.sfx('magic'); p.atkCd=s.cd; let a=Math.atan2(mouse.wy-p.y,mouse.wx-p.x); 
        let powerMin = s.dmgBase + s.dmgLvl * lvl;
        let powerMax = powerMin * 1.5;
        let dmg = randInt(powerMin, powerMax); // Range damage, no crit
        
        if (s.cat === 'ATK') {
            if(s.type === 'projectile') {
                game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*380,vy:Math.sin(a)*380,life:1.8,dmg:dmg, isIce: s.effect==='slow', effect:s.effect, isFireball: s.icon==='🔥', icon: s.icon});
            } else if (s.type === 'multishot') {
                for(let i=-1; i<=1; i++) { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a+i*0.3)*300,vy:Math.sin(a+i*0.3)*300,life:1.0,dmg:dmg}); }
            } else if (s.type === 'aoe') {
                game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:99, delay: 1.0, dmg:dmg*2});
            } else if (s.type === 'aoe_instant') { // Lightning Strike
                game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:0.5, dmg:dmg, isStatic:true, icon:'⚡'});
            }
        }
        else if (s.cat === 'REC') {
            if(s.name === '治癒術') { p.hp = Math.min(p.maxHp, p.hp + dmg); spawnText(p.x, p.y, `+${Math.floor(dmg)}`, "#0f0"); }
            if(s.name === '再生術') { p.buffs.push({type:'regen', time:15, icon:'🌿'}); spawnText(p.x, p.y, "再生", "#0f0"); }
            if(s.name === '淨化') { p.poisonTimer=0; p.slowTimer=0; p.confusedTimer=0; spawnText(p.x, p.y, "淨化", "#fff"); }
            if(s.name === '神聖之光') { p.hp = p.maxHp; spawnText(p.x, p.y, "全癒", "#ffd700"); }
            if(s.name === '魔力轉換') { let costHP = p.maxHp*0.2; if(p.hp > costHP) { p.hp -= costHP; p.mp = Math.min(p.maxMp, p.mp + p.maxMp*0.5); spawnText(p.x, p.y, "轉換", "#00f"); } }
        }
        else if (s.cat === 'EFF') {
            if(s.type === 'summon') {
                if(s.sumType === 'HYDRA') {
                    game.entities.push({x:mouse.wx, y:mouse.wy, type:'TURRET', hp:200+lvl*50, life:20, icon:'🐲', name:s.name, dead:false, lvl: lvl}); 
                    spawnText(mouse.wx, mouse.wy, "砲塔召喚!", "#fa0");
                } else {
                    let icon = s.sumType==='GOLEM'?'🗿':'💀';
                    let hp = s.sumType==='GOLEM'?200:50;
                    game.entities.push({x:p.x+20, y:p.y, type:'MINION', hp:hp+lvl*20, life:40, icon:icon, name:s.name, dead:false, lvl: lvl}); 
                    spawnText(p.x, p.y, "召喚!", "#aaa"); 
                }
            }
            else if(s.type === 'ground') {
                game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:8.0, dmg:dmg*0.5, isStatic:true});
            }
            else if(s.type === 'debuff') {
                game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*300,vy:Math.sin(a)*300,life:1.8,dmg:0, effect:s.effect});
            }
        }
        else if (s.type === 'buff') {
            let dur = 20 + lvl*5;
            p.buffs.push({type:s.buff, time:dur, icon:s.icon});
            p.recalc();
            spawnText(p.x, p.y, "強化!", "#ff0");
        }
        
    } else { spawnText(p.x, p.y, "魔力不足!", "#00f"); } 
}

function useTownPortal(isDungeon) {
    if(!isDungeon) {
        if(game.floor === 0) { spawnText(game.player.x, game.player.y, "已在城鎮中", "#fff"); return; }
        AudioSys.sfx('portal');
        game.dungeonCache = { floor: game.floor, x: game.player.x, y: game.player.y };
        game.savedPlayerPos = { x: 50*40+20, y: 50*40+20 };
        game.floor = 0;
        genFloor(0);
        spawnText(game.player.x, game.player.y, "回城卷軸!", "#0af");
    } else {
        if(!game.dungeonCache) { spawnText(game.player.x, game.player.y, "傳送門已失效", "#aaa"); return; }
        AudioSys.sfx('portal');
        game.floor = game.dungeonCache.floor;
        game.savedPlayerPos = { x: game.dungeonCache.x, y: game.dungeonCache.y };
        genFloor(game.floor);
    }
    game.cam.x = game.player.x; game.cam.y = game.player.y;
    game.player.path = [];
}

function interactNPC(npc) {
    if (npc.type === 'NPC_GENERAL') {
        openShop(npc);
    } else if (npc.type === 'NPC_ELDER') {
        spawnText(npc.x, npc.y - 30, "長老: 歡迎回來，英雄。", "#ffd700");
    } else if (npc.type === 'NPC_ADVENTURER') {
        spawnText(npc.x, npc.y - 30, "冒險者: 前方非常危險...", "#fff");
    }
}

function handlePlayerDeath() {
    game.dead = true;
    document.getElementById('death-screen').style.display = 'flex';
    AudioSys.sfx('die');
}

function resurrect(type) {
    let p = game.player;
    if (type === 'town') {
        p.inv = [];
        p.equip = { helm:null, necklace:null, earring1:null, earring2:null, armor:null, mainhand:null, offhand:null, ring1:null, ring2:null, pants:null, boots:null, gloves:null };
        p.hp = p.maxHp;
        p.mp = p.maxMp;
        p.recalc();
        game.dungeonCache = null; 
        game.savedPlayerPos = null; 
        game.floor = 0;
        genFloor(0); 
        game.cam.x = p.x; game.cam.y = p.y; 
    } 
    game.dead = false;
    document.getElementById('death-screen').style.display = 'none';
    game.uiDirty = true;
}
function showMainMenu(){ document.getElementById('char-create').style.display='none'; document.getElementById('main-menu').style.display='block'; document.getElementById('start-screen').style.display='flex'; document.getElementById('death-screen').style.display='none'; game.dead=false; game.running=false; }
function showCharCreate(){ document.getElementById('main-menu').style.display='none'; document.getElementById('char-create').style.display='flex'; }
function openGuide() { document.getElementById('guide-modal').style.display='block'; }
function closeGuide() { document.getElementById('guide-modal').style.display='none'; }
function saveGame(){ if(!game.player) return; const saveObj = { stats: game.player.stats, baseStats: game.player.baseStats, lvl: game.player.lvl, xp: game.player.xp, raceKey: game.player.raceKey, gender: game.player.gender, gold: game.player.gold, floor: game.floor, inv: game.player.inv, equip: game.player.equip, spells: game.player.spells, hotbar: game.player.hotbar }; localStorage.setItem('inf_save_v9', JSON.stringify(saveObj)); alert('遊戲已存檔'); }
function tryLoadGame(){ let d=JSON.parse(localStorage.getItem('inf_save_v9')); if(!d) return alert('無存檔紀錄'); selRace=d.raceKey; selGender=d.gender||'MALE'; startGame(); game.player.lvl = d.lvl; game.player.xp = d.xp; game.player.gold = d.gold; game.player.baseStats = d.baseStats; game.player.inv = d.inv || []; game.player.equip = d.equip || {}; game.player.spells = d.spells || {}; game.player.hotbar = d.hotbar || new Array(8).fill(null); const sKeys = Object.keys(game.player.spells); game.player.activeSpell = sKeys.length > 0 ? sKeys[0] : null; game.floor = d.floor; genFloor(d.floor); game.player.recalc(); game.uiDirty = true; }
function selectRace(k,b){ selRace=k; document.querySelectorAll('.race-btn').forEach(btn=>btn.classList.remove('selected')); if(b) b.classList.add('selected'); let r=RACES[k]; document.getElementById('preview-race').innerText=r.name; document.getElementById('preview-desc').innerText=r.desc; ['str','dex','mag','vit'].forEach(s=>document.getElementById('bar-'+s).style.width=(r.stats[s]*10)+'%'); updatePreviewIcon(); }
function selectGender(g){ selGender=g; document.getElementById('btn-male').className = g==='MALE'?'gender-btn selected':'gender-btn'; document.getElementById('btn-female').className = g==='FEMALE'?'gender-btn selected':'gender-btn'; updatePreviewIcon(); }
function updatePreviewIcon(){ let r=RACES[selRace]; document.getElementById('preview-icon').innerText = selGender==='MALE' ? r.iconM : r.iconF; }
function spawnText(x,y,t,c){ let e=document.createElement('div'); e.className='floating-text'; e.innerText=t; e.style.color=c; e.style.left=(x-game.cam.x+gameCanvas.width/2)+'px'; e.style.top=(y-game.cam.y+gameCanvas.height/2)+'px'; document.getElementById('floating-text-container').appendChild(e); setTimeout(()=>e.remove(),1000); }
function startGame() { AudioSys.init(); document.getElementById('btn-music').innerText = "🔊 音樂"; game.player=new PlayerClass(selRace, selGender); game.floor = 0; genFloor(0); game.cam.x=game.player.x; game.cam.y=game.player.y; game.running=true; game.uiDirty = true; document.getElementById('start-screen').style.display='none'; }
function init() { 
    gameCanvas = document.getElementById('gameCanvas'); gameCtx = gameCanvas.getContext('2d'); minimapCanvas = document.getElementById('minimap'); minimapCtx = minimapCanvas.getContext('2d'); const rl = document.getElementById('race-list'); rl.innerHTML = ''; Object.keys(RACES).forEach(k=>{ const b = document.createElement('button'); b.className = 'race-btn'; b.innerText = RACES[k].name; b.onclick = () => selectRace(k, b); rl.appendChild(b); }); selectRace('HUMAN', rl.firstChild); window.addEventListener('resize', ()=>{ gameCanvas.width=window.innerWidth; gameCanvas.height=window.innerHeight-140; }); window.dispatchEvent(new Event('resize')); gameCanvas.addEventListener('mousemove', e => { mouse.wx = e.clientX - gameCanvas.width/2 + game.cam.x; mouse.wy = e.clientY - gameCanvas.height/2 + game.cam.y; }); 
    window.addEventListener('keydown', e => { 
        if(!game.running) return; 
        if(e.key >= '1' && e.key <= '8') useHotbar(parseInt(e.key)-1);
        if(e.key === 'i' || e.key === 'I') toggleInventory(); 
        if(e.key === 'k' || e.key === 'K') toggleSpellBook(); 
    });
    
    document.getElementById('minimap-container').addEventListener('mousedown', e => {
        if(!game.running) return;
        const rect = e.target.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const cw = 150/60; const dx = (mx - 75) / cw; const dy = (my - 75) / cw; 
        game.player.targetEntity = null; game.player.path = findPath(game.player.x, game.player.y, game.player.x + dx * 40, game.player.y + dy * 40);
    });

    gameCanvas.addEventListener('mousedown', e=>{ 
        if(!game.running) return; 
        const wx=e.clientX-gameCanvas.width/2+game.cam.x; 
        const wy=e.clientY-gameCanvas.height/2+game.cam.y; 
        mouse.wx = wx; mouse.wy = wy; 
        
        if(e.button===0){ 
            let tx = Math.floor(wx / 40); let ty = Math.floor(wy / 40);
            if (game.map[ty] && (game.map[ty][tx] === 2 || game.map[ty][tx] === 6)) {
                 if (Math.hypot(game.player.x - (tx * 40 + 20), game.player.y - (ty * 40 + 20)) < 60) {
                     if (game.map[ty][tx] === 2) { game.floor++; genFloor(game.floor); game.cam.x=game.player.x; game.cam.y=game.player.y; game.player.path=[]; return; }
                     if (game.map[ty][tx] === 6 && game.floor > 0) { game.floor--; genFloor(game.floor); game.cam.x=game.player.x; game.cam.y=game.player.y; game.player.path=[]; return; }
                 }
            }
            let t = getTargetAt(wx,wy); let p = game.player; let closeEnemy = (t && t.isEnemy) ? t : null;
            if(closeEnemy) {
                let angleToClick = Math.atan2(wy - p.y, wx - p.x); let currentFacing = p.facing; let diff = Math.abs(angleToClick - currentFacing); if (diff > Math.PI) diff = 2 * Math.PI - diff;
                let dist = Math.hypot(closeEnemy.x - p.x, closeEnemy.y - p.y); let range = (p.equip.mainhand ? ITEM_TYPES[p.equip.mainhand.type].range : 35);
                if (diff < (60 * Math.PI) / 180) { if (dist <= range) { attack(closeEnemy); p.path = []; } else { game.player.targetEntity = closeEnemy; game.player.attackRequested = true; game.player.path = []; } } else { game.player.targetEntity = null; game.player.attackRequested = false; game.player.path = findPath(game.player.x, game.player.y, wx, wy); spawnText(p.x, p.y - 30, "移動", "#aaa"); }
            } else { if(t && !t.isEnemy) { game.player.targetEntity = t; game.player.path = []; } else { game.player.targetEntity=null; game.player.path=findPath(game.player.x,game.player.y,wx,wy); } }
        } 
        if(e.button===2) { e.preventDefault(); castSpell(); } 
    }); 
    
    gameCanvas.addEventListener('contextmenu', event => event.preventDefault()); const joy=document.getElementById('joystick-container'); joy.addEventListener('touchstart',e=>{ joystick.active=true; let t=e.touches[0]; joystick.startX=t.clientX; joystick.startY=t.clientY; }); window.addEventListener('touchmove',e=>{ if(!joystick.active)return; let t=e.touches[0]; let dx=t.clientX-joystick.startX,dy=t.clientY-joystick.startY; let d=Math.min(50,Math.sqrt(dx*dx+dy*dy)); let a=Math.atan2(dy,dx); joystick.vector={x:Math.cos(a)*(d/50),y:Math.sin(a)*(d/50)}; document.getElementById('joystick-knob').style.left=(50+Math.cos(a)*50*(d/50))+'%'; document.getElementById('joystick-knob').style.top=(50+Math.sin(a)*50*(d/50))+'%'; }); window.addEventListener('touchend',()=>{ joystick.active=false; joystick.vector={x:0,y:0}; document.getElementById('joystick-knob').style.left='50%'; document.getElementById('joystick-knob').style.top='50%'; if(game.player) { game.player.path = []; game.player.targetEntity = null; } }); if('ontouchstart' in window) joy.style.display='block'; setInterval(update, 16); requestAnimationFrame(function tick(){ if(typeof draw === 'function') draw(); requestAnimationFrame(tick); }); 
}
</script>
</body>
</html>