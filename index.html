<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>無限的地牢 - Infinite Dungeon (單機版)</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: #000; color: #dcdcdc;
            font-family: 'Noto Serif TC', serif; user-select: none; -webkit-user-select: none;
            display: flex; flex-direction: column; height: 100vh;
        }

        #game-viewport { position: relative; flex-grow: 1; overflow: hidden; cursor: crosshair; background: #050505; }
        
        #ui-panel {
            height: 140px; background: #111; border-top: 4px solid #333;
            display: flex; justify-content: center; align-items: center;
            padding: 5px 20px; box-sizing: border-box; z-index: 20;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.9);
            position: relative;
        }

        canvas { display: block; }

        .globe-wrapper { position: relative; width: 90px; height: 90px; margin: 0 15px; }
        .globe-container {
            width: 100%; height: 100%; background: #000; border-radius: 50%; border: 3px solid #555;
            box-shadow: inset 0 0 20px #000; overflow: hidden; position: relative;
        }
        .globe-liquid { position: absolute; bottom: 0; left: 0; width: 100%; transition: height 0.3s ease-out; }
        .globe-glass {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3) 0%, transparent 20%, rgba(0,0,0,0.4) 80%);
            border-radius: 50%; pointer-events: none;
        }
        #hp-globe .globe-liquid { background: linear-gradient(to top, #700, #f00); box-shadow: 0 0 15px #f00 inset; }
        #mp-globe .globe-liquid { background: linear-gradient(to top, #007, #0af); box-shadow: 0 0 15px #00f inset; }
        .globe-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-weight: bold; font-size: 16px; text-shadow: 1px 1px 2px #000; color: #fff; z-index: 5;
        }

        #center-controls { flex-grow: 1; max-width: 500px; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px; }
        #xp-bar-container { width: 100%; height: 6px; background: #222; border: 1px solid #555; border-radius: 4px; overflow: hidden; }
        #xp-bar-fill { height: 100%; background: #a3f; width: 0%; transition: width 0.2s; }

        .hotbar { display: flex; gap: 15px; margin: 5px 0; align-items: center; }
        .hotkey-slot {
            width: 48px; height: 48px; background: #1a1a1a; border: 2px solid #444; border-radius: 4px;
            position: relative; cursor: pointer; display: flex; justify-content: center; align-items: center;
            font-size: 24px; transition: 0.1s;
        }
        .hotkey-slot:hover { border-color: #d4af37; background: #222; }
        .key-label { position: absolute; top: -6px; left: -6px; background: #333; color: #fff; font-size: 10px; padding: 1px 4px; border-radius: 4px; border: 1px solid #555; }
        .qty-label { position: absolute; bottom: 1px; right: 2px; color: #fff; font-size: 11px; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        .system-btns { position: absolute; right: 20px; bottom: 20px; display: flex; flex-direction: column; gap: 10px; }

        .game-window {
            position: absolute; background: rgba(15, 15, 20, 0.98); border: 2px solid #555;
            box-shadow: 0 0 50px #000; display: none; flex-direction: column; pointer-events: auto; z-index: 100;
            max-height: 85vh; border-radius: 4px;
        }
        
        #inventory-window { width: 600px; height: 500px; top: 10%; right: 10%; left: auto; transform: none; display: none; }
        .inv-container { display: flex; flex-direction: row; flex-grow: 1; min-height: 0; overflow: hidden; }
        
        .stats-sidebar { 
            width: 140px; background: rgba(0,0,0,0.3); border-right: 1px solid #444; padding: 15px; 
            font-size: 13px; color: #aaa; flex-shrink: 0; overflow-y: auto;
        }
        
        .paper-doll-container { 
            width: 200px; position: relative; background: radial-gradient(circle at center, #222 0%, #080808 80%); 
            border-right: 1px solid #444; flex-shrink: 0;
        }
        
        .inv-grid-container { 
            flex-grow: 1; padding: 10px; overflow-y: auto; background: #0b0b0b; 
            display: flex; flex-direction: column;
        }
        .inventory-grid { 
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; 
            align-content: start; grid-auto-rows: min-content;
        }
        
        .doll-slot {
            width: 40px; height: 40px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 4px;
            position: absolute; display: flex; justify-content: center; align-items: center; font-size: 20px; color: #333; cursor: pointer;
        }
        .doll-slot.equipped { border-color: #d4af37; box-shadow: 0 0 10px rgba(212, 175, 55, 0.3); color: #fff; }
        .doll-label { position: absolute; font-size: 8px; color: #666; bottom: 0; width: 100%; text-align: center; pointer-events: none; }

        /* 裝備槽座標 */
        #slot-helm { top: 20px; left: 80px; }
        #slot-necklace { top: 70px; left: 130px; width: 30px; height: 30px; }
        #slot-armor { top: 70px; left: 80px; height: 60px; }
        #slot-mainhand { top: 80px; left: 20px; height: 80px; width: 40px; }
        #slot-offhand { top: 80px; left: 140px; height: 80px; width: 40px; }
        #slot-earring1 { top: 30px; left: 30px; width: 28px; height: 28px; }
        #slot-earring2 { top: 30px; left: 142px; width: 28px; height: 28px; }
        #slot-ring1 { top: 180px; left: 30px; width: 28px; height: 28px; }
        #slot-ring2 { top: 180px; left: 142px; width: 28px; height: 28px; }
        #slot-pants { top: 140px; left: 80px; height: 50px; }
        #slot-boots { top: 200px; left: 80px; height: 40px; }

        .inv-slot { width: 100%; aspect-ratio: 1; background: #151515; border: 1px solid #333; border-radius: 3px; display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer; }

        #shop-window { width: 350px; height: 500px; top: 10%; left: 5%; right: auto; transform: none; }
        .shop-items { flex-grow: 1; overflow-y: auto; padding: 10px; min-height: 0; }
        .shop-item { background: #1a1a1a; border: 1px solid #333; padding: 10px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; cursor: grab; border-radius: 4px; }
        .shop-item:hover { border-color: #d4af37; background: #252525; }
        .shop-item:active { cursor: grabbing; }

        .window-header { background: #222; color: #d4af37; padding: 8px 12px; font-weight: bold; display: flex; justify-content: space-between; border-bottom: 2px solid #444; font-size: 16px; flex-shrink: 0; }
        .close-btn { cursor: pointer; color: #f55; font-size: 20px; }

        #spell-btn {
            width: 60px; height: 60px; background: #111; border: 2px solid #00aaff; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; font-size: 30px; cursor: pointer;
            box-shadow: 0 0 15px #00aaff; position: relative; margin-left: 20px;
        }
        #spell-menu {
            position: absolute; bottom: 75px; right: 0; background: rgba(10,10,10,0.95); border: 1px solid #444;
            display: none; grid-template-columns: repeat(3, 1fr); gap: 5px; padding: 10px; border-radius: 8px; z-index: 100;
        }
        .spell-option { width: 45px; height: 45px; border: 1px solid #333; display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; background: #000; border-radius: 4px; color: #fff; }
        .spell-option:hover { border-color: #0af; background: #111; }
        #active-spell-icon { font-size: 28px; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; display: none; z-index: 50; touch-action: none;
        }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.2); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }

        #minimap-container {
            position: absolute; top: 10px; right: 10px; width: 150px; height: 150px;
            background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 4px; overflow: hidden; cursor: pointer; z-index: 50;
        }
        #minimap { display: block; width: 100%; height: 100%; }
        
        #dialogue-box {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 600px; background: rgba(0,0,0,0.9); border: 2px solid #d4af37;
            padding: 20px; color: #fff; font-size: 18px; display: none; z-index: 200;
            border-radius: 8px; box-shadow: 0 0 20px #000;
        }
        #dialogue-name { color: #d4af37; font-weight: bold; margin-bottom: 10px; font-size: 20px; }
        #dialogue-text { line-height: 1.5; min-height: 60px; }
        #dialogue-close { position: absolute; top: 10px; right: 15px; cursor: pointer; color: #888; }
        #dialogue-options { margin-top: 15px; display: flex; gap: 10px; }

        #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8); z-index: 9999;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #death-title { font-size: 80px; color: #f00; text-shadow: 0 0 20px #000; margin-bottom: 50px; font-family: 'serif'; }
        .death-btn {
            background: #111; border: 2px solid #555; color: #ddd;
            font-size: 24px; padding: 15px 40px; margin: 10px; cursor: pointer;
            transition: 0.2s; width: 300px;
        }
        .death-btn:hover { border-color: #f00; color: #fff; background: #300; }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        .char-create-panel { background: #111; border: 2px solid #444; padding: 30px; width: 800px; display: flex; gap: 30px; border-radius: 8px; box-shadow: 0 0 100px rgba(0,0,0,0.8); max-height: 90vh; }
        .race-btn { padding: 12px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; width: 100%; margin-bottom: 8px; text-align: left; font-size: 18px; border-radius: 4px; transition: 0.2s; }
        .race-btn.selected { background: #500; color: #fff; border-color: #f00; box-shadow: 0 0 15px rgba(255,0,0,0.3); }
        .stat-bar { background: #222; height: 8px; width: 100%; margin: 6px 0; border-radius: 2px; }
        .stat-fill { height: 100%; background: #d4af37; transition: width 0.3s; }
        .btn-back { position: absolute; top: 20px; left: 20px; background: #333; border: 1px solid #555; color: #aaa; padding: 10px 20px; cursor: pointer; font-size: 16px; border-radius: 4px; }
        .action-btn { background: #222; border: 1px solid #444; color: #dcdcdc; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-family: 'Noto Serif TC', serif; font-size: 14px; width: 100px; text-align: center; }
        .action-btn:hover { background: #333; border-color: #666; }

        .item-tooltip { position: absolute; background: rgba(10, 10, 15, 0.98); border: 1px solid #666; padding: 12px; pointer-events: none; display: none; z-index: 9999; width: 240px; box-shadow: 0 5px 20px #000; }
        .floating-text { position: absolute; font-weight: bold; pointer-events: none; animation: floatUp 1s forwards ease-out; text-shadow: 2px 2px 0 #000; font-family: sans-serif; font-size: 22px; z-index: 50; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-70px) scale(1.2); opacity: 0; } }
        #cast-bar { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 12px; background: rgba(0,0,0,0.8); border: 1px solid #aaa; display: none; border-radius: 6px; overflow: hidden; }
        #cast-fill { height: 100%; background: #0af; width: 0%; }
        
        /* 怪物資訊 HUD - 放在畫面上方，不擋視線 */
        #monster-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-weight: bold; text-shadow: 2px 2px 4px #000;
            font-size: 20px; pointer-events: none; display: none; z-index: 150;
            background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 10px;
        }
        
        #multiplayer-status { display: none !important; }
    </style>
</head>
<body onload="init()">

<div id="game-viewport">
    <canvas id="gameCanvas" ondragover="event.preventDefault();" ondrop="handleDropToWorld(event)"></canvas>
    <div id="floating-text-container" style="position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden;"></div>
    <div id="joystick-container"><div id="joystick-knob"></div></div>
    <div id="cast-bar"><div id="cast-fill"></div></div>
    <div id="minimap-container"><canvas id="minimap" width="150" height="150"></canvas></div>
    <!-- 怪物資訊顯示區域 -->
    <div id="monster-hud"></div>
    
    <div id="dialogue-box">
        <div id="dialogue-close" onclick="closeDialogue()">✕</div>
        <div id="dialogue-name">NPC Name</div>
        <div id="dialogue-text">Dialogue text goes here...</div>
        <div id="dialogue-options"></div>
    </div>

    <div id="inventory-window" class="game-window">
        <div class="window-header"><span>英雄裝備</span><span class="close-btn" onclick="toggleInventory()">✕</span></div>
        <div class="inv-container">
            <div class="stats-sidebar">
                <div style="margin-bottom:10px; color:#d4af37; font-weight:bold;">屬性點: <span id="stat-points">0</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">力量 <span id="stat-str">0</span> <span id="plus-str" style="color:red; cursor:pointer; display:none;" onclick="addStat('str')">[+]</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">敏捷 <span id="stat-dex">0</span> <span id="plus-dex" style="color:red; cursor:pointer; display:none;" onclick="addStat('dex')">[+]</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">魔力 <span id="stat-mag">0</span> <span id="plus-mag" style="color:red; cursor:pointer; display:none;" onclick="addStat('mag')">[+]</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">體質 <span id="stat-vit">0</span> <span id="plus-vit" style="color:red; cursor:pointer; display:none;" onclick="addStat('vit')">[+]</span></div>
                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                <div>攻擊力 <span id="stat-atk">0</span></div>
                <div>防禦力 <span id="stat-def">0</span></div>
                <div style="margin-top:5px; color:#888; font-size:11px;">爆擊率: <span id="stat-crit">0</span>%</div>
                <div style="color:#888; font-size:11px;">必殺率: <span id="stat-kill">0</span>%</div>
                <div style="margin-top:5px; color:#0f0;">HP回: <span id="stat-hpregen">0</span>/s</div>
                <div style="color:#0af;">MP回: <span id="stat-mpregen">0</span>/s</div>
                <div style="margin-top:10px; font-weight:bold; color:#ffd700;">💰 <span id="ui-gold-inv">0</span></div>
                <div style="margin-top:5px; font-size:12px; color:#888;">物品: <span id="inv-count">0</span>/40</div>
            </div>
            
            <div class="paper-doll-container">
                <div class="doll-slot" id="slot-helm" ondblclick="unequip('helm')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'helm')"><span class="doll-label">頭部</span></div>
                <div class="doll-slot" id="slot-necklace" ondblclick="unequip('necklace')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'necklace')"><span class="doll-label">項鍊</span></div>
                <div class="doll-slot" id="slot-earring1" ondblclick="unequip('earring1')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'earring1')"><span class="doll-label">耳</span></div>
                <div class="doll-slot" id="slot-earring2" ondblclick="unequip('earring2')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'earring2')"><span class="doll-label">耳</span></div>
                <div class="doll-slot" id="slot-armor" ondblclick="unequip('armor')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'armor')"><span class="doll-label">身體</span></div>
                <div class="doll-slot" id="slot-mainhand" ondblclick="unequip('mainhand')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'mainhand')"><span class="doll-label">右手</span></div>
                <div class="doll-slot" id="slot-offhand" ondblclick="unequip('offhand')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'offhand')"><span class="doll-label">左手</span></div>
                <div class="doll-slot" id="slot-ring1" ondblclick="unequip('ring1')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'ring1')"><span class="doll-label">戒</span></div>
                <div class="doll-slot" id="slot-ring2" ondblclick="unequip('ring2')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'ring2')"><span class="doll-label">戒</span></div>
                <div class="doll-slot" id="slot-pants" ondblclick="unequip('pants')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'pants')"><span class="doll-label">腿部</span></div>
                <div class="doll-slot" id="slot-boots" ondblclick="unequip('boots')" ondragover="event.preventDefault();" ondrop="handleDropToEquip(event, 'boots')"><span class="doll-label">腳部</span></div>
            </div>

            <div class="inv-grid-container">
                <div class="inventory-grid" id="inventory-grid" ondragover="event.preventDefault();" ondrop="handleDropToInventory(event)"></div>
            </div>
        </div>
    </div>

    <div id="shop-window" class="game-window" ondragover="event.preventDefault();" ondrop="handleDropToShop(event)">
        <div class="window-header"><span id="shop-title">商店 (雙擊購買/拖曳出售)</span><span class="close-btn" onclick="closeShop()">✕</span></div>
        <div class="shop-items" id="shop-items"></div>
    </div>
</div>

<div id="ui-panel">
    <div class="globe-wrapper">
        <div class="globe-container" id="hp-globe"><div class="globe-liquid" id="hp-fill"></div><div class="globe-glass"></div></div>
        <div class="globe-text" id="hp-text">100</div>
    </div>
    <div id="center-controls">
        <div style="width:100%; display:flex; justify-content:space-between; align-items:baseline;">
            <div id="level-info" style="font-size:18px; color:#d4af37; font-weight:bold;">營地</div>
            <div style="font-size:14px; color:#aaa;">Lv <span id="ui-level">1</span></div>
        </div>
        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
        <div class="hotbar">
            <div class="hotkey-slot" onclick="useQuickSlot('HP')" ondragover="event.preventDefault()" ondrop="handleDropToHotbar(event, 'HP')"><div class="key-label">1</div>💊<div class="qty-label" id="qty-HP">0</div></div>
            <div class="hotkey-slot" onclick="useQuickSlot('MP')" ondragover="event.preventDefault()" ondrop="handleDropToHotbar(event, 'MP')"><div class="key-label">2</div>🧪<div class="qty-label" id="qty-MP">0</div></div>
            <div class="hotkey-slot" onclick="useQuickSlot('TP')" ondragover="event.preventDefault()" ondrop="handleDropToHotbar(event, 'TP')"><div class="key-label">3</div>📜<div class="qty-label" id="qty-TP">0</div></div>
        </div>
    </div>
    
    <div class="system-btns">
        <button class="action-btn" onclick="toggleInventory()">背包 (I)</button>
        <button class="action-btn" onclick="saveGame()">存檔</button>
        <button class="action-btn" onclick="toggleMusic()" id="btn-music">🔇 音樂</button>
    </div>

    <div id="spell-btn" onclick="toggleSpellMenu()"><span id="active-spell-icon">🚫</span><div id="spell-menu"></div></div>
    <div class="globe-wrapper">
        <div class="globe-container" id="mp-globe"><div class="globe-liquid" id="mp-fill"></div><div class="globe-glass"></div></div>
        <div class="globe-text" id="mp-text">50</div>
    </div>
</div>

<div class="item-tooltip" id="tooltip">
    <div id="tip-title" style="font-weight:bold; font-size:18px;"></div>
    <div id="tip-body" style="font-size:13px; margin-top:8px;"></div>
</div>

<div id="start-screen">
    <h1 style="font-size: 80px; color: #8b0000; text-shadow: 0 0 30px red; margin-bottom: 40px; font-family:'serif';">無限的地牢</h1>
    <div class="char-create-panel" id="char-create" style="display:none;">
        <button class="btn-back" onclick="showMainMenu()">⬅ 返回主選單</button>
        <div style="width:250px; display:flex; flex-direction:column;" id="race-list"></div>
        <div style="flex-grow:1; padding-left:45px; border-left:1px solid #333;">
            <h2 id="preview-race" style="color:#d4af37; font-size:36px; margin-top:0;">人類</h2>
            <p id="preview-desc" style="color:#888; height:70px; font-size:16px;">描述...</p>
            <div style="width:100%;">
                <div>力量</div><div class="stat-bar"><div id="bar-str" class="stat-fill"></div></div>
                <div>敏捷</div><div class="stat-bar"><div id="bar-dex" class="stat-fill"></div></div>
                <div>魔力</div><div class="stat-bar"><div id="bar-mag" class="stat-fill"></div></div>
                <div>體質</div><div class="stat-bar"><div id="bar-vit" class="stat-fill"></div></div>
            </div>
            <button class="action-btn" style="margin-top:40px; font-size:24px; border-color:#d00; width:100%; padding:20px; font-weight:bold;" onclick="startGame()">踏入黑暗</button>
        </div>
    </div>
    <div id="main-menu">
        <button class="action-btn" style="font-size:28px; padding:25px 80px; margin-bottom:20px; display:block; width:350px;" onclick="showCharCreate()">新遊戲</button>
        <button class="action-btn" id="btn-load" style="font-size:28px; padding:25px 80px; display:block; width:350px;" onclick="tryLoadGame()">讀取進度</button>
    </div>
</div>

<div id="death-screen">
    <div id="death-title">你死掉了</div>
    <button class="death-btn" onclick="resurrect('town')">靈魂轉生 (掉落裝備保留等級)</button>
    <button class="death-btn" onclick="showMainMenu()">重新開始</button>
</div>

<script>
const game = {
    running: false, map: [], visited: [], visibleTiles: [], entities: [], items: [], projs: [], shopItems: [],
    cam: {x:0, y:0}, player: null, floor: 0, uiDirty: false, transitionCooldown: 0, bossActive: false,
    dungeonCache: null, dead: false, currentNPC: null, savedPlayerPos: null,
    theme: { floor: '#181818', wall: '#1d1d1d' }, shopOpen: false
};
const joystick = { active: false, startX: 0, startY: 0, vector: {x:0,y:0} };
const mouse = { wx: 0, wy: 0 };
let gameCanvas, gameCtx, minimapCanvas, minimapCtx, selRace = 'HUMAN';

const RACES = {
    HUMAN: { name: '人類', desc: '能力平均。', stats: { str: 5, dex: 5, mag: 5, vit: 5 }, startSpells: { 'FIREBALL': 1 }, critBonus:0, killBonus:0 },
    ELF:   { name: '精靈', desc: '身手敏捷，精通魔法。', stats: { str: 3, dex: 8, mag: 7, vit: 3 }, startSpells: { 'FIREBALL': 1 }, critBonus:5, killBonus:0 },
    DWARF: { name: '矮人', desc: '體質強健，擅長暴擊。', stats: { str: 7, dex: 3, mag: 2, vit: 9 }, startSpells: {}, critBonus:10, killBonus:2 },
    ORC:   { name: '獸人', desc: '力量強大，容易一擊必殺。', stats: { str: 9, dex: 4, mag: 1, vit: 7 }, startSpells: {}, critBonus:5, killBonus:5 },
    UNDEAD:{ name: '亡靈', desc: '魔力強大，免疫毒素。', stats: { str: 2, dex: 4, mag: 10, vit: 5 }, startSpells: { 'FIREBALL': 1, 'CHARGED_BOLT': 1 }, critBonus:0, killBonus:1 }
};

const ITEM_TYPES = {
    SWORD_1H:{icon:'🗡️',name:'單手劍',slot:'mainhand',hands:1,range:55, speed:0.4, scale:1.0}, 
    SWORD_2H:{icon:'🗡️',name:'雙手巨劍',slot:'mainhand',hands:2,range:75, speed:0.7, scale:1.4}, 
    AXE_1H:{icon:'🪓',name:'單手斧',slot:'mainhand',hands:1,range:55, speed:0.5, scale:1.0}, 
    AXE_2H:{icon:'🪓',name:'雙手戰斧',slot:'mainhand',hands:2,range:75, speed:0.8, scale:1.6}, 
    BOW:{icon:'🏹',name:'短弓',slot:'mainhand',hands:2,range:350, speed:0.6, scale:1.0}, 
    CROSSBOW:{icon:'🏹',name:'十字弓',slot:'mainhand',hands:2,range:320, speed:0.9, scale:1.1},
    STAFF:{icon:'🦯',name:'法杖',slot:'mainhand',hands:2,range:65, speed:0.5, scale:1.1},
    DAGGER:{icon:'🔪',name:'匕首',slot:'offhand',hands:1,range:40, speed:0.25, scale:0.8},
    SHIELD:{icon:'🛡️',name:'盾牌',slot:'offhand',hands:1}, 
    HELM:{icon:'🪖',name:'頭盔',slot:'helm'},
    ARMOR:{icon:'👕',name:'護甲',slot:'armor'}, 
    PANTS:{icon:'👖',name:'護腿',slot:'pants'}, 
    BOOTS:{icon:'👢',name:'長靴',slot:'boots'}, 
    AMULET:{icon:'📿',name:'護符',slot:'necklace'}, 
    EARRING:{icon:'👂',name:'耳環',slot:'earring'}, 
    RING:{icon:'💍',name:'戒指',slot:'ring'},
    GOLD:{icon:'💰',name:'金幣'}, POTION:{icon:'💊',name:'生命藥水'}, MANA_POTION:{icon:'🧪',name:'魔力藥水'}, SCROLL_TP:{icon:'📜',name:'回城卷軸'}, SPELL_BOOK:{icon:'📘',name:'法術書'}
};

const SPELLS = {
    FIREBALL:{name:'火球術',icon:'🔥',cost:15,dmg:25,cd:0.8,type:'projectile'}, CHARGED_BOLT:{name:'電網',icon:'⚡',cost:12,dmg:8,cd:0.6,type:'multishot'},
    ICEBOLT:{name:'冰箭術',icon:'❄️',cost:10,dmg:15,cd:0.5,type:'projectile'}, HEAL:{name:'治癒術',icon:'💚',cost:40,dmg:0,cd:2.0,type:'self'},
    FIREWALL:{name:'火牆',icon:'🌋',cost:35,dmg:5,cd:3.0,type:'ground'}, METEOR:{name:'隕石術',icon:'☄️',cost:60,dmg:80,cd:4.0,type:'aoe'},
    CONFUSE:{name:'迷惑術',icon:'💫',cost:25,dmg:0,cd:5.0,type:'debuff',effect:'confused'},
    CHARM:{name:'魅惑術',icon:'💗',cost:40,dmg:0,cd:10.0,type:'debuff',effect:'charmed'},
    SUMMON:{name:'召喚術',icon:'💀',cost:50,dmg:0,cd:5.0,type:'summon'},
    RESURRECTION:{name:'復活術',icon:'✝️',cost:100,dmg:0,cd:60.0,type:'self'}
};

const MONSTERS = {
    RAT: {name:'巨鼠', icon:'🐀', hp:30, dmg:8, ranged:false}, 
    BAT: {name:'蝙蝠', icon:'🦇', hp:25, dmg:10, ranged:false},
    SKELETON_SOLDIER: {name:'骷髏兵', icon:'💀', hp:50, dmg:15, ranged:false}, 
    SKELETON_SHIELD: {name:'骷髏盾衛', icon:'🛡️💀', hp:90, dmg:10, ranged:false}, 
    SKELETON_ARCHER: {name:'骷髏射手', icon:'💀', subIcon:'🏹', hp:60, dmg:20, ranged:true, projIcon:'🏹', range:200},
    GOBLIN_MAGE: {name:'哥布林法師', icon:'👹', subIcon:'🔥', hp:55, dmg:25, ranged:true, projIcon:'🔥', range:220},
    ORC_WARRIOR: {name:'獸人戰士', icon:'🐗', hp:150, dmg:45, ranged:false},
    EYE: {name:'眼魔', icon:'👁️', subIcon:'⚡', hp:100, dmg:35, ranged:true, projIcon:'⚡', range:180},
    GHOST: {name:'幽靈', icon:'👻', hp:70, dmg:30, speed:110, ranged:false},
    ASSASSIN: {name:'刺客', icon:'🥷', hp:90, dmg:55, speed:140, ranged:false},
    DEMON: {name:'惡魔', icon:'👿', hp:300, dmg:70, ranged:false}
};

const AudioSys = {
    ctx: null, isMuted: false, bgmTimer: null, bgmOsc: [],
    init: function() { 
        if(!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            this.playBGM();
        }
    },
    sfx: function(type) {
        if(!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        if(type === 'hit') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.1); 
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
            osc.start(t); osc.stop(t+0.1);
        }
        else if (type === 'coin') { 
            osc.type = 'sine'; osc.frequency.setValueAtTime(1500, t); osc.frequency.setValueAtTime(2000, t+0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
            osc.start(t); osc.stop(t+0.2);
        }
        else if (type === 'magic') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(600, t+0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.3);
            osc.start(t); osc.stop(t+0.3);
        }
        else if (type === 'level') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.setValueAtTime(600, t+0.2); osc.frequency.setValueAtTime(800, t+0.4);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.6);
            osc.start(t); osc.stop(t+0.6);
        }
        else if (type === 'step') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(50, t); 
            gain.gain.setValueAtTime(0.02, t); gain.gain.exponentialRampToValueAtTime(0.001, t+0.05);
            osc.start(t); osc.stop(t+0.05);
        }
        else if (type === 'die') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.5);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
            osc.start(t); osc.stop(t+0.5);
        }
    },
    playBGM: function() {
        if (!this.ctx || this.isMuted) return;
        const now = this.ctx.currentTime;
        const tone = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        tone.connect(gain); gain.connect(this.ctx.destination);
        const freqs = [146.83, 174.61, 196.00, 220.00, 261.63, 130.81];
        let f = freqs[Math.floor(Math.random()*freqs.length)];
        if(Math.random() > 0.7) f *= 0.5; 
        tone.type = 'sine';
        tone.frequency.setValueAtTime(f, now);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.03, now + 1);
        gain.gain.linearRampToValueAtTime(0, now + 4);
        tone.start(now);
        tone.stop(now + 4);
        this.bgmTimer = setTimeout(() => this.playBGM(), 3000);
    },
    stopBGM: function() { clearTimeout(this.bgmTimer); }
};

class ItemClass {
    constructor(lvl, x, y, forceRare=false) {
        this.x = x; this.y = y; this.lvl = Math.max(1, lvl); this.isItem = true;
        const types = ['SWORD_1H','SWORD_2H','BOW','CROSSBOW','STAFF','AXE_1H','AXE_2H','SHIELD','HELM','ARMOR','PANTS','BOOTS','AMULET','EARRING','RING','DAGGER'];
        const consumables = ['POTION','MANA_POTION','SCROLL_TP','SPELL_BOOK']; 
        
        if (!forceRare && Math.random() < 0.3) {
            this.type = consumables[randInt(0, consumables.length)];
            this.rarity = { name: '普通', col: '#fff', mul: 1 };
            if (this.type === 'SPELL_BOOK') {
                const spellKeys = Object.keys(SPELLS); this.spellKey = spellKeys[randInt(0, spellKeys.length)];
                this.name = `法術書: ${SPELLS[this.spellKey].name}`; this.rarity = { name: '魔法', col: '#44f', mul: 1 };
            }
        } else {
            this.type = types[randInt(0, types.length)];
            let rRoll = Math.random();
            if (forceRare) rRoll = 0.99; 

            if (rRoll < 0.7 && !forceRare) this.rarity = { name: '普通', col: '#bbb', mul: 1 };
            else if (rRoll < 0.9 && !forceRare) this.rarity = { name: '魔法', col: '#44f', mul: 1.3 };
            else if (rRoll < 0.98) this.rarity = { name: '稀有', col: '#fe0', mul: 1.8 };
            else this.rarity = { name: '傳奇', col: '#f80', mul: 2.5 };
        }
        if (this.type !== 'SPELL_BOOK') {
            const baseVal = ITEM_TYPES[this.type].slot ? 50 : 10;
            this.price = Math.floor(baseVal * this.lvl * (this.rarity.mul || 1));
            this.name = (this.rarity.name !== '普通' ? this.rarity.name + '的' : '') + ITEM_TYPES[this.type].name;
        } else { this.price = 200; }
        
        this.effects = [];
        if (this.type !== 'SPELL_BOOK' && this.rarity.mul > 1) {
            if(Math.random() < 0.15) this.effects.push({type:'燃燒', chance:0.2, val:this.lvl*2});
            if(Math.random() < 0.15) this.effects.push({type:'中毒', chance:0.2, val:this.lvl*1});
            if(Math.random() < 0.15) this.effects.push({type:'暈眩', chance:0.1, val:1.0});
            if(Math.random() < 0.15) this.effects.push({type:'緩速', chance:0.2, val:2.0});
            if(this.type === 'BOOTS') this.effects.push({type:'加速', chance:1.0, val: 10 + this.lvl * 2});
        }

        this.stats = {};
        if (ITEM_TYPES[this.type].slot) {
            let variance = randInt(0, 3);
            let mul = this.rarity.mul;
            this.stats.atk = (['SWORD_1H','SWORD_2H','AXE_1H','AXE_2H','BOW','CROSSBOW','DAGGER'].includes(this.type)) ? Math.floor((10 + this.lvl * 3 + variance) * mul) : 0;
            if(this.type.includes('2H') || this.type === 'CROSSBOW') this.stats.atk = Math.floor(this.stats.atk * 1.6); 
            this.stats.def = (['ARMOR','SHIELD','HELM','PANTS','BOOTS'].includes(this.type)) ? Math.floor((2 + this.lvl * 1.5 + variance) * mul) : 0;
            if (this.type === 'STAFF') this.stats.mag = Math.floor((8 + this.lvl * 3 + variance) * mul);
            if(['AMULET','RING','EARRING'].includes(this.type)) {
                this.stats.str = randInt(0, this.lvl); this.stats.dex = randInt(0, this.lvl); this.stats.mag = randInt(0, this.lvl); this.stats.vit = randInt(0, this.lvl);
            }
            if(mul > 1.2) this.stats.str = (this.stats.str||0) + randInt(1, this.lvl);
            if(mul > 1.5) this.stats.vit = (this.stats.vit||0) + randInt(1, this.lvl);
        }
    }
}

class PlayerClass {
    constructor(raceKey) {
        this.raceKey = raceKey; this.race = RACES[raceKey];
        this.x = 0; this.y = 0; this.lvl = 1; this.xp = 0; this.pts = 0;
        this.baseStats = { ...this.race.stats }; this.stats = { ...this.baseStats, atk: 0, def: 0 };
        this.hp = 100; this.maxHp = 100; this.mp = 50; this.maxMp = 50; this.gold = 50;
        this.icon = '🧙‍♂️';
        if (raceKey === 'ORC') this.icon = '👹'; if (raceKey === 'ELF') this.icon = '🧝'; if (raceKey === 'DWARF') this.icon = '🧔'; if (raceKey === 'UNDEAD') this.icon = '💀';
        this.inv = []; 
        this.equip = { helm:null, necklace:null, earring1:null, earring2:null, armor:null, mainhand:null, offhand:null, ring1:null, ring2:null, pants:null, boots:null };
        this.potions = { HP: 2, MP: 1, TP: 1 };
        this.spells = JSON.parse(JSON.stringify(this.race.startSpells));
        const sKeys = Object.keys(this.spells);
        this.activeSpell = sKeys.length > 0 ? sKeys[0] : null;
        this.atkCd = 0; this.path = []; this.targetEntity = null; this.attackRequested = false; 
        this.attackAnimTimer = 0;
        this.moveSpeed = 90; 
        this.recalc();
    }
    recalc() {
        this.stats = { ...this.baseStats, atk: 0, def: 0, mag: 0, str: 0, vit: 0, dex: 0 };
        this.stats.str += this.baseStats.str; this.stats.dex += this.baseStats.dex; this.stats.mag += this.baseStats.mag; this.stats.vit += this.baseStats.vit;
        let bonusSpeed = 0;
        for (let key in this.equip) {
            if (this.equip[key]) {
                const s = this.equip[key].stats;
                if(s.atk) this.stats.atk += s.atk; if(s.def) this.stats.def += s.def; if(s.mag) this.stats.mag += s.mag; if(s.str) this.stats.str += s.str; if(s.vit) this.stats.vit += s.vit; if(s.dex) this.stats.dex += s.dex;
                if(this.equip[key].effects) { this.equip[key].effects.forEach(e => { if(e.type==='加速') bonusSpeed += e.val; }); }
            }
        }
        this.stats.atk += this.stats.str * 2; 
        this.maxHp = 50 + this.stats.vit * 10 + this.lvl * 10; this.maxMp = 20 + this.stats.mag * 8 + this.lvl * 5;
        this.critChance = 0.05 + this.stats.str * 0.005 + (this.race.critBonus/100);
        this.killChance = 0.00 + (this.stats.str + this.stats.dex) * 0.001 + (this.race.killBonus/100);
        this.evasion = 0.0 + this.stats.dex * 0.005; 
        this.moveSpeed = 90 + (this.stats.dex * 1.5) + bonusSpeed;
    }
    equipItem(it, invIdx, targetSlot = null) {
        if(it.type === 'SPELL_BOOK') {
            if(this.spells[it.spellKey]) { this.spells[it.spellKey] = Math.min(100, this.spells[it.spellKey] + 1); spawnText(this.x, this.y, `法術升級! Lv ${this.spells[it.spellKey]}`, "#0af"); }
            else { this.spells[it.spellKey] = 1; if(!this.activeSpell) this.activeSpell = it.spellKey; spawnText(this.x, this.y, `習得 ${SPELLS[it.spellKey].name}!`, "#0af"); }
            this.inv.splice(invIdx, 1); AudioSys.sfx('level'); game.uiDirty = true; updateSpellIcon(); return;
        }
        if(it.type === 'POTION') { useQuickSlot('HP'); this.inv.splice(invIdx, 1); game.uiDirty=true; return; }
        if(it.type === 'MANA_POTION') { useQuickSlot('MP'); this.inv.splice(invIdx, 1); game.uiDirty=true; return; }
        if(it.type === 'SCROLL_TP') { useQuickSlot('TP'); this.inv.splice(invIdx, 1); game.uiDirty=true; return; }
        
        let slot = targetSlot || ITEM_TYPES[it.type].slot;
        if (!slot) return;
        
        if (ITEM_TYPES[it.type].hands === 2) {
             let reqStr = it.lvl * 3;
             if (this.stats.str < reqStr) { alert(`力量不足! 需要: ${reqStr}`); return; }
        }

        if (slot === 'ring' && !targetSlot) { slot = !this.equip.ring1 ? 'ring1' : (!this.equip.ring2 ? 'ring2' : 'ring1'); }
        if (slot === 'earring' && !targetSlot) { slot = !this.equip.earring1 ? 'earring1' : (!this.equip.earring2 ? 'earring2' : 'earring1'); }

        if (this.equip[slot]) this.inv.push(this.equip[slot]);
        
        if (ITEM_TYPES[it.type].hands === 2) { 
            if((it.type === 'BOW' || it.type === 'CROSSBOW') && this.equip.offhand && this.equip.offhand.type === 'DAGGER') {
            } else {
                if(this.equip.offhand) { this.inv.push(this.equip.offhand); this.equip.offhand = null; }
            }
            if(slot === 'offhand') slot = 'mainhand'; 
        }
        if (slot === 'offhand' && this.equip.mainhand && ITEM_TYPES[this.equip.mainhand.type].hands === 2) { 
            if ((this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW') && it.type === 'DAGGER') {
            } else {
                this.inv.push(this.equip.mainhand); this.equip.mainhand = null; 
            }
        }
        
        if (!targetSlot && ITEM_TYPES[it.type].hands === 1 && slot === 'mainhand' && this.equip.mainhand && !this.equip.offhand && it.type !== 'SHIELD') { slot = 'offhand'; }
        if (!targetSlot && it.type === 'DAGGER' && this.equip.mainhand && (this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW')) { slot = 'offhand'; }
        
        if (slot === 'offhand' && this.equip.mainhand && ITEM_TYPES[this.equip.mainhand.type].hands === 2) {
             if (!((this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW') && it.type === 'DAGGER')) {
                 this.inv.push(this.equip.mainhand); this.equip.mainhand = null;
             }
        }

        this.equip[slot] = it; this.inv.splice(invIdx, 1); this.recalc(); game.uiDirty = true; AudioSys.sfx('coin');
    }
}

function randInt(min,max){return Math.floor(Math.random()*(max-min)+min);}

function isSolid(x,y){ 
    const tx=Math.floor(x/40), ty=Math.floor(y/40); 
    if(tx<0||tx>=60||ty<0||ty>=60) return true;
    return game.map[ty][tx]===1; 
}

function hasLineOfSight(x1, y1, x2, y2) {
    if (x1<0||x1>=60||y1<0||y1>=60||x2<0||x2>=60||y2<0||y2>=60) return false;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1); let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1; let err = dx - dy;
    let maxIter = 200; 
    while (maxIter-- > 0) {
        if (x1 === x2 && y1 === y2) return true; 
        if (game.map[y1][x1] === 1) return false;
        let e2 = 2 * err; if (e2 > -dy) { err -= dy; x1 += sx; } if (e2 < dx) { err += dx; y1 += sy; }
        if (x1<0||x1>=60||y1<0||y1>=60) return false;
    }
    return false;
}

function isBlocked(x, y, self) {
    if(isSolid(x, y)) return true;
    for(let e of game.entities) {
        if(e !== self && !e.dead) {
            if (e.isEnemy && self.isEnemy) continue; 
            if (self === game.player && e.isEnemy && Math.hypot(e.x - x, e.y - y) < 25) { return false; }
            if (self.isEnemy && e === game.player && Math.hypot(e.x - x, e.y - y) < 25) return true; 
        }
    }
    return false;
}

function findPath(sx, sy, tx, ty) {
    let startNode = {x: Math.floor(sx/40), y: Math.floor(sy/40)};
    let endNode = {x: Math.floor(tx/40), y: Math.floor(ty/40)};
    if (endNode.x < 0 || endNode.x >= 60 || endNode.y < 0 || endNode.y >= 60) return [];
    
    if (game.map[endNode.y][endNode.x] === 1) {
        let best = null; let minD = 999;
        [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d=>{
            let nx=endNode.x+d.x, ny=endNode.y+d.y;
            if(nx>=0 && nx<60 && ny>=0 && ny<60 && game.map[ny][nx] !== 1) {
                let d = Math.hypot(nx-startNode.x, ny-startNode.y);
                if(d < minD) { minD = d; best = {x:nx, y:ny}; }
            }
        });
        if(best) { endNode = best; } else return [];
    }

    if (hasLineOfSight(startNode.x, startNode.y, endNode.x, endNode.y)) {
        return [{x: endNode.x*40+20, y: endNode.y*40+20}];
    }

    let queue = [startNode]; let cameFrom = {}; let key = (n) => n.x + ',' + n.y; cameFrom[key(startNode)] = null;
    let current = null; let maxSteps = 1000;
    while(queue.length > 0 && maxSteps-- > 0) {
        current = queue.shift();
        if (current.x === endNode.x && current.y === endNode.y) break;
        [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d => {
            let next = {x: current.x + d.x, y: current.y + d.y};
            if (next.x >= 0 && next.x < 60 && next.y >= 0 && next.y < 60 && game.map[next.y][next.x] !== 1) {
                if (cameFrom[key(next)] === undefined) { queue.push(next); cameFrom[key(next)] = current; }
            }
        });
    }
    
    if (!current || (current.x !== endNode.x && current.y !== endNode.y)) return [];
    let path = []; let curr = endNode;
    while (curr && (curr.x !== startNode.x || curr.y !== startNode.y)) {
        path.push({x: curr.x * 40 + 20, y: curr.y * 40 + 20});
        curr = cameFrom[key(curr)];
        if(!curr && path.length > 0) break;
    }
    return path.reverse();
}

function computeFOV(px, py, radius) {
    let visible = []; for(let y=0; y<60; y++) visible[y] = []; 
    if(px>=0 && px<60 && py>=0 && py<60) visible[py][px] = true;
    const rays = 360;
    for (let i = 0; i < rays; i++) {
        let angle = (i * Math.PI) / 180; let dx = Math.cos(angle); let dy = Math.sin(angle); let ox = px + 0.5, oy = py + 0.5;
        for (let j = 0; j < radius; j++) {
            ox += dx; oy += dy; let tx = Math.floor(ox), ty = Math.floor(oy);
            if (tx < 0 || tx >= 60 || ty < 0 || ty >= 60) break;
            visible[ty][tx] = true; if (game.map[ty][tx] === 1) break;
        }
    }
    return visible;
}

function createRoomsAndCorridors(lvl) {
    let map = []; for(let y=0;y<60;y++){ let r=[]; for(let x=0;x<60;x++) r.push(1); map.push(r); }
    let rooms = []; const numRooms = 15 + Math.floor(Math.random() * 5);
    for (let i = 0; i < numRooms; i++) {
        let w = randInt(5, 11); let h = randInt(5, 11); let x = randInt(2, 57 - w); let y = randInt(2, 57 - h);
        let overlap = false; for (let r of rooms) { if (x < r.x + r.w + 1 && x + w + 1 > r.x && y < r.y + r.h + 1 && y + h + 1 > r.y) { overlap = true; break; } }
        if (!overlap) { rooms.push({x, y, w, h, cx: Math.floor(x + w / 2), cy: Math.floor(y + h / 2)}); for (let ry = y; ry < y + h; ry++) for (let rx = x; rx < x + w; rx++) map[ry][rx] = 0; }
    }
    for (let i = 1; i < rooms.length; i++) {
        let r1 = rooms[i-1], r2 = rooms[i]; let cx1 = r1.cx, cy1 = r1.cy, cx2 = r2.cx, cy2 = r2.cy;
        if (Math.random() < 0.5) {
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy1][x] = 0; map[cy1+1][x] = 0; }
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx2] = 0; map[y][cx2+1] = 0; }
        } else {
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx1] = 0; map[y][cx1+1] = 0; }
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy2][x] = 0; map[cy2+1][x] = 0; }
        }
    }
    return {map, rooms};
}

function genFloor(lvl) {
    game.floor = lvl;
    game.map=[]; game.visited=[]; game.visibleTiles=[]; game.entities=[]; game.items=[]; game.projs=[];
    game.transitionCooldown = 2.0; game.bossActive = (lvl > 0 && lvl % 5 === 0);
    const themes = [{f:'#181818', w:'#222'}, {f:'#1a1f1a', w:'#203020'}, {f:'#221010', w:'#331111'}];
    game.theme = themes[Math.floor((lvl-1)/3) % 3] || themes[0];

    for(let y=0;y<60;y++){ let v=[]; let vt=[]; for(let x=0;x<60;x++) { v.push(false); vt.push(false); } game.visited.push(v); game.visibleTiles.push(vt); }

    if(lvl===0){ 
        for(let y=0;y<60;y++){ let r=[]; for(let x=0;x<60;x++) r.push(1); game.map.push(r); }
        for(let y=20;y<40;y++) for(let x=20;x<40;x++) game.map[y][x]=0;
        if(!game.savedPlayerPos) {
            game.player.x=30*40+20; game.player.y=30*40+20;
        }
        game.entities.push({x:25*40+20,y:25*40+20,size:22,type:'NPC_ELDER',icon:'👴',name:'長老'});
        game.entities.push({x:35*40+20,y:25*40+20,size:22,type:'NPC_GENERAL',icon:'💰',name:'商人'});
        if(game.dungeonCache) {
             game.entities.push({x:30*40+20, y:28*40+20, type:'PORTAL_DUNGEON', icon:'🌀', name:'回城傳送門', dead:false, size:30});
        }
        game.map[35][30]=2; spawnText(game.player.x, game.player.y - 50, "城鎮", "#ffd700");
        
        // 更新城鎮視野
        game.visibleTiles = computeFOV(Math.floor(game.player.x/40), Math.floor(game.player.y/40), 10);
        for(let y=0; y<60; y++) for(let x=0; x<60; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;

    } else {
        const dungeon = createRoomsAndCorridors(lvl);
        game.map = dungeon.map;
        const rooms = dungeon.rooms;
        let startRoom = rooms[0];
        game.map[startRoom.cy][startRoom.cx] = 6;
        game.player.x = (startRoom.cx + 1) * 40 + 20; game.player.y = startRoom.cy * 40 + 20;
        let endRoom = rooms[rooms.length - 1];
        if (game.bossActive) {
            game.entities.push({x: endRoom.cx*40+20, y: endRoom.cy*40+20, isEnemy: true, isBoss: true, hp: 1000 + lvl * 200, maxHp: 1000 + lvl * 200, dmg: 40 + lvl * 10, icon: '👹', name: '守門者', dead: false, size: 40});
            spawnText(game.player.x, game.player.y - 100, "警告：BOSS 出現！", "#f00");
        } else { game.map[endRoom.cy][endRoom.cx] = 2; }
        
        if(Math.random() < 0.3) { let r = rooms[randInt(1, rooms.length-1)]; game.entities.push({x:r.cx*40+20, y:r.cy*40+20, type:'NPC_ADVENTURER', icon:'🤕', name:'受傷冒險者', dead:false, size:20}); }

        for (let i = 1; i < rooms.length - 1; i++) {
            let r = rooms[i];
            if(Math.random() < 0.2) {
                let tx, ty, tries=0;
                do { tx = randInt(r.x, r.x+r.w) * 40 + 20; ty = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(tx, ty) && tries < 50);
                game.entities.push({x:tx, y:ty, type:'TRAP', icon:'⚠️', name:'陷阱', dead:false, size:20, hidden:true, triggered:false});
            }
            let numMobs = randInt(5, 8 + Math.floor(lvl/2)); 
            for(let m=0; m<numMobs; m++) {
                let mx, my, tries=0;
                do { mx = randInt(r.x, r.x+r.w) * 40 + 20; my = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(mx, my) && tries < 50);
                let mKeys = Object.keys(MONSTERS);
                let limit = lvl <= 2 ? 3 : (lvl <= 5 ? 6 : mKeys.length);
                let mKey = mKeys[randInt(0, limit)];
                let template = MONSTERS[mKey];
                let isElite = Math.random() < 0.05 + (lvl * 0.01);
                let hp = Math.floor(template.hp + lvl * 10); 
                let dmg = Math.floor(template.dmg + lvl * 2);
                if (isElite) { hp = Math.floor(hp * 2.5); dmg = Math.floor(dmg * 1.5); }
                game.entities.push({
                    x:mx, y:my, isEnemy:true, 
                    hp:hp, maxHp:hp, 
                    dmg:dmg, icon:template.icon, subIcon:template.subIcon, name:template.name,
                    ranged: template.ranged, projIcon: template.projIcon, range: template.range || 50,
                    speed: template.speed || 75,
                    dead:false, size:20, lvl: lvl,
                    pushX: 0, pushY: 0,
                    isElite: isElite
                });
            }
            if (Math.random() < 0.3) {
                let cx, cy, tries=0;
                do { cx = randInt(r.x, r.x+r.w) * 40 + 20; cy = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(cx, cy) && tries < 50);
                let isTrapped = Math.random() < 0.25;
                game.entities.push({x:cx, y:cy, type:'CHEST', icon:'📦', name:'寶箱', dead:false, size:20, trapped: isTrapped});
            }
        }
        spawnText(game.player.x, game.player.y - 50, "地下城 第 " + lvl + " 層", "#f00");
        
        // 初始更新視野
        game.visibleTiles = computeFOV(Math.floor(game.player.x/40), Math.floor(game.player.y/40), 10);
        for(let y=0; y<60; y++) for(let x=0; x<60; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;
    }
}

function update() {
    try {
        if(game.dead) return;
        if(!game.running) return;
        const p=game.player; const dt=0.016; 
        p.atkCd-=dt; p.attackAnimTimer -= dt;
        if(game.transitionCooldown > 0) game.transitionCooldown -= dt;

        const tx=Math.floor(p.x/40), ty=Math.floor(p.y/40);
        game.visibleTiles = computeFOV(tx, ty, 10);
        for(let y=0; y<60; y++) for(let x=0; x<60; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;

        let regenMult = (p.path.length > 0 || joystick.active) ? 0.2 : 1.0; 
        let hpRegenBase = p.maxHp * 0.002 * regenMult; let mpRegenBase = p.maxMp * 0.005;
        p.hp = Math.min(p.maxHp, p.hp + hpRegenBase * (1 + p.stats.vit * 0.2) * dt);
        p.mp = Math.min(p.maxMp, p.mp + mpRegenBase * (1 + p.stats.mag * 0.2) * dt);
        p.regenInfo = { hp: hpRegenBase * (1 + p.stats.vit * 0.2), mp: mpRegenBase * (1 + p.stats.mag * 0.2) };
        
        if(p.poisonTimer > 0) {
            p.poisonTimer -= dt; p.hp -= p.poisonDmg * dt;
            if(Math.random() < 0.05) spawnText(p.x, p.y-30, "中毒!", "#0f0");
            if(p.poisonTimer <= 0) p.poisonDmg = 0;
        }

        // 推擠力重置
        let pushX = 0, pushY = 0;
        
        // 處理玩家被怪物包圍時的推擠
        game.entities.forEach(e => {
            if (e.isEnemy && !e.dead) {
                let dist = Math.hypot(e.x - p.x, e.y - p.y);
                if (dist < 30) {
                    let angle = Math.atan2(p.y - e.y, p.x - e.x);
                    let force = (30 - dist) * 5; // 推力係數
                    pushX += Math.cos(angle) * force;
                    pushY += Math.sin(angle) * force;
                }
            }
        });

        if(joystick.active) {
            let speed=p.moveSpeed; 
            let nx=p.x + (joystick.vector.x * speed + pushX) * dt; 
            let ny=p.y + (joystick.vector.y * speed + pushY) * dt;
            
            if(!isBlocked(nx,p.y,p)) p.x=nx; 
            if(!isBlocked(p.x,ny,p)) p.y=ny; 
            
            p.path=[]; p.targetEntity=null; 
            if(joystick.vector.x!==0 || joystick.vector.y!==0) p.facing=Math.atan2(joystick.vector.y,joystick.vector.x);
        } else if(p.targetEntity && !p.targetEntity.dead) {
            const dist=Math.hypot(p.targetEntity.x-p.x, p.targetEntity.y-p.y);
            p.facing = Math.atan2(p.targetEntity.y - p.y, p.targetEntity.x - p.x);
            let dx=p.targetEntity.x-p.x, dy=p.targetEntity.y-p.y; 
            if (p.targetEntity.isEnemy && !p.targetEntity.charmed && dist <= (p.equip.mainhand ? ITEM_TYPES[p.equip.mainhand.type].range : 35)) {
                 // 攻擊範圍內，不動，但受推力影響
                 let nx = p.x + pushX * dt; let ny = p.y + pushY * dt;
                 if(!isBlocked(nx, p.y, p)) p.x = nx; if(!isBlocked(p.x, ny, p)) p.y = ny;
                 if(p.attackRequested) { attack(p.targetEntity); p.attackRequested = false; }
                 p.path = [];
            } else {
                 if(dist < 40 && !p.targetEntity.isEnemy) {
                    if(p.targetEntity.type === 'CHEST') openChest(p.targetEntity);
                    else if(p.targetEntity.type && p.targetEntity.type.startsWith('NPC')) interactNPC(p.targetEntity); 
                    else if(p.targetEntity.type === 'PORTAL_TOWN') useTownPortal(true); 
                    else if(p.targetEntity.type === 'PORTAL_DUNGEON') useTownPortal(true); 
                    else if(p.targetEntity.isItem) pickup(p.targetEntity);
                    p.targetEntity = null; p.path = [];
                 } else {
                    let moveS = p.moveSpeed*dt; 
                    let mx = (dx/dist*moveS) + (pushX*dt);
                    let my = (dy/dist*moveS) + (pushY*dt);
                    if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                 }
            }
        } else if(p.path.length>0) {
            let next=p.path[0]; let dx=next.x-p.x, dy=next.y-p.y; let dist=Math.sqrt(dx*dx+dy*dy);
            if(dist<8) p.path.shift(); else { 
                let s=p.moveSpeed; 
                let mx = (dx/dist*s + pushX)*dt; 
                let my = (dy/dist*s + pushY)*dt;
                if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                if(dx!==0||dy!==0) p.facing=Math.atan2(dy,dx); 
            }
        } else {
            // 站立不動時也要受推力
            if(pushX !== 0 || pushY !== 0) {
                let nx = p.x + pushX * dt; let ny = p.y + pushY * dt;
                if(!isBlocked(nx, p.y, p)) p.x = nx; if(!isBlocked(p.x, ny, p)) p.y = ny;
            }
        }

        game.entities.forEach(e=>{
            // 怪物推擠
            if (e.isEnemy && !e.dead) {
                game.entities.forEach(other => {
                    if (e !== other && other.isEnemy && !other.dead) {
                        let dx = e.x - other.x; let dy = e.y - other.y;
                        let dist = Math.hypot(dx, dy);
                        if (dist < 25 && dist > 0) { 
                            let force = (25 - dist) * 2 * dt;
                            e.x += (dx/dist) * force; e.y += (dy/dist) * force;
                        }
                    }
                });
            }
            if(e.type === 'TRAP' && !e.triggered && Math.hypot(e.x-p.x, e.y-p.y) < 20) {
                 e.triggered = true; e.hidden = false; e.icon = '🩸';
                 let dmg = 25 + game.floor * 10; p.hp -= dmg; spawnText(p.x, p.y, `陷阱! -${dmg}`, "red"); AudioSys.sfx('hit');
            }
            if(e.slowTimer > 0) e.slowTimer -= dt;
            if(e.effectTimer > 0) { 
                e.effectTimer -= dt;
                if(e.effectType === 'confused') {
                     if(Math.random() < 0.05) {
                         let victim = game.entities.concat([game.player]).find(v => v!==e && !v.dead && Math.hypot(v.x-e.x, v.y-e.y) < 150);
                         if(victim) {
                             e.target = victim; 
                             let ang = Math.atan2(victim.y - e.y, victim.x - e.x);
                             game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*250, vy:Math.sin(ang)*250, life:1.0, dmg:e.dmg, enemyProj:true}); 
                         }
                     }
                     e.vx = (Math.random()-0.5)*100; e.vy = (Math.random()-0.5)*100;
                     let nx = e.x + e.vx * dt; let ny = e.y + e.vy * dt;
                     if(!isBlocked(nx, ny, e)) { e.x = nx; e.y = ny; }
                }
                if(e.effectTimer <= 0) { e.effectType = null; if(e.charmed) { e.charmed = false; e.isEnemy = true; } }
            }
            if(e.isEnemy && !e.dead && !e.charmed && e.effectType !== 'confused'){
                const dist = Math.hypot(p.x-e.x,p.y-e.y);
                const ex = Math.floor(e.x/40), ey = Math.floor(e.y/40);
                const playerVisible = hasLineOfSight(ex, ey, tx, ty);
                if (e.hp < e.maxHp && !e.target) e.target = p; 
                
                // AI 行為: 逃跑 (Flee)
                let isFleeing = false;
                if (e.hp < e.maxHp * 0.3 && Math.random() < 0.02) { // 30%血以下，有機率逃跑
                    e.target = null; // 放棄目標
                    let ang = Math.atan2(e.y - p.y, e.x - p.x); // 反向
                    let fleeX = Math.cos(ang) * 100 * dt;
                    let fleeY = Math.sin(ang) * 100 * dt;
                    if(!isBlocked(e.x + fleeX, e.y + fleeY, e)) { e.x += fleeX; e.y += fleeY; }
                    isFleeing = true;
                }

                // AI 行為: 閃避 (Dodge)
                if (!isFleeing && e.ranged && dist < 150 && p.atkCd > 0 && Math.random() < 0.05) {
                     let ang = Math.atan2(e.y - p.y, e.x - p.x) + (Math.random() < 0.5 ? 1.5 : -1.5); 
                     let dodgeX = Math.cos(ang) * 120 * dt;
                     let dodgeY = Math.sin(ang) * 120 * dt;
                     if(!isBlocked(e.x + dodgeX, e.y + dodgeY, e)) { e.x += dodgeX; e.y += dodgeY; }
                     isFleeing = true; 
                }

                if(!isFleeing && ((playerVisible && dist < 300) || e.target === p)) {
                    if (e.ranged && dist < e.range && dist > 80) { // 保持距離
                        e.atkCd = (e.atkCd || 0) - dt;
                        if (e.atkCd <= 0) {
                            let ang = Math.atan2(p.y - e.y, p.x - e.x);
                            game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*250, vy:Math.sin(ang)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:e.projIcon});
                            e.atkCd = 2.0;
                        }
                    } else {
                        const a=Math.atan2(p.y-e.y,p.x-e.x); 
                        let currentSpeed = (e.speed || 75) * (e.slowTimer > 0 ? 0.5 : 1);
                        let nx=e.x+Math.cos(a)*currentSpeed*dt, ny=e.y+Math.sin(a)*currentSpeed*dt; 
                        if(!isBlocked(nx,e.y, e)) e.x=nx; if(!isBlocked(e.x,ny, e)) e.y=ny;
                    }
                } else if (!isFleeing && !e.isBoss && !e.target && Math.random() < 0.005) { 
                    let ang = Math.random() * 6.28; e.vx = Math.cos(ang) * 20; e.vy = Math.sin(ang) * 20; e.wanderTime = 1.0 + Math.random(); 
                }
                if(e.wanderTime > 0) { let nx = e.x + e.vx * dt; let ny = e.y + e.vy * dt; if(!isBlocked(nx, ny, e)) { e.x = nx; e.y = ny; } e.wanderTime -= dt; }
                
                // 攻擊判斷
                if(dist < 45 && Math.random() < 0.025){ 
                    p.hp-=Math.max(1, e.dmg-p.stats.def); AudioSys.sfx('hit'); spawnText(p.x,p.y-30,"-"+Math.floor(Math.max(1, e.dmg-p.stats.def)),"red"); game.uiDirty=true; 
                }
            }
            
            if((e.type === 'MINION' || e.charmed) && !e.dead) {
                if(e.type === 'MINION') { e.life -= dt; if(e.life <= 0) e.dead = true; }
                let target = game.entities.find(t => t.isEnemy && !t.dead && !t.charmed && Math.hypot(t.x-e.x, t.y-e.y) < 300 && game.visibleTiles[Math.floor(t.y/40)][Math.floor(t.x/40)]);
                if(target) { 
                    let dx = target.x - e.x, dy = target.y - e.y; let d = Math.hypot(dx,dy); 
                    if(d > 30) { e.x += dx/d * 90 * dt; e.y += dy/d * 90 * dt; } 
                    else { 
                        e.atkCd = (e.atkCd || 0) - dt;
                        if(e.atkCd <= 0) {
                            target.hp -= (e.dmg || 10); spawnText(target.x, target.y, (e.dmg||10), "#eee");
                            if(target.hp<=0) killEnemy(target); e.atkCd = 1.0;
                        }
                    } 
                } else { 
                    let dx = p.x - e.x, dy = p.y - e.y; let d = Math.hypot(dx,dy); 
                    if(d > 80) { e.x += dx/d * 100 * dt; e.y += dy/d * 100 * dt; } 
                }
            }
        });

        for(let i=game.projs.length-1;i>=0;i--){ 
            const pr=game.projs[i]; 
            if(pr.delay) { 
                pr.delay -= dt; if(pr.delay <= 0) { pr.delay = 0; pr.life = 0.2; AudioSys.sfx('hit'); game.entities.forEach(e => { if(e.isEnemy && !e.dead && Math.hypot(e.x-pr.x, e.y-pr.y) < 60) { e.hp -= pr.dmg; spawnText(e.x, e.y, pr.dmg, "#f00"); if(e.hp<=0) killEnemy(e); } }); } continue;
            }
            if(pr.isStatic) { 
                pr.life -= dt;
                if(pr.life<=0) game.projs.splice(i,1); else { game.entities.forEach(e => { if(e.isEnemy && !e.dead && Math.hypot(e.x-pr.x, e.y-pr.y) < 30 && Math.random() < 0.1) { e.hp -= pr.dmg; spawnText(e.x, e.y, pr.dmg, "#f60"); if(e.hp<=0) killEnemy(e); } }); } continue; 
            }
            
            pr.x+=pr.vx*dt; pr.y+=pr.vy*dt; pr.life-=dt; 
            if(pr.life<=0||isSolid(pr.x,pr.y)){game.projs.splice(i,1);continue;} 
            
            if (pr.enemyProj) {
                if (Math.hypot(p.x - pr.x, p.y - pr.y) < 20) {
                    p.hp -= Math.max(1, pr.dmg - p.stats.def);
                    spawnText(p.x, p.y-30, "-"+Math.floor(Math.max(1, pr.dmg - p.stats.def)), "red");
                    AudioSys.sfx('hit'); game.uiDirty=true; game.projs.splice(i,1);
                }
            } else {
                let hit=game.entities.find(e=>e.isEnemy && !e.charmed && !e.dead && Math.hypot(e.x-pr.x,e.y-pr.y)<35); 
                if(hit){ 
                    let finalDmg = pr.dmg;
                    if(Math.random() < p.critChance) { finalDmg *= 2; spawnText(hit.x, hit.y-50, "爆擊!", "#ff0"); }
                    if(!hit.isBoss && Math.random() < p.killChance) { finalDmg = hit.hp + 999; spawnText(hit.x, hit.y-60, "必殺!", "#f00"); }
                    hit.hp-=finalDmg; hit.target = p; 
                    if(pr.isIce) hit.slowTimer = 3.0; 
                    if(pr.effect === 'confused') { hit.effectType = 'confused'; hit.effectTimer = 5.0; spawnText(hit.x, hit.y-40, "混亂!", "#f0f"); }
                    if(pr.effect === 'charmed') { 
                        hit.effectType = 'charmed'; hit.charmed = true; hit.isEnemy = false; hit.effectTimer = 8.0; 
                        spawnText(hit.x, hit.y-40, "魅惑!", "#f66"); 
                        if(game.player.targetEntity === hit) { game.player.targetEntity = null; game.player.path = []; }
                    }
                    AudioSys.sfx('hit'); spawnText(hit.x,hit.y-30,Math.floor(finalDmg), pr.isIce?"#0af":"#fff"); 
                    if(hit.hp<=0) killEnemy(hit); game.projs.splice(i,1); 
                } 
            }
        }
        if(p.hp <= 0 && !game.dead) { handlePlayerDeath(); }
        game.cam.x+=(p.x-game.cam.x)*0.12; game.cam.y+=(p.y-game.cam.y)*0.12; 
        updateUI(); 
        if(typeof drawMinimap === 'function') drawMinimap();
    } catch(e) { console.log(e); }
}

function draw() {
    try {
        if(!game.running || !gameCtx) return;
        gameCtx.fillStyle = game.floor === 0 ? '#223322' : '#000';
        gameCtx.fillRect(0,0,gameCanvas.width,gameCanvas.height);
        gameCtx.save(); gameCtx.translate(gameCanvas.width/2-game.cam.x, gameCanvas.height/2-game.cam.y);
        for(let y=0;y<60;y++) for(let x=0;x<60;x++){
            if(Math.abs(x*40 - game.cam.x) > gameCanvas.width/2 + 60) continue; 
            if(Math.abs(y*40 - game.cam.y) > gameCanvas.height/2 + 60) continue;
            let visible = game.floor === 0 ? true : (game.visibleTiles[y] && game.visibleTiles[y][x]); 
            let visited = game.floor === 0 ? true : (game.visited[y] && game.visited[y][x]);
            if (!visible && !visited) continue; 
            const t=game.map[y][x]; 
            if (visible) {
                if(t===1){ gameCtx.fillStyle=game.theme.w; gameCtx.beginPath(); gameCtx.arc(x*40+20,y*40+20,24,0,Math.PI*2); gameCtx.fill(); }
                else { 
                    gameCtx.fillStyle = (game.floor === 0) ? ((x%2==y%2)?'#284020':'#253a20') : game.theme.f; 
                    gameCtx.fillRect(x*40,y*40,40,40); gameCtx.strokeStyle='#000'; gameCtx.strokeRect(x*40,y*40,40,40); 
                    if(t===2) { gameCtx.font='22px serif'; gameCtx.fillStyle='#aaa'; gameCtx.fillText('⬇️', x*40+5,y*40+30); } 
                    if(t===6) { gameCtx.font='22px serif'; gameCtx.fillStyle='#aaa'; gameCtx.fillText('⬆️', x*40+5,y*40+30); } 
                }
            } else if (visited) {
                if(t===1){ gameCtx.fillStyle='#111'; gameCtx.beginPath(); gameCtx.arc(x*40+20,y*40+20,24,0,Math.PI*2); gameCtx.fill(); }
                else { gameCtx.fillStyle='#050505'; gameCtx.fillRect(x*40,y*40,40,40); gameCtx.strokeStyle='#111'; gameCtx.strokeRect(x*40,y*40,40,40); }
            }
        }
        game.items.forEach(i=>{ if(game.floor===0 || (game.visibleTiles[Math.floor(i.y/40)] && game.visibleTiles[Math.floor(i.y/40)][Math.floor(i.x/40)])) { gameCtx.font='22px serif'; gameCtx.fillStyle='#fd0'; gameCtx.fillText(i.type==='GOLD'?'💰':ITEM_TYPES[i.type].icon, i.x-10, i.y+5); } });
        game.entities.forEach(e=>{ 
            if(e.hidden) return;
            let ex = Math.floor(e.x/40), ey = Math.floor(e.y/40);
            if(!e.dead && (game.floor === 0 || (game.visibleTiles[ey] && game.visibleTiles[ey][ex]))){ 
                if (e.isElite) {
                    gameCtx.save();
                    gameCtx.fillStyle = 'rgba(200, 0, 255, 0.3)';
                    gameCtx.beginPath();
                    gameCtx.arc(e.x, e.y, 25, 0, Math.PI * 2);
                    gameCtx.fill();
                    gameCtx.restore();
                }
                gameCtx.font=(e.size?e.size+4:26)+'px serif'; gameCtx.fillText(e.icon, e.x-13,e.y+9); 
                if(e.subIcon) { gameCtx.font='14px serif'; gameCtx.fillText(e.subIcon, e.x+5, e.y+15); } 
                if(e.slowTimer > 0) { gameCtx.globalAlpha = 0.5; gameCtx.fillStyle = '#0af'; gameCtx.beginPath(); gameCtx.arc(e.x,e.y,20,0,Math.PI*2); gameCtx.fill(); gameCtx.globalAlpha = 1; } 
                if(e.effectType === 'confused') { gameCtx.font='16px serif'; gameCtx.fillText('?', e.x, e.y-30); }
                if(e.effectType === 'charmed') { gameCtx.font='16px serif'; gameCtx.fillText('❤️', e.x, e.y-30); }
                if(e.isEnemy && !e.charmed){ gameCtx.fillStyle='red'; gameCtx.fillRect(e.x-15,e.y-25,30,4); gameCtx.fillStyle='#0f0'; gameCtx.fillRect(e.x-15,e.y-25,30*(e.hp/e.maxHp),4); } 
                else { gameCtx.fillStyle='#fff'; gameCtx.font='12px serif'; gameCtx.fillText(e.name, e.x-15, e.y-25); }
                if(e.type === 'MINION' || e.charmed) { gameCtx.fillStyle='#0ff'; gameCtx.fillRect(e.x-10,e.y-20,20,3); }
            } 
        });
        if(game.player) {
            let p = game.player;
            gameCtx.save(); gameCtx.translate(p.x, p.y);
            gameCtx.font='32px serif'; gameCtx.fillText(p.icon, -16, 12);
            if(p.equip.helm) { gameCtx.font='22px serif'; gameCtx.fillText('🪖', -11, -20); } // Helm Higher
            let mainHand = p.equip.mainhand; let offHand = p.equip.offhand;
            if(mainHand) {
                gameCtx.save(); let handOffset = 15;
                gameCtx.rotate(p.facing); gameCtx.translate(handOffset, 5); 
                if (p.attackAnimTimer > 0) { gameCtx.rotate(Math.sin(p.attackAnimTimer * 20) * 1.5); }
                gameCtx.rotate(Math.PI / 4); let scale = ITEM_TYPES[mainHand.type].scale || 1.0;
                gameCtx.scale(scale, scale);
                gameCtx.font='20px serif'; gameCtx.fillText(ITEM_TYPES[mainHand.type].icon, -10, 5); 
                gameCtx.restore();
            }
            if(offHand) {
                gameCtx.save(); gameCtx.rotate(p.facing); gameCtx.translate(10, -5); 
                if (offHand.type === 'DAGGER' && p.attackAnimTimer > 0 && p.targetEntity && Math.hypot(p.targetEntity.x-p.x, p.targetEntity.y-p.y) < 60) {
                     gameCtx.rotate(-Math.sin(p.attackAnimTimer * 20) * 1.5); 
                }
                gameCtx.rotate(Math.PI / 4); let scale = ITEM_TYPES[offHand.type].scale || 1.0;
                gameCtx.scale(scale, scale);
                gameCtx.font='18px serif'; gameCtx.fillText(ITEM_TYPES[offHand.type].icon, -10, 5);
                gameCtx.restore();
            }
            if(p.attackAnimTimer > 0) {
                gameCtx.rotate(p.facing); gameCtx.fillStyle = 'rgba(255,255,255,0.3)'; 
                gameCtx.beginPath(); gameCtx.arc(0, 0, 50, -0.5, 0.5); gameCtx.lineTo(0,0); gameCtx.fill(); 
            }
            if(p.targetEntity) { gameCtx.strokeStyle = 'rgba(255,0,0,0.3)'; gameCtx.beginPath(); gameCtx.moveTo(0, 0); gameCtx.lineTo(p.targetEntity.x - p.x, p.targetEntity.y - p.y); gameCtx.stroke(); }
            gameCtx.restore();
        }
        game.projs.forEach(p=>{ 
            if(game.floor===0 || (game.visibleTiles[Math.floor(p.y/40)] && game.visibleTiles[Math.floor(p.y/40)][Math.floor(p.x/40)])) {
                if(p.delay) { gameCtx.fillStyle='rgba(255,0,0,0.3)'; gameCtx.beginPath(); gameCtx.arc(p.x,p.y,60,0,Math.PI*2); gameCtx.fill(); } 
                else if (p.isStatic) { gameCtx.fillStyle='rgba(255,100,0,0.6)'; gameCtx.beginPath(); gameCtx.arc(p.x,p.y,20,0,Math.PI*2); gameCtx.fill(); } 
                else { 
                    if (p.icon) { gameCtx.font='16px serif'; gameCtx.fillText(p.icon, p.x-8, p.y+4); }
                    else if (p.isArrow) { gameCtx.save(); gameCtx.translate(p.x, p.y); gameCtx.rotate(Math.atan2(p.vy, p.vx)); gameCtx.font='20px serif'; gameCtx.fillText('➳', 0, 0); gameCtx.restore(); }
                    else if (p.isIce) { gameCtx.fillStyle='#0af';gameCtx.beginPath();gameCtx.arc(p.x,p.y,5,0,Math.PI*2);gameCtx.fill(); }
                    else { gameCtx.fillStyle='#fa0';gameCtx.beginPath();gameCtx.arc(p.x,p.y,5,0,Math.PI*2);gameCtx.fill(); }
                } 
            }
        });
        
        let hoverTarget = getTargetAt(mouse.wx, mouse.wy);
        let hud = document.getElementById('monster-hud');
        if (hoverTarget && hoverTarget.isEnemy) {
            hud.style.display = 'block';
            let eliteText = hoverTarget.isElite ? "<span style='color:#d0f'>(菁英)</span> " : "";
            hud.innerHTML = `${eliteText}${hoverTarget.name} - HP: ${hoverTarget.hp}/${hoverTarget.maxHp}`;
        } else {
            hud.style.display = 'none';
        }
        gameCtx.restore();
    } catch(e) { console.log(e); }
}

function drawMinimap() {
    if(!minimapCtx || !game.running) return;
    minimapCtx.fillStyle = '#000'; 
    minimapCtx.fillRect(0,0,150,150); 
    const cw = 150/60;
    
    for(let y=0;y<60;y++) for(let x=0;x<60;x++) { 
        if(game.visited[y] && game.visited[y][x]) { 
            if(game.map[y][x] === 1) {
                // Draw walls
                minimapCtx.fillStyle = '#444'; 
            } else {
                // Draw floor
                minimapCtx.fillStyle = '#888'; 
            }
            
            if(game.map[y][x] === 2) minimapCtx.fillStyle = '#0f0'; // Down
            if(game.map[y][x] === 6) minimapCtx.fillStyle = '#aaf'; // Up
            
            minimapCtx.fillRect(x*cw, y*cw, cw, cw); 
        } 
    }
    let px = game.player.x / 40 * cw; let py = game.player.y / 40 * cw; minimapCtx.fillStyle = '#0af'; minimapCtx.beginPath(); minimapCtx.arc(px,py,3,0,Math.PI*2); minimapCtx.fill();
    game.entities.forEach(e => { 
        if (e.hidden) return;
        let ex = Math.floor(e.x/40), ey = Math.floor(e.y/40);
        if(!e.dead && game.visited[ey] && game.visited[ey][ex]) { 
            let dcx = e.x / 40 * cw; let dcy = e.y / 40 * cw; 
            if(e.isEnemy && !e.charmed) { minimapCtx.fillStyle = '#f00'; if(e.isBoss) { minimapCtx.fillStyle = '#a0f'; minimapCtx.beginPath(); minimapCtx.arc(dcx,dcy,4,0,Math.PI*2); minimapCtx.fill(); } else minimapCtx.fillRect(dcx-1, dcy-1, 2, 2); } 
            else if(e.type === 'CHEST') { minimapCtx.fillStyle = '#fd0'; minimapCtx.fillRect(dcx-1, dcy-1, 3, 3); } 
            else if(e.type === 'MINION' || e.charmed) { minimapCtx.fillStyle = '#0ff'; minimapCtx.fillRect(dcx-1, dcy-1, 2, 2); }
            else if(e.type === 'PORTAL_TOWN' || e.type === 'PORTAL_DUNGEON') { minimapCtx.fillStyle = '#0ff'; minimapCtx.beginPath(); minimapCtx.arc(dcx,dcy,3,0,Math.PI*2); minimapCtx.fill(); }
        } 
    });
}

function getTargetAt(x,y){ 
    let tx = Math.floor(x/40); let ty = Math.floor(y/40);
    if (tx<0||tx>=60||ty<0||ty>=60) return null;
    if(game.floor > 0 && (!game.visibleTiles[ty] || !game.visibleTiles[ty][tx])) return null;
    let e = game.entities.find(e => !e.dead && !e.hidden && e.isEnemy && Math.hypot(e.x - x, e.y - y) < 40);
    if (e) return e;
    e = game.entities.find(e => !e.dead && !e.hidden && !e.isEnemy && e.type !== 'MINION' && !e.charmed && Math.hypot(e.x - x, e.y - y) < 40);
    if (e) return e;
    let i = game.items.find(i => Math.hypot(i.x - x, i.y - y) < 40);
    return i;
}

function handleDropToInventory(e) { e.preventDefault(); if(!game.shopOpen) return; const shopIdx = e.dataTransfer.getData('shopIdx'); if(shopIdx && shopIdx !== "") { let it = game.shopItems[shopIdx]; if(game.player.gold >= it.price && game.player.inv.length < 40){ game.player.gold -= it.price; game.player.inv.push(JSON.parse(JSON.stringify(it))); game.uiDirty=true; AudioSys.sfx('coin'); } else { alert('金幣不足或背包已滿'); } } }
function handleDropToEquip(e, slot) { e.preventDefault(); const idx = e.dataTransfer.getData('idx'); if (idx === "") return; const it = game.player.inv[idx]; if (it) { game.player.equipItem(it, idx, slot); } }
function buyItem(idx) { let it = game.shopItems[idx]; if(game.player.gold >= it.price && game.player.inv.length < 40){ game.player.gold -= it.price; game.player.inv.push(JSON.parse(JSON.stringify(it))); game.uiDirty=true; AudioSys.sfx('coin'); } else { alert('金幣不足或背包已滿'); } }
function handleShopDragStart(e, idx) { e.dataTransfer.setData('shopIdx', idx); e.dataTransfer.effectAllowed = "copy"; }
function killEnemy(e){ 
    e.dead=true; AudioSys.sfx('die'); 
    let xpReq = 100 * Math.pow(2.0, game.player.lvl-1); 
    let levelDiff = Math.max(0, game.player.lvl - e.lvl);
    let xpMult = Math.max(0.1, 1.0 - levelDiff * 0.2);
    let xpGain = (30 + (e.maxHp/3)) * xpMult;
    game.player.xp += xpGain; 
    spawnText(e.x, e.y, "+"+Math.floor(xpGain)+" XP", "#0af"); 
    if(game.player.xp >= xpReq){ game.player.lvl++; game.player.xp=0; game.player.pts+=5; game.player.hp = game.player.maxHp; game.player.mp = game.player.maxMp; game.player.recalc(); AudioSys.sfx('level'); spawnText(game.player.x, game.player.y, "升級!", "#fd0"); } 
    game.items.push({x:e.x,y:e.y,type:'GOLD',val:randInt(15,40), isItem:true}); 
    if(e.isElite) { game.items.push(new ItemClass(game.floor, e.x, e.y, true)); spawnText(e.x, e.y - 20, "菁英掉落!", "#d0f"); } else if(Math.random()<0.30 || e.isBoss) { game.items.push(new ItemClass(game.floor,e.x,e.y)); }
    if(e.isBoss) { spawnText(e.x, e.y, "BOSS 擊殺！", "#f0f"); let bx = Math.floor(e.x/40), by = Math.floor(e.y/40); game.map[by][bx] = 2; } 
    game.uiDirty = true; 
}
function openChest(e) { if(e.dead) return; e.dead = true; e.icon = '📭'; if (e.trapped) { let dmg = 50 + game.floor * 10; game.player.hp -= dmg; spawnText(game.player.x, game.player.y, `爆炸! -${dmg}`, "red"); AudioSys.sfx('hit'); game.projs.push({x:e.x, y:e.y, vx:0, vy:0, life:0.5, dmg:0, isStatic:true, icon:'💥'}); } else { AudioSys.sfx('coin'); spawnText(e.x, e.y, "開啟寶箱!", "#fd0"); } game.items.push({x:e.x,y:e.y,type:'GOLD',val:randInt(50,150), isItem:true}); game.items.push(new ItemClass(game.floor,e.x,e.y)); game.items.push(new ItemClass(game.floor,e.x+10,e.y)); }
function pickup(it){ if(it.type==='GOLD') { game.player.gold+=it.val; } else { if(game.player.inv.length >= 40) { spawnText(game.player.x, game.player.y, "背包已滿!", "#f55"); return; } game.player.inv.push(it); } AudioSys.sfx('coin'); game.items=game.items.filter(x=>x!==it); game.uiDirty=true; }
function attack(e){ 
    if(game.player.atkCd > 0) return; 
    let p=game.player; 
    let mainHand = p.equip.mainhand; let offHand = p.equip.offhand;
    let dist = Math.hypot(e.x - p.x, e.y - p.y);
    let weapon = mainHand; let useDagger = false;
    if (mainHand && (mainHand.type === 'BOW' || mainHand.type === 'CROSSBOW')) {
        if (dist < 60) { if (offHand && offHand.type === 'DAGGER') { useDagger = true; weapon = offHand; } else { spawnText(p.x, p.y-30, "太近了(需匕首)", "#aaa"); return; } }
    }
    let isRanged = mainHand && (mainHand.type === 'BOW' || mainHand.type === 'CROSSBOW') && !useDagger;
    if(isRanged) AudioSys.sfx('step'); else AudioSys.sfx('hit');
    let speed = weapon ? (ITEM_TYPES[weapon.type].speed || 0.5) : 0.4;
    p.atkCd = speed; p.attackAnimTimer = 0.2; 
    for(let key in p.equip) { if(p.equip[key] && p.equip[key].effects) { p.equip[key].effects.forEach(eff => { if(Math.random() < eff.chance) { if(eff.type === '緩速') { e.slowTimer = 3.0; spawnText(e.x, e.y-40, "緩速!", "#0af"); } if(eff.type === '暈眩') { e.atkCd += 2.0; spawnText(e.x, e.y-40, "暈眩!", "#ff0"); } if(eff.type === '中毒') { e.poisonTimer = 5.0; e.poisonDmg = eff.val; spawnText(e.x, e.y, "中毒!", "#0f0"); } if(eff.type === '燃燒') { e.hp -= eff.val; spawnText(e.x, e.y, "燃燒!", "#f60"); } } }); } }
    if(isRanged) { let ang = Math.atan2(e.y - p.y, e.x - p.x); game.projs.push({x:p.x, y:p.y, vx:Math.cos(ang)*400, vy:Math.sin(ang)*400, life:1.5, dmg:p.stats.atk, isArrow:true}); } 
    else if(e) { 
        let dmg = p.stats.atk;
        if (useDagger) { let rangedAtk = (mainHand && mainHand.stats.atk) || 0; let daggerAtk = (offHand && offHand.stats.atk) || 0; dmg = Math.max(1, p.stats.atk - rangedAtk + Math.floor(daggerAtk * 0.5)); }
        if(Math.random() < p.critChance) { dmg *= 2; spawnText(e.x, e.y-40, "爆擊!", "#ff0"); }
        if(!e.isBoss && Math.random() < p.killChance) { dmg = 9999; spawnText(e.x, e.y-50, "必殺!", "#f00"); }
        e.hp -= dmg; spawnText(e.x, e.y-20, Math.floor(dmg), "#fff"); if(e.hp<=0) killEnemy(e); 
    } 
}
function handleDropToWorld(e) { const idx=e.dataTransfer.getData('idx'); if(idx==="")return; const it=game.player.inv[idx]; game.items.push({...it,x:game.player.x,y:game.player.y}); game.player.inv.splice(idx,1); game.uiDirty=true; }
function handleDropToShop(e) { e.preventDefault(); if(!game.shopOpen) return; const idx = e.dataTransfer.getData('idx'); if(idx==="")return; const it=game.player.inv[idx]; if(it) { game.player.gold += Math.floor(it.price/2); game.player.inv.splice(idx,1); game.uiDirty=true; AudioSys.sfx('coin'); } }
function handleDropToHotbar(e, type) { e.preventDefault(); const idx = e.dataTransfer.getData('idx'); if (idx === "") return; const it = game.player.inv[idx]; let valid = false; if (type === 'HP' && it.type === 'POTION') valid = true; if (type === 'MP' && it.type === 'MANA_POTION') valid = true; if (type === 'TP' && it.type === 'SCROLL_TP') valid = true; if (valid) { game.player.potions[type]++; game.player.inv.splice(idx, 1); game.uiDirty = true; AudioSys.sfx('coin'); } else { alert("物品類型不符！"); } }
function unequip(s){ let p=game.player; if(p.equip[s] && p.inv.length < 40){ p.inv.push(p.equip[s]); p.equip[s]=null; p.recalc(); game.uiDirty=true; } }
function addStat(s){ if(game.player.pts>0){ game.player.baseStats[s]++; game.player.pts--; game.player.recalc(); game.uiDirty=true; } }
function toggleInventory(){ let w=document.getElementById('inventory-window'); w.style.display=w.style.display==='flex'?'none':'flex'; game.uiDirty=true; if(w.style.display==='none') document.getElementById('tooltip').style.display='none'; }
function openShop(t){ game.shopOpen=t; document.getElementById('shop-window').style.display='flex'; let s=document.getElementById('shop-items'); s.innerHTML=''; game.shopItems = []; for(let i=0;i<6;i++){ let it=new ItemClass(game.player.lvl,0,0); game.shopItems.push(it); let d=document.createElement('div'); d.className='shop-item'; d.draggable=true; d.ondragstart=(e)=>handleShopDragStart(e, i); d.ondblclick=()=>buyItem(i); d.onmouseenter=(e)=>showTip(it,e); d.onmouseleave=hideTip; d.innerHTML=`<span style="color:${it.rarity.col}">${ITEM_TYPES[it.type].icon} ${it.name}</span><span>${it.price} G</span>`; s.appendChild(d); } }
function closeShop(){ game.shopOpen=null; document.getElementById('shop-window').style.display='none'; document.getElementById('tooltip').style.display='none'; }
function updateUI() { const p=game.player; if(!p)return; document.getElementById('hp-fill').style.height=(Math.max(0, p.hp)/p.maxHp*100)+'%'; document.getElementById('hp-text').innerText=Math.floor(Math.max(0, p.hp)); document.getElementById('mp-fill').style.height=(Math.max(0, p.mp)/p.maxMp*100)+'%'; document.getElementById('mp-text').innerText=Math.floor(Math.max(0, p.mp)); document.getElementById('xp-bar-fill').style.width=(Math.min(100, (p.xp / (100 * Math.pow(2.0, p.lvl-1))) * 100))+'%'; document.getElementById('ui-level').innerText=p.lvl; ['HP','MP','TP'].forEach(k=>document.getElementById('qty-'+k).innerText=p.potions[k]); if(p.activeSpell) document.getElementById('active-spell-icon').innerText = SPELLS[p.activeSpell].icon; else document.getElementById('active-spell-icon').innerText = "🚫"; if(game.uiDirty) updateInventoryUI(); }
function updateInventoryUI() { const p=game.player; const g=document.getElementById('inventory-grid'); g.innerHTML=''; p.inv.forEach((it,i)=>{ const el=document.createElement('div'); el.className='inv-slot'; el.style.borderColor=it.rarity.col; el.innerText=it.type==='SPELL_BOOK'?'📘':ITEM_TYPES[it.type].icon; el.draggable=true; el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; el.ondragstart=(e)=>e.dataTransfer.setData('idx',i); el.ondblclick=()=>p.equipItem(it,i); g.appendChild(el); }); ['str','dex','mag','vit'].forEach(k=>{ document.getElementById('stat-'+k).innerText=p.stats[k]; document.getElementById('plus-'+k).style.display=p.pts>0?'inline-block':'none'; }); document.getElementById('stat-hpregen').innerText = p.regenInfo ? p.regenInfo.hp.toFixed(1) : 0; document.getElementById('stat-mpregen').innerText = p.regenInfo ? p.regenInfo.mp.toFixed(1) : 0; document.getElementById('stat-points').innerText=p.pts; document.getElementById('stat-atk').innerText=p.stats.atk; document.getElementById('stat-def').innerText=p.stats.def; document.getElementById('stat-crit').innerText=Math.floor(p.critChance*100); document.getElementById('stat-kill').innerText=(p.killChance*100).toFixed(1); document.getElementById('ui-gold-inv').innerText=p.gold; document.getElementById('inv-count').innerText=p.inv.length; for(let k in p.equip){ let el=document.getElementById('slot-'+k), it=p.equip[k]; if(it){el.innerText=ITEM_TYPES[it.type].icon;el.style.borderColor=it.rarity.col;el.classList.add('equipped'); el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; } else {el.innerText='';el.style.borderColor='#444';el.classList.remove('equipped'); el.onmouseenter=null;} } game.uiDirty=false; }
function updateSpellIcon() { game.uiDirty = true; }
function showTip(it,e){ let t=document.getElementById('tooltip'); t.style.display='block'; let left = e.clientX + 15; if (left + 240 > window.innerWidth) left = e.clientX - 250; t.style.left=left+'px'; t.style.top=(e.clientY+15)+'px'; document.getElementById('tip-title').innerText=it.name; document.getElementById('tip-title').style.color=it.rarity.col; let statsText = ''; if(it.type === 'SPELL_BOOK') statsText = '點擊兩下以學習/升級'; else { statsText = `等級: ${it.lvl}\n售價: ${it.price}G\n`; if(it.stats.atk) statsText += `攻擊: +${it.stats.atk}\n`; if(it.stats.def) statsText += `防禦: +${it.stats.def}\n`; if(it.stats.mag) statsText += `魔力: +${it.stats.mag}\n`; if(it.stats.str) statsText += `力量: +${it.stats.str}\n`; if(it.stats.vit) statsText += `體質: +${it.stats.vit}\n`; if(it.effects && it.effects.length > 0) { statsText += `\n[特效]:\n`; it.effects.forEach(ef => { statsText += `- ${ef.type} (${Math.floor(ef.chance*100)}%)\n`; }); } } document.getElementById('tip-body').innerText=statsText; }
function hideTip(){ document.getElementById('tooltip').style.display='none'; }
function useQuickSlot(k){ if(game.player.potions[k]>0){ if(k==='HP') game.player.hp=Math.min(game.player.maxHp, game.player.hp+50); if(k==='MP') game.player.mp=Math.min(game.player.maxMp, game.player.mp+50); if(k==='TP'){ useTownPortal(false); } game.player.potions[k]--; game.uiDirty=true; AudioSys.sfx('coin'); } }
function toggleSpellMenu(){ let m=document.getElementById('spell-menu'); if(m.style.display === 'grid') { m.style.display = 'none'; } else { m.style.display = 'grid'; m.innerHTML=''; let keys = Object.keys(game.player.spells); if(keys.length === 0) { let d=document.createElement('div'); d.innerText="無"; d.style.color="#fff"; m.appendChild(d); } keys.forEach(k=>{ let d=document.createElement('div'); d.className='spell-option'; d.innerText=SPELLS[k].icon; let lv = game.player.spells[k]; let span = document.createElement('span'); span.style.fontSize='10px'; span.innerText=`${lv}`; d.appendChild(span); d.onclick=(e)=>{ e.stopPropagation(); game.player.activeSpell=k; m.style.display='none'; game.uiDirty = true; }; m.appendChild(d); }); } }
function castSpell(){ 
    let p=game.player; if(!p.activeSpell)return; let s=SPELLS[p.activeSpell]; 
    let lvl = p.spells[p.activeSpell]; let cost = s.cost + (lvl-1)*2; 
    if(p.mp>=cost){ 
        p.mp-=cost; AudioSys.sfx('magic'); p.atkCd=s.cd; let a=Math.atan2(mouse.wy-p.y,mouse.wx-p.x); 
        let power = p.stats.mag * 0.5 + (lvl-1) * 5; 
        if (s.name === '治癒術') { p.hp = Math.min(p.maxHp, p.hp + p.maxHp * 0.3 + p.stats.mag * 5 + lvl * 10); spawnText(p.x, p.y, "治療", "#0f0"); } 
        else if (s.name === '迷惑術') { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*300,vy:Math.sin(a)*300,life:1.8,dmg:0, effect:'confused'}); }
        else if (s.name === '魅惑術') { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*300,vy:Math.sin(a)*300,life:1.8,dmg:0, effect:'charmed'}); }
        else if (s.name === '電網') { for(let i=-1; i<=1; i++) { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a+i*0.3)*300,vy:Math.sin(a+i*0.3)*300,life:1.0,dmg:s.dmg+power}); } } 
        else if (s.name === '火牆') { game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:8.0, dmg:(s.dmg+power)*0.5, isStatic:true}); } 
        else if (s.name === '隕石術') { game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:99, delay: 1.0, dmg:s.dmg+power*2}); } 
        else if (s.name === '召喚術') { 
            let typeName = '骷髏戰士', typeIcon = '💀', hp = 40, life = 30;
            if(lvl >= 2) { typeName = '骷髏射手'; typeIcon = '🏹💀'; }
            if(lvl >= 3) { typeName = '血肉魔像'; typeIcon = '🧟'; hp = 100; life = 40; }
            if(lvl >= 4) { typeName = '火元素'; typeIcon = '🔥'; hp = 60; life = 20; }
            if(lvl >= 5) { typeName = '巫妖'; typeIcon = '🧙💀'; hp = 80; life = 50; }
            game.entities.push({x:p.x+20, y:p.y, type:'MINION', hp:hp+p.stats.mag*5+lvl*10, life:life, icon:typeIcon, name:typeName, dead:false, lvl: lvl}); 
            spawnText(p.x, p.y, "召喚!", "#aaa"); 
        } 
        else { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*380,vy:Math.sin(a)*380,life:1.8,dmg:s.dmg+power, isIce: s.name==='冰箭術'}); } 
    } else { spawnText(p.x, p.y, "魔力不足!", "#00f"); } 
}

function handlePlayerDeath() {
    game.dead = true;
    document.getElementById('death-screen').style.display = 'flex';
    AudioSys.sfx('die');
}

function resurrect(type) {
    let p = game.player;
    if (type === 'town') {
        p.inv = [];
        p.equip = { helm:null, necklace:null, earring1:null, earring2:null, armor:null, mainhand:null, offhand:null, ring1:null, ring2:null, pants:null, boots:null };
        p.hp = p.maxHp;
        p.mp = p.maxMp;
        p.recalc();
        game.dungeonCache = null; 
        game.floor = 0;
        genFloor(0); 
        p.x = 30*40+20; p.y = 30*40+20; 
    } 
    game.dead = false;
    document.getElementById('death-screen').style.display = 'none';
    game.uiDirty = true;
}
function showMainMenu(){ document.getElementById('char-create').style.display='none'; document.getElementById('main-menu').style.display='block'; document.getElementById('start-screen').style.display='flex'; document.getElementById('death-screen').style.display='none'; game.dead=false; game.running=false; }
function showCharCreate(){ document.getElementById('main-menu').style.display='none'; document.getElementById('char-create').style.display='flex'; }
function saveGame(){ if(!game.player) return; const saveObj = { stats: game.player.stats, baseStats: game.player.baseStats, lvl: game.player.lvl, xp: game.player.xp, raceKey: game.player.raceKey, gold: game.player.gold, floor: game.floor, inv: game.player.inv, equip: game.player.equip, spells: game.player.spells }; localStorage.setItem('inf_save_v7', JSON.stringify(saveObj)); alert('遊戲已存檔'); }
function tryLoadGame(){ let d=JSON.parse(localStorage.getItem('inf_save_v7')); if(!d) return alert('無存檔紀錄'); selRace=d.raceKey; startGame(); game.player.lvl = d.lvl; game.player.xp = d.xp; game.player.gold = d.gold; game.player.baseStats = d.baseStats; game.player.inv = d.inv || []; game.player.equip = d.equip || {}; game.player.spells = d.spells || {}; const sKeys = Object.keys(game.player.spells); game.player.activeSpell = sKeys.length > 0 ? sKeys[0] : null; game.floor = d.floor; genFloor(d.floor); game.player.recalc(); game.uiDirty = true; }
function selectRace(k,b){ selRace=k; document.querySelectorAll('.race-btn').forEach(btn=>btn.classList.remove('selected')); if(b) b.classList.add('selected'); let r=RACES[k]; document.getElementById('preview-race').innerText=r.name; document.getElementById('preview-desc').innerText=r.desc; ['str','dex','mag','vit'].forEach(s=>document.getElementById('bar-'+s).style.width=(r.stats[s]*10)+'%'); }
function spawnText(x,y,t,c){ let e=document.createElement('div'); e.className='floating-text'; e.innerText=t; e.style.color=c; e.style.left=(x-game.cam.x+gameCanvas.width/2)+'px'; e.style.top=(y-game.cam.y+gameCanvas.height/2)+'px'; document.getElementById('floating-text-container').appendChild(e); setTimeout(()=>e.remove(),1000); }
function startGame() { AudioSys.init(); document.getElementById('btn-music').innerText = "🔊 音樂"; game.player=new PlayerClass(selRace); game.floor = 0; genFloor(0); game.cam.x=game.player.x; game.cam.y=game.player.y; game.running=true; game.uiDirty = true; document.getElementById('start-screen').style.display='none'; }
function init() { 
    gameCanvas = document.getElementById('gameCanvas'); gameCtx = gameCanvas.getContext('2d'); minimapCanvas = document.getElementById('minimap'); minimapCtx = minimapCanvas.getContext('2d'); const rl = document.getElementById('race-list'); rl.innerHTML = ''; Object.keys(RACES).forEach(k=>{ const b = document.createElement('button'); b.className = 'race-btn'; b.innerText = RACES[k].name; b.onclick = () => selectRace(k, b); rl.appendChild(b); }); selectRace('HUMAN', rl.firstChild); window.addEventListener('resize', ()=>{ gameCanvas.width=window.innerWidth; gameCanvas.height=window.innerHeight-140; }); window.dispatchEvent(new Event('resize')); gameCanvas.addEventListener('mousemove', e => { mouse.wx = e.clientX - gameCanvas.width/2 + game.cam.x; mouse.wy = e.clientY - gameCanvas.height/2 + game.cam.y; }); window.addEventListener('keydown', e => { if(!game.running) return; if(e.key === '1') useQuickSlot('HP'); if(e.key === '2') useQuickSlot('MP'); if(e.key === '3') useQuickSlot('TP'); if(e.key === 'i' || e.key === 'I') toggleInventory(); });
    gameCanvas.addEventListener('mousedown', e=>{ 
        if(!game.running) return; const wx=e.clientX-gameCanvas.width/2+game.cam.x; const wy=e.clientY-gameCanvas.height/2+game.cam.y; mouse.wx = wx; mouse.wy = wy; 
        if(e.button===0){ 
            let tx=Math.floor(wx/40), ty=Math.floor(wy/40);
            if (game.map[ty] && (game.map[ty][tx] === 2 || game.map[ty][tx] === 6)) {
                if (Math.hypot(game.player.x - (tx*40+20), game.player.y - (ty*40+20)) < 60) {
                    if (game.map[ty][tx] === 2) { game.floor++; genFloor(game.floor); game.cam.x=game.player.x; game.cam.y=game.player.y; game.player.path=[]; return; }
                    if (game.map[ty][tx] === 6 && game.floor > 0) { game.floor--; genFloor(game.floor); game.cam.x=game.player.x; game.cam.y=game.player.y; game.player.path=[]; return; }
                } else { spawnText(game.player.x, game.player.y, "太遠了", "#aaa"); }
            }
            let t=getTargetAt(wx,wy); 
            if(t) { game.player.targetEntity = t; if(t.isEnemy) game.player.attackRequested = true; game.player.path = []; } 
            else { game.player.targetEntity=null; game.player.path=findPath(game.player.x,game.player.y,wx,wy); } 
        } 
        if(e.button===2) { e.preventDefault(); castSpell(); } 
    }); 
    gameCanvas.addEventListener('contextmenu', event => event.preventDefault()); const joy=document.getElementById('joystick-container'); joy.addEventListener('touchstart',e=>{ joystick.active=true; let t=e.touches[0]; joystick.startX=t.clientX; joystick.startY=t.clientY; }); window.addEventListener('touchmove',e=>{ if(!joystick.active)return; let t=e.touches[0]; let dx=t.clientX-joystick.startX,dy=t.clientY-joystick.startY; let d=Math.min(50,Math.sqrt(dx*dx+dy*dy)); let a=Math.atan2(dy,dx); joystick.vector={x:Math.cos(a)*(d/50),y:Math.sin(a)*(d/50)}; document.getElementById('joystick-knob').style.left=(50+Math.cos(a)*50*(d/50))+'%'; document.getElementById('joystick-knob').style.top=(50+Math.sin(a)*50*(d/50))+'%'; }); window.addEventListener('touchend',()=>{ joystick.active=false; joystick.vector={x:0,y:0}; document.getElementById('joystick-knob').style.left='50%'; document.getElementById('joystick-knob').style.top='50%'; if(game.player) { game.player.path = []; game.player.targetEntity = null; } }); if('ontouchstart' in window) joy.style.display='block'; setInterval(update, 16); requestAnimationFrame(function tick(){ draw(); requestAnimationFrame(tick); }); 
}
</script>
</body>
</html>