
<head>
    <meta charset="UTF-8">
    <!-- 加入 minimal-ui 和 standalone 模式以優化手機顯示 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>無盡之淵 - Infinite Dungeon (Mobile v23 Guide)</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        body {
            margin: 0; overflow: hidden; background-color: #000; color: #dcdcdc;
            font-family: 'Noto Serif TC', serif; user-select: none; -webkit-user-select: none;
            display: flex; flex-direction: column; 
            /* 使用 dvh 以適應移動瀏覽器網址列 */
            height: 100vh; height: 100dvh; 
        }

        #game-viewport { position: relative; flex-grow: 1; overflow: hidden; cursor: crosshair; background: #050505; }
        
        #ui-panel {
            height: 140px; background: #111; border-top: 4px solid #333;
            display: flex; justify-content: center; align-items: center;
            padding: 5px 20px; box-sizing: border-box; z-index: 20;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.9);
            position: relative;
            flex-shrink: 0; /* 防止 UI 被壓縮 */
        }

        canvas { display: block; }

        .globe-wrapper { position: relative; width: 90px; height: 90px; margin: 0 10px; flex-shrink: 0; }
        .globe-container {
            width: 100%; height: 100%; background: #000; border-radius: 50%; border: 3px solid #555;
            box-shadow: inset 0 0 20px #000; overflow: hidden; position: relative;
        }
        .globe-liquid { position: absolute; bottom: 0; left: 0; width: 100%; transition: height 0.3s ease-out; }
        .globe-glass {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3) 0%, transparent 20%, rgba(0,0,0,0.4) 80%);
            border-radius: 50%; pointer-events: none;
        }
        #hp-globe .globe-liquid { background: linear-gradient(to top, #700, #f00); box-shadow: 0 0 15px #f00 inset; }
        #mp-globe .globe-liquid { background: linear-gradient(to top, #007, #0af); box-shadow: 0 0 15px #00f inset; }
        .globe-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-weight: bold; font-size: 16px; text-shadow: 1px 1px 2px #000; color: #fff; z-index: 5;
        }
        
        #spell-btn {
            width: 60px; height: 60px; background: #111; border: 2px solid #00aaff; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; font-size: 30px; cursor: pointer;
            box-shadow: 0 0 15px #00aaff; position: absolute; left: -80px; bottom: 10px;
            z-index: 10;
        }
        #active-spell-icon { font-size: 28px; }

        #center-controls { flex-grow: 1; max-width: 800px; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px; }
        #xp-bar-container { width: 100%; height: 6px; background: #222; border: 1px solid #555; border-radius: 4px; overflow: hidden; }
        #xp-bar-fill { height: 100%; background: #a3f; width: 0%; transition: width 0.2s; }

        .hotbar { display: flex; gap: 8px; margin: 5px 0; align-items: center; background: #000; padding: 5px; border-radius: 8px; border: 1px solid #333; }
        .hotkey-slot {
            width: 42px; height: 42px; background: #1a1a1a; border: 2px solid #444; border-radius: 4px;
            position: relative; cursor: pointer; display: flex; justify-content: center; align-items: center;
            font-size: 22px; transition: 0.1s;
        }
        .hotkey-slot:hover { border-color: #d4af37; background: #222; }
        .hotkey-slot.active-spell { border-color: #0af; box-shadow: 0 0 10px #0af; }
        .key-label { position: absolute; top: -6px; left: -6px; background: #333; color: #fff; font-size: 10px; padding: 1px 4px; border-radius: 4px; border: 1px solid #555; z-index: 2; }
        .qty-label { position: absolute; bottom: 1px; right: 2px; color: #fff; font-size: 11px; font-weight: bold; text-shadow: 1px 1px 0 #000; z-index: 2; }
        .spell-lvl-label { position: absolute; top: 1px; right: 2px; color: #0ff; font-size: 10px; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        .hotbar-separator { width: 2px; height: 40px; background: #333; margin: 0 5px; }

        .system-btns { position: absolute; right: 20px; bottom: 20px; display: flex; flex-direction: column; gap: 8px; }

        .game-window {
            position: absolute; background: rgba(15, 15, 20, 0.98); border: 2px solid #555;
            box-shadow: 0 0 50px #000; display: none; flex-direction: column; pointer-events: auto; z-index: 200;
            max-height: 85vh; border-radius: 4px;
        }
        
        #inventory-window { width: 660px; height: 520px; top: 10%; right: 10%; left: auto; transform: none; display: none; }
        #stash-window { width: 500px; height: 500px; top: 15%; left: 15%; transform: none; display: none; }
        
        .inv-container { display: flex; flex-direction: row; flex-grow: 1; min-height: 0; overflow: hidden; }
        
        .stats-sidebar { 
            width: 140px; background: rgba(0,0,0,0.3); border-right: 1px solid #444; padding: 15px; 
            font-size: 13px; color: #aaa; flex-shrink: 0; overflow-y: auto;
        }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 6px; align-items: center; }
        .plus-btn { 
            color: #444; cursor: default; font-weight: bold; padding: 0 4px; border: 1px solid #333; border-radius: 3px; background: #111; user-select: none;
        }
        .plus-btn.active { color: #f00; cursor: pointer; border-color: #600; background: #200; }
        .plus-btn.active:hover { background: #400; color: #fff; }
        
        .paper-doll-container { 
            width: 200px; position: relative; background: radial-gradient(circle at center, #222 0%, #080808 80%); 
            border-right: 1px solid #444; flex-shrink: 0;
        }
        
        .inv-grid-container { 
            flex-grow: 1; padding: 10px; overflow-y: auto; 
            background-color: #0b0b0b;
            background-image: 
                linear-gradient(#1a1a1a 1px, transparent 1px),
                linear-gradient(90deg, #1a1a1a 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex; flex-direction: column;
        }
        .inventory-grid { 
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; 
            align-content: start; grid-auto-rows: min-content; min-height: 200px;
        }
        
        .doll-slot {
            width: 40px; height: 40px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 4px;
            position: absolute; display: flex; justify-content: center; align-items: center; font-size: 20px; color: #333; cursor: pointer;
        }
        .doll-slot.equipped { border-color: #d4af37; box-shadow: 0 0 10px rgba(212, 175, 55, 0.3); color: #fff; }
        .doll-label { position: absolute; font-size: 8px; color: #666; bottom: 0; width: 100%; text-align: center; pointer-events: none; }

        #slot-helm { top: 10px; left: 80px; }
        #slot-earring1 { top: 25px; left: 15px; width: 30px; height: 30px; }
        #slot-earring2 { top: 25px; left: 155px; width: 30px; height: 30px; }
        #slot-necklace { top: 60px; left: 140px; width: 32px; height: 32px; }
        #slot-armor { top: 65px; left: 80px; height: 60px; }
        #slot-mainhand { top: 100px; left: 10px; height: 90px; width: 45px; }
        #slot-offhand { top: 100px; left: 145px; height: 90px; width: 45px; }
        #slot-gloves { top: 150px; left: 15px; height: 40px; width: 40px; }
        #slot-pants { top: 140px; left: 80px; height: 50px; }
        #slot-boots { top: 205px; left: 80px; height: 40px; }
        #slot-ring1 { top: 205px; left: 25px; width: 30px; height: 30px; }
        #slot-ring2 { top: 205px; left: 145px; width: 30px; height: 30px; }

        .inv-slot { 
            width: 100%; aspect-ratio: 1; background: #151515; border: 1px solid #333; border-radius: 3px; 
            display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer; z-index: 2; position: relative; 
        }
        .inv-qty { position: absolute; bottom: 1px; right: 2px; font-size: 10px; color: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        #shop-window { width: 400px; height: 600px; top: 10%; left: 5%; right: auto; transform: none; display:none; flex-direction:column; }
        .shop-items { flex-grow: 1; overflow-y: auto; padding: 10px; min-height: 0; }
        .shop-item { background: #1a1a1a; border: 1px solid #333; padding: 10px; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; cursor: grab; border-radius: 4px; }
        .shop-item:hover { border-color: #d4af37; background: #252525; }
        .shop-item:active { cursor: grabbing; }
        
        .shop-sell-zone { 
            height: 80px; border-top: 2px solid #444; background: #151515; 
            display: flex; justify-content: center; align-items: center; 
            color: #666; font-size: 14px; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px;
            transition: 0.2s; text-align: center; padding: 10px;
            flex-shrink: 0;
        }
        .shop-sell-zone.drag-over { background: #221; color: #d4af37; border-color: #d4af37; }

        #spellbook-window { width: 460px; height: 500px; top: 15%; left: 15%; right: auto; }
        .spell-category { font-size: 14px; color: #aaa; margin: 10px 0 5px 0; padding-left: 5px; border-bottom: 1px solid #333; clear: both; width: 100%; grid-column: 1 / -1; }
        .spell-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; padding: 10px; overflow-y: auto; align-content: start; }
        .spell-icon { width: 100%; aspect-ratio: 1; border: 1px solid #444; background: #111; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 20px; cursor: pointer; position: relative; }
        .spell-icon:hover { border-color: #0af; background: #222; }
        .spell-icon .s-name { font-size: 9px; margin-top: 2px; text-align: center; width: 100%; overflow: hidden; white-space: nowrap; color: #ccc; }
        .spell-lvl { position: absolute; top: 1px; right: 2px; font-size: 9px; color: #0ff; }

        .window-header { background: #222; color: #d4af37; padding: 8px 12px; font-weight: bold; display: flex; justify-content: space-between; border-bottom: 2px solid #444; font-size: 16px; flex-shrink: 0; }
        .close-btn { cursor: pointer; color: #f55; font-size: 20px; }

        #joystick-container {
            position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px;
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1); border-radius: 50%; display: none; z-index: 50; touch-action: none;
        }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.2); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }

        #minimap-container {
            position: absolute; top: 10px; right: 10px; width: 150px; height: 150px;
            background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 4px; overflow: hidden; cursor: pointer; z-index: 50;
        }
        #minimap { display: block; width: 100%; height: 100%; }
        
        #dialogue-box {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            width: 600px; background: rgba(0,0,0,0.9); border: 2px solid #d4af37;
            padding: 20px; color: #fff; font-size: 18px; display: none; z-index: 250;
            border-radius: 8px; box-shadow: 0 0 20px #000;
        }
        #dialogue-name { color: #d4af37; font-weight: bold; margin-bottom: 10px; font-size: 20px; }
        #dialogue-text { line-height: 1.5; min-height: 60px; }
        #dialogue-close { position: absolute; top: 10px; right: 15px; cursor: pointer; color: #888; }

        #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.9); z-index: 9999;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #death-title { font-size: 80px; color: #f00; text-shadow: 0 0 20px #000; margin-bottom: 50px; font-family: 'serif'; }
        .death-btn {
            background: #111; border: 2px solid #555; color: #ddd;
            font-size: 24px; padding: 15px 40px; margin: 10px; cursor: pointer;
            transition: 0.2s; width: 350px;
        }
        .death-btn:hover { border-color: #f00; color: #fff; background: #300; }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; }
        .char-create-panel { background: #111; border: 2px solid #444; padding: 30px; width: 900px; display: flex; gap: 30px; border-radius: 8px; box-shadow: 0 0 100px rgba(0,0,0,0.8); max-height: 90vh; }
        .race-btn { padding: 12px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; width: 100%; margin-bottom: 8px; text-align: left; font-size: 18px; border-radius: 4px; transition: 0.2s; }
        .race-btn.selected { background: #500; color: #fff; border-color: #f00; box-shadow: 0 0 15px rgba(255,0,0,0.3); }
        .gender-select { display: flex; gap: 10px; margin-bottom: 20px; }
        .gender-btn { flex: 1; padding: 10px; background: #222; border: 1px solid #444; color: #888; cursor: pointer; text-align: center; border-radius: 4px; }
        .gender-btn.selected { background: #0055aa; color: #fff; border-color: #0af; }
        
        .stat-bar { background: #222; height: 8px; width: 100%; margin: 6px 0; border-radius: 2px; }
        .stat-fill { height: 100%; background: #d4af37; transition: width 0.3s; }
        .btn-back { position: absolute; top: 20px; left: 20px; background: #333; border: 1px solid #555; color: #aaa; padding: 10px 20px; cursor: pointer; font-size: 16px; border-radius: 4px; }
        .action-btn { background: #222; border: 1px solid #444; color: #dcdcdc; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-family: 'Noto Serif TC', serif; font-size: 14px; width: 100px; text-align: center; }
        .action-btn:hover { background: #333; border-color: #666; }

        .item-tooltip { position: absolute; background: rgba(10, 10, 15, 0.98); border: 1px solid #666; padding: 12px; pointer-events: none; display: none; z-index: 9999; width: 260px; box-shadow: 0 5px 20px #000; }
        .floating-text { position: absolute; font-weight: bold; pointer-events: none; animation: floatUp 1s forwards ease-out; text-shadow: 2px 2px 0 #000; font-family: sans-serif; font-size: 22px; z-index: 50; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-70px) scale(1.2); opacity: 0; } }
        
        @keyframes burning {
            0% { text-shadow: 0 0 10px #f00, 0 -5px 20px #d00, 0 -10px 30px #f40; }
            33% { text-shadow: 0 0 15px #f00, 0 -8px 25px #d00, 0 -12px 35px #f60; }
            66% { text-shadow: 0 0 12px #f00, 0 -6px 22px #d00, 0 -11px 32px #f80; }
            100% { text-shadow: 0 0 10px #f00, 0 -5px 20px #d00, 0 -10px 30px #f40; }
        }
        
        #cast-bar { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 12px; background: rgba(0,0,0,0.8); border: 1px solid #aaa; display: none; border-radius: 6px; overflow: hidden; }
        #cast-fill { height: 100%; background: #0af; width: 0%; }
        
        #monster-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-weight: bold; text-shadow: 2px 2px 4px #000;
            font-size: 20px; pointer-events: none; display: none; z-index: 150;
            background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 10px;
        }
        
        /* 更新指南 Modal 樣式 */
        #guide-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 700px; max-height: 80vh; background: #151515; border: 2px solid #d4af37;
            padding: 30px; z-index: 1000; display: none; overflow-y: auto; color: #ccc;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 8px;
        }
        #guide-modal h2 { color: #d4af37; border-bottom: 2px solid #444; padding-bottom: 10px; margin-top: 0; text-align: center; }
        .guide-content h3 { color: #d4af37; border-bottom: 1px solid #444; padding-bottom: 5px; margin-top: 20px; }
        .guide-content h4 { color: #eee; margin: 10px 0 5px 0; font-size: 16px; }
        .guide-content ul { padding-left: 20px; margin: 5px 0; }
        .guide-content li { margin-bottom: 3px; color: #aaa; font-size: 14px; line-height: 1.5; }
        .guide-content p { color: #aaa; font-size: 14px; margin: 5px 0; line-height: 1.5; }
        
        /* 指南表格樣式 */
        .guide-table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px; color: #ccc; }
        .guide-table th { text-align: left; border-bottom: 1px solid #d4af37; color: #d4af37; padding: 5px; background: rgba(212, 175, 55, 0.1); }
        .guide-table td { border-bottom: 1px solid #333; padding: 5px; }
        .guide-table tr:hover { background: rgba(255,255,255,0.05); }

        /* 新增：手機版戰鬥按鈕與全螢幕按鈕樣式 */
        .mobile-action-btn {
            position: absolute; width: 70px; height: 70px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            display: none; justify-content: center; align-items: center; font-size: 32px;
            z-index: 60; touch-action: none; user-select: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .mobile-action-btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        
        #btn-attack { bottom: 40px; right: 120px; color: #f55; border-color: #f55; }
        #btn-magic { bottom: 120px; right: 50px; color: #0af; border-color: #0af; }
        
        #btn-fullscreen {
            position: absolute; top: 10px; left: 10px; z-index: 1000;
            background: rgba(0,0,0,0.5); color: white; border: 1px solid #555;
            padding: 5px 10px; cursor: pointer; font-size: 14px; border-radius: 4px;
        }
    </style>
</head>
<body onload="init()">

<div id="game-viewport">
    <canvas id="gameCanvas" ondragover="event.preventDefault();" ondrop="handleDropToWorld(event)"></canvas>
    
    <!-- 新增全螢幕按鈕 -->
    <button id="btn-fullscreen" onclick="toggleFullScreen()">⛶ 全螢幕</button>

    <div id="floating-text-container" style="position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden;"></div>
    <div id="joystick-container"><div id="joystick-knob"></div></div>
    
    <!-- 新增手機版戰鬥按鈕 -->
    <div id="btn-attack" class="mobile-action-btn">⚔️</div>
    <div id="btn-magic" class="mobile-action-btn">✨</div>

    <div id="cast-bar"><div id="cast-fill"></div></div>
    <div id="minimap-container" title="點擊以移動"><canvas id="minimap" width="150" height="150"></canvas></div>
    <div id="monster-hud"></div>
    
    <div id="dialogue-box">
        <div id="dialogue-close" onclick="closeDialogue()">✕</div>
        <div id="dialogue-name">NPC Name</div>
        <div id="dialogue-text">Dialogue text goes here...</div>
    </div>

    <div id="inventory-window" class="game-window" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'inv', null)">
        <div class="window-header"><span>英雄裝備</span><span class="close-btn" onclick="toggleInventory()">✕</span></div>
        <div class="inv-container">
            <div class="stats-sidebar">
                <div style="margin-bottom:10px; color:#d4af37; font-weight:bold;">屬性點: <span id="stat-points">0</span></div>
                <div class="stat-row">力量 <span id="stat-str">0</span> <span id="plus-str" class="plus-btn" onclick="addStat('str')">[+]</span></div>
                <div class="stat-row">敏捷 <span id="stat-dex">0</span> <span id="plus-dex" class="plus-btn" onclick="addStat('dex')">[+]</span></div>
                <div class="stat-row">魔力 <span id="stat-mag">0</span> <span id="plus-mag" class="plus-btn" onclick="addStat('mag')">[+]</span></div>
                <div class="stat-row">體質 <span id="stat-vit">0</span> <span id="plus-vit" class="plus-btn" onclick="addStat('vit')">[+]</span></div>
                
                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                <div>攻擊力 <span id="stat-atk">0</span></div>
                <div>防禦力 <span id="stat-def">0</span></div>
                <div style="margin-top:5px; color:#888; font-size:11px;">爆擊率: <span id="stat-crit">0</span>%</div>
                <div style="color:#888; font-size:11px;">必殺率: <span id="stat-kill">0</span>%</div>
                <div style="color:#8af; font-size:11px;">格擋率: <span id="stat-block">0</span>%</div>
                <div style="color:#6d6; font-size:11px;">閃避率: <span id="stat-evade">0</span>%</div>
                <div style="margin-top:5px; color:#0f0;">HP回: <span id="stat-hpregen">0</span>/s</div>
                <div style="color:#0af;">MP回: <span id="stat-mpregen">0</span>/s</div>
                <div style="margin-top:10px; font-weight:bold; color:#ffd700;">💰 <span id="ui-gold-inv">0</span></div>
                <div style="margin-top:5px; font-size:12px; color:#888;">物品: <span id="inv-count">0</span>/40</div>
            </div>
            
            <div class="paper-doll-container">
                <div class="doll-slot" id="slot-helm" ondblclick="unequip('helm')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'helm')"><span class="doll-label">頭部</span></div>
                <div class="doll-slot" id="slot-necklace" ondblclick="unequip('necklace')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'necklace')"><span class="doll-label">項鍊</span></div>
                <div class="doll-slot" id="slot-earring1" ondblclick="unequip('earring1')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'earring1')"><span class="doll-label">耳</span></div>
                <div class="doll-slot" id="slot-earring2" ondblclick="unequip('earring2')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'earring2')"><span class="doll-label">耳</span></div>
                <div class="doll-slot" id="slot-armor" ondblclick="unequip('armor')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'armor')"><span class="doll-label">身體</span></div>
                <div class="doll-slot" id="slot-mainhand" ondblclick="unequip('mainhand')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'mainhand')"><span class="doll-label">右手</span></div>
                <div class="doll-slot" id="slot-offhand" ondblclick="unequip('offhand')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'offhand')"><span class="doll-label">左手</span></div>
                <div class="doll-slot" id="slot-ring1" ondblclick="unequip('ring1')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'ring1')"><span class="doll-label">戒</span></div>
                <div class="doll-slot" id="slot-ring2" ondblclick="unequip('ring2')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'ring2')"><span class="doll-label">戒</span></div>
                <div class="doll-slot" id="slot-pants" ondblclick="unequip('pants')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'pants')"><span class="doll-label">腿部</span></div>
                <div class="doll-slot" id="slot-boots" ondblclick="unequip('boots')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'boots')"><span class="doll-label">腳部</span></div>
                <div class="doll-slot" id="slot-gloves" ondblclick="unequip('gloves')" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'equip', 'gloves')"><span class="doll-label">手套</span></div>
            </div>

            <div class="inv-grid-container">
                <div class="inventory-grid" id="inventory-grid" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'inv', null)"></div>
            </div>
        </div>
    </div>

    <div id="stash-window" class="game-window" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'stash', null)">
        <div class="window-header"><span>個人儲藏室 (100格)</span><span class="close-btn" onclick="toggleStash()">✕</span></div>
        <div class="inv-grid-container" style="flex-grow:1; background:#181818;">
             <div class="inventory-grid" id="stash-grid"></div>
        </div>
        <div style="padding:10px; color:#888; text-align:center; font-size:12px; background:#111;">
            可與背包、裝備欄互相拖曳物品
        </div>
    </div>

    <div id="spellbook-window" class="game-window">
        <div class="window-header"><span>法術書</span><span class="close-btn" onclick="toggleSpellBook()">✕</span></div>
        <div style="padding:10px; color:#aaa; font-size:12px;">將法術拖曳至快捷列 5-8 以快速使用</div>
        <div class="spell-grid" id="spell-grid"></div>
    </div>

    <div id="shop-window" class="game-window" ondragover="event.preventDefault();" ondrop="handleDropUnified(event, 'shop', null)">
        <div class="window-header"><span id="shop-title">商店</span><span class="close-btn" onclick="closeShop()">✕</span></div>
        <div class="shop-items" id="shop-items"></div>
        <div class="shop-sell-zone" ondragover="this.classList.add('drag-over'); event.preventDefault();" ondragleave="this.classList.remove('drag-over');" ondrop="this.classList.remove('drag-over'); handleDropUnified(event, 'shop-sell', null)">
            拖曳物品至此出售
        </div>
    </div>
</div>

<div id="ui-panel">
    <div class="globe-wrapper">
        <div class="globe-container" id="hp-globe"><div class="globe-liquid" id="hp-fill"></div><div class="globe-glass"></div></div>
        <div class="globe-text" id="hp-text">100</div>
    </div>
    <div id="center-controls">
        <div style="width:100%; display:flex; justify-content:space-between; align-items:baseline;">
            <div id="level-info" style="font-size:18px; color:#d4af37; font-weight:bold;">營地</div>
            <div style="font-size:14px; color:#aaa;">Lv <span id="ui-level">1</span></div>
        </div>
        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
        
        <div class="hotbar">
            <!-- Items 1-4 -->
            <div class="hotkey-slot" ondrop="handleDropUnified(event, 'hotbar', 0)" ondragover="event.preventDefault()" onclick="useHotbar(0)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 0)"><div class="key-label">1</div><span id="hb-icon-0"></span><div class="qty-label" id="hb-qty-0"></div></div>
            <div class="hotkey-slot" ondrop="handleDropUnified(event, 'hotbar', 1)" ondragover="event.preventDefault()" onclick="useHotbar(1)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 1)"><div class="key-label">2</div><span id="hb-icon-1"></span><div class="qty-label" id="hb-qty-1"></div></div>
            <div class="hotkey-slot" ondrop="handleDropUnified(event, 'hotbar', 2)" ondragover="event.preventDefault()" onclick="useHotbar(2)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 2)"><div class="key-label">3</div><span id="hb-icon-2"></span><div class="qty-label" id="hb-qty-2"></div></div>
            <div class="hotkey-slot" ondrop="handleDropUnified(event, 'hotbar', 3)" ondragover="event.preventDefault()" onclick="useHotbar(3)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 3)"><div class="key-label">4</div><span id="hb-icon-3"></span><div class="qty-label" id="hb-qty-3"></div></div>
            
            <div class="hotbar-separator"></div>
            
            <!-- Spells 5-8 -->
            <div class="hotkey-slot" id="slot-spell-0" ondrop="handleDropUnified(event, 'hotbar', 4)" ondragover="event.preventDefault()" onclick="useHotbar(4)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 4)" onmouseenter="showSpellTip(4, event)" onmouseleave="hideTip()"><div class="key-label">5</div><span id="hb-icon-4"></span><div class="spell-lvl-label" id="hb-lvl-4"></div></div>
            <div class="hotkey-slot" id="slot-spell-1" ondrop="handleDropUnified(event, 'hotbar', 5)" ondragover="event.preventDefault()" onclick="useHotbar(5)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 5)" onmouseenter="showSpellTip(5, event)" onmouseleave="hideTip()"><div class="key-label">6</div><span id="hb-icon-5"></span><div class="spell-lvl-label" id="hb-lvl-5"></div></div>
            <div class="hotkey-slot" id="slot-spell-2" ondrop="handleDropUnified(event, 'hotbar', 6)" ondragover="event.preventDefault()" onclick="useHotbar(6)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 6)" onmouseenter="showSpellTip(6, event)" onmouseleave="hideTip()"><div class="key-label">7</div><span id="hb-icon-6"></span><div class="spell-lvl-label" id="hb-lvl-6"></div></div>
            <div class="hotkey-slot" id="slot-spell-3" ondrop="handleDropUnified(event, 'hotbar', 7)" ondragover="event.preventDefault()" onclick="useHotbar(7)" draggable="true" ondragstart="handleDragStart(event, 'hotbar', 7)" onmouseenter="showSpellTip(7, event)" onmouseleave="hideTip()"><div class="key-label">8</div><span id="hb-icon-7"></span><div class="spell-lvl-label" id="hb-lvl-7"></div></div>
        </div>
    </div>
    
    <div class="system-btns">
        <button class="action-btn" onclick="toggleInventory()">背包 (I)</button>
        <button class="action-btn" onclick="toggleSpellBook()">法術 (K)</button>
        <button class="action-btn" onclick="saveGame()">存檔</button>
        <button class="action-btn" onclick="toggleMusic()" id="btn-music">🔇 音樂</button>
    </div>

    <div class="globe-wrapper">
        <div class="globe-container" id="mp-globe"><div class="globe-liquid" id="mp-fill"></div><div class="globe-glass"></div></div>
        <div class="globe-text" id="mp-text">50</div>
        
        <div id="spell-btn" onclick="toggleSpellBook()" title="法術書 (K)">
            <span id="active-spell-icon">🚫</span>
        </div>
    </div>
</div>

<div class="item-tooltip" id="tooltip">
    <div id="tip-title" style="font-weight:bold; font-size:18px;"></div>
    <div id="tip-body" style="font-size:13px; margin-top:8px;"></div>
</div>

<div id="guide-modal">
    <h2>遊戲指南</h2>
    <button class="close-btn" style="position:absolute; top:20px; right:20px;" onclick="closeGuide()">✕</button>
    
    <div class="guide-content">
        <h3>📱 操作指南</h3>
        <h4>1. 電腦版 (PC/Mac)</h4>
        <ul>
            <li><b>移動：</b>點擊地面 (左鍵)</li>
            <li><b>攻擊：</b>滑鼠移至怪物變劍 (⚔️) 時點擊左鍵</li>
            <li><b>施法：</b>右鍵點擊目標方向</li>
            <li><b>快捷鍵：</b>1-4 物品, 5-8 法術, I 背包, K 法術書</li>
        </ul>
        <h4>2. 行動版 (手機/平板)</h4>
        <ul>
            <li><b>移動：</b>左下角隱形搖桿拖曳，或點擊小地圖</li>
            <li><b>攻擊：</b>右下角 ⚔️ 按鈕 (自動鎖定)</li>
            <li><b>施法：</b>右下角 ✨ 按鈕 (自動瞄準)</li>
            <li><b>全螢幕：</b>點擊左上角 [⛶ 全螢幕]</li>
        </ul>

        <h3>🧙‍♂️ 種族特性</h3>
        <table class="guide-table">
            <tr><th>種族</th><th>特色</th><th>初始法術</th></tr>
            <tr><td>人類</td><td>均衡</td><td>火球術</td></tr>
            <tr><td>精靈</td><td>高爆擊</td><td>火球術、急速</td></tr>
            <tr><td>矮人</td><td>高格擋</td><td>石化皮膚</td></tr>
            <tr><td>獸人</td><td>高必殺</td><td>力量強化</td></tr>
            <tr><td>亡靈</td><td>高魔力</td><td>火球術、電網</td></tr>
        </table>

        <h3>⚔️ 武器與戰鬥</h3>
        <ul>
            <li><b>單手劍/斧：</b>攻速快，可持盾。</li>
            <li><b>雙手武/長槍：</b>高傷害，無法持副手。</li>
            <li><b>弓/十字弓：</b>遠程。貼身時自動切換副手匕首。</li>
            <li><b>盾牌：</b>提供格擋率 (完全抵擋傷害)。</li>
        </ul>

        <h3>✨ 法術系別</h3>
        <ul>
            <li><b>🔥 攻擊系：</b>火球、冰箭(緩速)、毒鏢(中毒)、電網。</li>
            <li><b>💖 回復系：</b>治癒術、再生術、淨化、神聖之光。</li>
            <li><b>🛡️ 強化系：</b>石化皮膚(防)、急速(速)、隱形。</li>
            <li><b>💀 召喚系：</b>召喚骷髏/魔像、魅惑術(控制敵人)。</li>
        </ul>

        <h3>🎒 裝備與系統</h3>
        <p><b>稀有度：</b><span style="color:#fff">白</span> > <span style="color:#999">灰</span> > <span style="color:#0f0">綠</span> > <span style="color:#00f">藍</span> > <span style="color:#ff0">黃</span> > <span style="color:#f00">紅</span> > <span style="color:#ffd700">金</span> > <span style="color:#f0f">紫</span> > <span style="color:#000; text-shadow:0 0 2px #fff">黑</span></p>
        <p><b>死亡懲罰：</b></p>
        <ul>
            <li><b>最近安全區：</b>需摸過靈魂水晶。讀取存檔。</li>
            <li><b>靈魂轉生：</b>回城鎮，保留等級與倉庫，掉落全身裝備。</li>
        </ul>
    </div>
</div>

<div id="start-screen">
    <h1 style="font-size: 100px; color: #8b0000; letter-spacing: 15px; margin-bottom: 40px; font-family:'serif'; text-align: center; animation: burning 2s infinite alternate;">無盡之淵<br><span style="font-size: 40px; letter-spacing: 5px;">Infinite Dungeon</span></h1>
    <div class="char-create-panel" id="char-create" style="display:none;">
        <button class="btn-back" onclick="showMainMenu()">⬅ 返回主選單</button>
        <div style="width:250px; display:flex; flex-direction:column;" id="race-list"></div>
        <div style="flex-grow:1; padding-left:45px; border-left:1px solid #333; display: flex; flex-direction: column;">
            <div class="gender-select">
                <div class="gender-btn selected" id="btn-male" onclick="selectGender('MALE')">♂ 男</div>
                <div class="gender-btn" id="btn-female" onclick="selectGender('FEMALE')">♀ 女</div>
            </div>
            
            <div style="display: flex; flex-direction: row; align-items: flex-start; margin-bottom: 20px;">
                <div style="flex: 1;">
                    <h2 id="preview-race" style="color:#d4af37; font-size:36px; margin-top:0; margin-bottom: 10px;">人類</h2>
                    <p id="preview-desc" style="color:#888; height:70px; font-size:16px;">描述...</p>
                    <div style="width:100%;">
                        <div>力量</div><div class="stat-bar"><div id="bar-str" class="stat-fill"></div></div>
                        <div>敏捷</div><div class="stat-bar"><div id="bar-dex" class="stat-fill"></div></div>
                        <div>魔力</div><div class="stat-bar"><div id="bar-mag" class="stat-fill"></div></div>
                        <div>體質</div><div class="stat-bar"><div id="bar-vit" class="stat-fill"></div></div>
                    </div>
                </div>
                <div style="width: 200px; display: flex; justify-content: center; align-items: center;">
                     <div id="preview-icon" style="font-size:80px;">🧑</div>
                </div>
            </div>

            <button class="action-btn" style="margin-top:auto; font-size:24px; border-color:#d00; width:100%; padding:20px; font-weight:bold;" onclick="startGame()">踏入黑暗</button>
        </div>
    </div>
    <div id="main-menu">
        <button class="action-btn" style="font-size:28px; padding:25px 80px; margin-bottom:20px; display:block; width:350px;" onclick="showCharCreate()">新遊戲</button>
        <button class="action-btn" id="btn-load" style="font-size:28px; padding:25px 80px; margin-bottom:20px; display:block; width:350px;" onclick="tryLoadGame()">讀取進度</button>
        <button class="action-btn" style="font-size:28px; padding:25px 80px; display:block; width:350px;" onclick="openGuide()">遊戲指南</button>
    </div>
</div>

<div id="death-screen">
    <div id="death-title">你死掉了</div>
    <button class="death-btn" onclick="resurrect('checkpoint')" id="btn-checkpoint" style="display:none; border-color:#0af; color:#0af;">從最近安全區復活</button>
    <button class="death-btn" onclick="resurrect('town')">靈魂轉生 (掉落裝備保留等級)</button>
    <button class="death-btn" onclick="showMainMenu()">重新開始</button>
</div>

<script>
const HELM_ICON_SRC = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cpath d='M32 6 C20 6 10 16 10 32 V54 L18 60 L32 54 L46 60 L54 54 V32 C54 16 44 6 32 6 Z' fill='%2395a5a6' stroke='%232c3e50' stroke-width='2'/%3E%3Crect x='30' y='2' width='4' height='10' fill='%23c0392b'/%3E%3Cpath d='M32 2 Q40 2 42 10 Q32 8 32 10' fill='%23e74c3c'/%3E%3Cpath d='M20 32 L20 46 L32 54 L44 46 V32' fill='none' stroke='%232c3e50' stroke-width='3'/%3E%3Cpath d='M32 32 V54' fill='none' stroke='%232c3e50' stroke-width='2'/%3E%3C/svg%3E";
const helmImg = new Image();
helmImg.src = HELM_ICON_SRC;

const game = {
    running: false, map: [], visited: [], visibleTiles: [], entities: [], items: [], projs: [], shopItems: [],
    cam: {x:0, y:0}, player: null, floor: 0, uiDirty: false, transitionCooldown: 0, bossActive: false,
    dungeonCache: null, dead: false, currentNPC: null, activeShopNPC: null, savedPlayerPos: null,
    theme: { floor: '#181818', wall: '#1d1d1d' }, shopOpen: false, checkpoint: null,
    currentShopInventory: [],
    mapW: 100, mapH: 100
};
const joystick = { active: false, startX: 0, startY: 0, vector: {x:0,y:0} };
const mouse = { wx: 0, wy: 0 };
let gameCanvas, gameCtx, minimapCanvas, minimapCtx, selRace = 'HUMAN', selGender = 'MALE';

const RACES = {
    HUMAN: { name: '人類', desc: '能力平均。', stats: { str: 5, dex: 5, mag: 5, vit: 5 }, startSpells: { 'FIREBALL': 1 }, critBonus:0, killBonus:0, iconM: '🧑', iconF: '👧', startWeapon: 'SWORD_1H' },
    ELF:   { name: '精靈', desc: '身手敏捷，精通魔法。', stats: { str: 3, dex: 8, mag: 7, vit: 3 }, startSpells: { 'FIREBALL': 1, 'HASTE': 1 }, critBonus:5, killBonus:0, iconM: '🧝', iconF: '🧝‍♀️', startWeapon: 'DAGGER' },
    DWARF: { name: '矮人', desc: '體質強健，擅長暴擊。', stats: { str: 7, dex: 3, mag: 2, vit: 9 }, startSpells: { 'STONE_SKIN': 1 }, critBonus:10, killBonus:2, iconM: '🧔', iconF: '👩', startWeapon: 'AXE_2H' },
    ORC:   { name: '獸人', desc: '力量強大，容易一擊必殺。', stats: { str: 9, dex: 4, mag: 1, vit: 7 }, startSpells: { 'MIGHT': 1 }, critBonus:5, killBonus:5, iconM: '🦁', iconF: '🐯', startWeapon: 'SWORD_2H' },
    UNDEAD:{ name: '亡靈', desc: '魔力強大，免疫毒素。', stats: { str: 2, dex: 4, mag: 10, vit: 5 }, startSpells: { 'FIREBALL': 1, 'CHARGED_BOLT': 1 }, critBonus:0, killBonus:1, iconM: '💀', iconF: '💀', startWeapon: 'STAFF' }
};

const ITEM_TYPES = {
    SWORD_1H:{icon:'🗡️',name:'單手劍',slot:'mainhand',hands:1,range:55, speed:0.4, scale:1.0}, 
    SWORD_2H:{icon:'🗡️',name:'雙手巨劍',slot:'mainhand',hands:2,range:75, speed:0.7, scale:1.25}, 
    AXE_1H:{icon:'🪓',name:'單手斧',slot:'mainhand',hands:1,range:55, speed:0.5, scale:1.0}, 
    AXE_2H:{icon:'🪓',name:'雙手戰斧',slot:'mainhand',hands:2,range:75, speed:0.8, scale:1.25}, 
    SPEAR:{icon:'🔱',name:'長槍',slot:'mainhand',hands:2,range:72, speed:0.6, scale:1.2},
    BOW:{icon:'🏹',name:'短弓',slot:'mainhand',hands:2,range:350, speed:0.6, scale:1.0}, 
    CROSSBOW:{icon:'🏹',name:'十字弓',slot:'mainhand',hands:2,range:320, speed:0.9, scale:1.1},
    STAFF:{icon:'🦯',name:'法杖',slot:'mainhand',hands:2,range:65, speed:0.5, scale:1.1},
    DAGGER:{icon:'🔪',name:'匕首',slot:'offhand',hands:1,range:40, speed:0.25, scale:0.8},
    SHIELD:{icon:'🛡️',name:'盾牌',slot:'offhand',hands:1}, 
    HELM:{icon:'🧢',name:'頭盔',slot:'helm'},
    ARMOR:{icon:'👕',name:'護甲',slot:'armor'}, 
    PANTS:{icon:'👖',name:'護腿',slot:'pants'}, 
    BOOTS:{icon:'👢',name:'長靴',slot:'boots'}, 
    GLOVES:{icon:'🧤',name:'手套',slot:'gloves'},
    AMULET:{icon:'📿',name:'護符',slot:'necklace'}, 
    EARRING:{icon:'🔗',name:'耳環',slot:'earring'}, 
    RING:{icon:'💍',name:'戒指',slot:'ring'},
    GOLD:{icon:'💰',name:'金幣'}, POTION:{icon:'💊',name:'生命藥水'}, MANA_POTION:{icon:'🧪',name:'魔力藥水'}, SCROLL_TP:{icon:'📜',name:'回城卷軸'}, SPELL_BOOK:{icon:'📘',name:'法術書'}
};

const SPELLS = {
    FIREBALL:{name:'火球術',icon:'🔥',cost:15,dmgBase:20,dmgLvl:5,cd:0.8,type:'projectile', cat:'ATK', desc:'發射一團火球攻擊單一敵人。'},
    ICEBOLT:{name:'冰箭術',icon:'❄️',cost:12,dmgBase:15,dmgLvl:4,cd:0.6,type:'projectile', cat:'ATK', effect:'slow', desc:'發射冰箭，造成傷害並緩速。'},
    CHARGED_BOLT:{name:'電網',icon:'⚡',cost:18,dmgBase:8,dmgLvl:3,cd:0.6,type:'multishot', cat:'ATK', desc:'發射多個帶電的電球。'},
    POISON_DART:{name:'毒鏢',icon:'🤢',cost:15,dmgBase:10,dmgLvl:3,cd:1.0,type:'projectile', cat:'ATK', effect:'poison', desc:'使敵人中毒持續扣血。'},
    METEOR:{name:'隕石術',icon:'☄️',cost:60,dmgBase:60,dmgLvl:15,cd:4.0,type:'aoe', cat:'ATK', desc:'延遲後召喚隕石造成大範圍傷害。'},
    WIND_BLADE:{name:'風刃',icon:'🍃',cost:20,dmgBase:25,dmgLvl:6,cd:0.7,type:'projectile', cat:'ATK', desc:'快速的風刃攻擊。'},
    LIGHTNING_STRIKE:{name:'落雷',icon:'🌩️',cost:50,dmgBase:50,dmgLvl:10,cd:3.0,type:'aoe_instant', cat:'ATK', desc:'在鼠標處召喚落雷。'},
    HEAL:{name:'治癒術',icon:'💗',cost:30,dmgBase:40,dmgLvl:10,cd:2.0,type:'self', cat:'REC', desc:'恢復自身生命值。'},
    REGEN:{name:'再生術',icon:'🌿',cost:40,dmgBase:5,dmgLvl:2,cd:15.0,type:'buff', buff:'regen', desc:'一段時間內持續恢復生命。'},
    PURIFY:{name:'淨化',icon:'✨',cost:20,dmgBase:0,dmgLvl:0,cd:5.0,type:'self', cat:'REC', desc:'移除所有負面狀態。'},
    FULL_HEAL:{name:'神聖之光',icon:'✝️',cost:100,dmgBase:999,dmgLvl:0,cd:60.0,type:'self', cat:'REC', desc:'完全恢復生命值。'},
    MANA_TAP:{name:'魔力轉換',icon:'🔄',cost:0,dmgBase:0,dmgLvl:0,cd:10.0,type:'self', cat:'REC', desc:'消耗20%生命值轉換為魔力。'},
    STONE_SKIN:{name:'石化皮膚',icon:'🗿',cost:40,dmgBase:0,dmgLvl:0,cd:30.0,type:'buff', buff:'def', desc:'暫時增加防禦力。'},
    HASTE:{name:'急速',icon:'🥾',cost:30,dmgBase:0,dmgLvl:0,cd:20.0,type:'buff', buff:'speed', desc:'暫時增加移動速度。'},
    MIGHT:{name:'力量強化',icon:'💪',cost:40,dmgBase:0,dmgLvl:0,cd:30.0,type:'buff', buff:'atk', desc:'暫時增加物理攻擊力。'},
    MAGIC_SHIELD:{name:'魔力盾',icon:'🛡️',cost:50,dmgBase:0,dmgLvl:0,cd:40.0,type:'buff', buff:'shield', desc:'用魔力抵擋受到的傷害。'},
    INVISIBILITY:{name:'隱形',icon:'👻',cost:60,dmgBase:0,dmgLvl:0,cd:20.0,type:'buff', buff:'invis', desc:'暫時讓敵人無法發現你。'},
    SUMMON_SKELETON:{name:'召喚骷髏',icon:'💀',cost:50,dmgBase:0,dmgLvl:0,cd:5.0,type:'summon', cat:'EFF', sumType:'SKELETON', desc:'召喚一隻骷髏為你作戰。'},
    SUMMON_GOLEM:{name:'召喚魔像',icon:'🗿',cost:80,dmgBase:0,dmgLvl:0,cd:10.0,type:'summon', cat:'EFF', sumType:'GOLEM', desc:'召喚一隻強大的岩石魔像。'},
    SUMMON_HYDRA:{name:'噴火龍頭',icon:'🐲',cost:70,dmgBase:15,dmgLvl:5,cd:12.0,type:'summon', cat:'EFF', sumType:'HYDRA', desc:'召喚一個噴火龍頭砲塔。'},
    FIREWALL:{name:'火牆',icon:'🌋',cost:35,dmgBase:10,dmgLvl:2,cd:5.0,type:'ground', cat:'EFF', desc:'在地面創造一道持續傷害的火牆。'},
    CONFUSE:{name:'迷惑術',icon:'💫',cost:25,dmgBase:0,dmgLvl:0,cd:8.0,type:'debuff', cat:'EFF', effect:'confused', desc:'使敵人混亂隨機移動。'},
    CHARM:{name:'魅惑術',icon:'💞',cost:40,dmgBase:0,dmgLvl:0,cd:15.0,type:'debuff', cat:'EFF', effect:'charmed', desc:'暫時使敵人倒戈為你作戰。'}
};

const MONSTERS = {
    RAT: {name:'巨鼠', icon:'🐀', hp:20, dmg:5, def:0, ranged:false, tier: 1}, 
    BAT: {name:'蝙蝠', icon:'🦇', hp:15, dmg:6, def:0, ranged:false, tier: 1},
    SNAKE: {name:'巨毒蛇', icon:'🐍', hp:30, dmg:8, def:1, ranged:false, poison:true, tier: 1}, 
    SKELETON_SOLDIER: {name:'骷髏兵', icon:'💀', hp:50, dmg:15, def:2, ranged:false, tier: 1}, 
    SKELETON_SHIELD: {name:'骷髏盾衛', icon:'💀', subIcon:'🛡️', hp:110, dmg:10, def:10, ranged:false, tier: 2}, 
    SKELETON_SWORD: {name:'骷髏劍士', icon:'💀', subIcon:'🗡️', hp:70, dmg:22, def:4, ranged:false, tier: 2},
    SKELETON_ARCHER: {name:'骷髏射手', icon:'💀', subIcon:'🏹', hp:60, dmg:20, def:1, ranged:true, projIcon:'➳', range:200, tier: 2},
    GOBLIN_MAGE: {name:'哥布林法師', icon:'👹', subIcon:'🔥', hp:55, dmg:25, def:1, ranged:true, projIcon:'🔥', range:220, tier: 2},
    ORC_WARRIOR: {name:'獸人戰士', icon:'🐗', hp:150, dmg:45, def:5, ranged:false, tier: 3},
    OGRE: {name:'食人魔', icon:'👹', hp:250, dmg:50, def:8, ranged:false, tier: 3}, 
    EYE: {name:'眼魔', icon:'👁️', subIcon:'⚡', hp:100, dmg:35, def:3, ranged:true, projIcon:'⚡', range:180, tier: 3},
    GHOST: {name:'幽靈', icon:'👻', hp:70, dmg:30, def:8, speed:110, ranged:false, tier: 3},
    ASSASSIN: {name:'刺客', icon:'🥷', hp:90, dmg:55, def:2, speed:140, ranged:false, tier: 3},
    TENGU: {name:'天狗', icon:'👺', hp:120, dmg:40, def:5, speed:120, ranged:false, tier: 4}, 
    GOLEM_MOB: {name:'巨魔象', icon:'🗿', hp:400, dmg:60, def:20, speed:50, ranged:false, tier: 4}, 
    DEMON: {name:'惡魔', icon:'👿', hp:300, dmg:70, def:10, ranged:false, tier: 4},
    SPIDER: {name:'巨蜘蛛', icon:'🕷️', hp:60, dmg:20, def:2, speed:110, ranged:false, tier: 2}, 
    SCORPION: {name:'毒蠍', icon:'🦂', hp:80, dmg:25, def:5, ranged:false, tier: 2}, 
    DARK_ELF: {name:'黑暗精靈', icon:'🧕', subIcon:'🏹', hp:70, dmg:30, def:2, ranged:true, projIcon:'➳', range:250, tier: 3}, 
    BANDIT: {name:'土匪', icon:'🦹', hp:100, dmg:40, def:3, ranged:false, tier: 2},
    BANDIT_LEADER: {name:'強盜頭目', icon:'🦹', subIcon:'👑', hp:180, dmg:50, def:8, ranged:false, tier: 3},
    SUCCUBUS: {name:'魅魔', icon:'👩‍🎤', hp:150, dmg:30, def:5, ranged:true, projIcon:'❤️', range:180, special:'confuse', tier: 4}, 
    VAMPIRE: {name:'吸血鬼', icon:'🧛‍♂️', hp:200, dmg:40, def:8, ranged:false, special:'lifesteal', tier: 4}, 
    LICH: {name:'妖巫', icon:'🧙‍♂️', hp:180, dmg:45, def:5, ranged:true, projIcon:'🟣', range:250, special:'magic', tier: 4}, 
    HIGH_LICH: {name:'高級妖巫', icon:'🧙‍♀️', subIcon:'✨', hp:300, dmg:60, def:10, ranged:true, projIcon:'🔴', range:280, special:'high_magic', tier: 5}, 
    DRAGON: {name:'龍', icon:'🐉', hp:2000, dmg:100, def:30, ranged:true, projIcon:'🔥', range:300, speed:80, tier: 6} 
};

const AudioSys = {
    ctx: null, isMuted: false, bgmTimer: null,
    init: function() { 
        if(!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            this.playBGM();
        }
    },
    sfx: function(type) {
        if(!this.ctx || this.isMuted) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        
        if(type === 'hit') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.1); 
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
            osc.start(t); osc.stop(t+0.1);
        }
        else if (type === 'coin') { 
            osc.type = 'sine'; osc.frequency.setValueAtTime(1500, t); osc.frequency.setValueAtTime(2000, t+0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
            osc.start(t); osc.stop(t+0.2);
        }
        else if (type === 'magic') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(600, t+0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.3);
            osc.start(t); osc.stop(t+0.3);
        }
        else if (type === 'level') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.setValueAtTime(600, t+0.2); osc.frequency.setValueAtTime(800, t+0.4);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.6);
            osc.start(t); osc.stop(t+0.6);
        }
        else if (type === 'die') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.5);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
            osc.start(t); osc.stop(t+0.5);
        }
        else if (type === 'portal') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(800, t+1.0);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+1.0);
            osc.start(t); osc.stop(t+1.0);
        }
        else if (type === 'step') { // Added sound
            osc.type = 'square'; osc.frequency.setValueAtTime(50, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.05);
            gain.gain.setValueAtTime(0.05, t); gain.gain.linearRampToValueAtTime(0, t+0.05);
            osc.start(t); osc.stop(t+0.05);
        }
    },
    playBGM: function() {
        if (!this.ctx || this.isMuted) return;
        const now = this.ctx.currentTime;
        const tone = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        tone.connect(gain); gain.connect(this.ctx.destination);
        const freqs = [146.83, 174.61, 196.00, 220.00, 261.63, 130.81];
        let f = freqs[Math.floor(Math.random()*freqs.length)];
        if(Math.random() > 0.7) f *= 0.5; 
        tone.type = 'sine';
        tone.frequency.setValueAtTime(f, now);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.03, now + 1);
        gain.gain.linearRampToValueAtTime(0, now + 4);
        tone.start(now);
        tone.stop(now + 4);
        this.bgmTimer = setTimeout(() => this.playBGM(), 3000);
    },
    stopBGM: function() { clearTimeout(this.bgmTimer); }
};

class ItemClass {
    constructor(lvl, x, y, forceRare=false, forceCommon=false) {
        this.x = x; this.y = y; this.lvl = Math.max(1, lvl); this.isItem = true;
        this.count = 1; 
        const types = ['SWORD_1H','SWORD_2H','BOW','CROSSBOW','STAFF','AXE_1H','AXE_2H','SPEAR','SHIELD','HELM','ARMOR','PANTS','BOOTS','AMULET','EARRING','RING','DAGGER','GLOVES'];
        const consumables = ['POTION','MANA_POTION','SCROLL_TP','SPELL_BOOK']; 
        
        if (!forceRare && Math.random() < 0.3 && !forceCommon) {
            this.type = consumables[randInt(0, consumables.length)];
            this.rarity = { name: '普通', col: '#fff', mul: 1 };
            if (this.type === 'SPELL_BOOK') {
                const spellKeys = Object.keys(SPELLS); this.spellKey = spellKeys[randInt(0, spellKeys.length)];
                this.name = `法術書: ${SPELLS[this.spellKey].name}`; this.rarity = { name: '魔法', col: '#44f', mul: 1 };
            } else {
                this.name = ITEM_TYPES[this.type].name;
            }
        } else {
            this.type = types[randInt(0, types.length)];
            let rRoll = Math.random() + (this.lvl * 0.015);
            if (forceRare) rRoll += 0.5;
            if (forceCommon) rRoll = 0;
            if (this.lvl <= 2 && !forceRare) rRoll = Math.min(rRoll, 0.6); 
            else if (this.lvl <= 5 && !forceRare) rRoll = Math.min(rRoll, 0.85); 

            if (rRoll < 0.45) { this.rarity = { name: '普通', col: '#fff', mul: 1.0, tier: 0 }; } 
            else if (rRoll < 0.65) { this.rarity = { name: '破損', col: '#999', mul: 1.1, tier: 1 }; } 
            else if (rRoll < 0.80) { this.rarity = { name: '優秀', col: '#0f0', mul: 1.3, tier: 2 }; } 
            else if (rRoll < 0.90) { this.rarity = { name: '精良', col: '#00f', mul: 1.6, tier: 3 }; } 
            else if (rRoll < 0.96) { this.rarity = { name: '史詩', col: '#ff0', mul: 2.0, tier: 4 }; } 
            else if (rRoll < 0.99) { this.rarity = { name: '傳說', col: '#f00', mul: 2.5, tier: 5 }; } 
            else if (rRoll < 0.998) { this.rarity = { name: '神話', col: '#ffd700', mul: 3.5, tier: 6 }; } 
            else if (rRoll < 0.9999) { this.rarity = { name: '虛空', col: '#f0f', mul: 5.0, tier: 7 }; } 
            else { this.rarity = { name: '滅世', col: '#000', mul: 10.0, tier: 8, glow: true }; }
            
            this.name = ITEM_TYPES[this.type].name;
            if (this.rarity.tier > 0) { const pre = ['','粗糙','優秀','精良','史詩','傳說','神話','虛空','滅世']; this.name = pre[this.rarity.tier] + "的" + this.name; }
        }
        
        if (this.type !== 'SPELL_BOOK') { const baseVal = ITEM_TYPES[this.type].slot ? 50 : 10; this.price = Math.floor(baseVal * this.lvl * (this.rarity.mul || 1)); } else { this.price = 200; }
        
        this.effects = [];
        if (this.type !== 'SPELL_BOOK' && this.rarity.tier >= 1) { 
            let chance = 0.05 + (this.rarity.tier * 0.06);
            if(Math.random() < chance) this.effects.push({type:'燃燒', chance:0.2, val:this.lvl*2, duration:3});
            if(Math.random() < chance) this.effects.push({type:'中毒', chance:0.2, val:this.lvl*1, duration:5});
            if(Math.random() < chance) this.effects.push({type:'暈眩', chance:0.1, val:1.0, duration:2});
            if(Math.random() < chance) this.effects.push({type:'緩速', chance:0.2, val:2.0, duration:3});
            if(this.type === 'BOOTS') this.effects.push({type:'加速', chance:1.0, val: 10 + this.lvl * 2});
        }

        this.stats = {};
        if (ITEM_TYPES[this.type].slot) {
            let variance = randInt(0, 3); let mul = this.rarity.mul;
            this.stats.atk = (['SWORD_1H','SWORD_2H','AXE_1H','AXE_2H','SPEAR','BOW','CROSSBOW','DAGGER','GLOVES'].includes(this.type)) ? Math.floor((10 + this.lvl * 3 + variance) * mul) : 0;
            if(this.type === 'GLOVES') this.stats.atk = Math.floor(this.stats.atk * 0.3);
            if(this.type.includes('2H') || this.type === 'CROSSBOW' || this.type === 'SPEAR') this.stats.atk = Math.floor(this.stats.atk * 1.6); 
            this.stats.def = (['ARMOR','SHIELD','HELM','PANTS','BOOTS','GLOVES'].includes(this.type)) ? Math.floor((2 + this.lvl * 1.5 + variance) * mul) : 0;
            if (this.type === 'STAFF') this.stats.mag = Math.floor((8 + this.lvl * 3 + variance) * mul);
            if(['AMULET','RING','EARRING'].includes(this.type)) { this.stats.str = randInt(0, this.lvl); this.stats.dex = randInt(0, this.lvl); this.stats.mag = randInt(0, this.lvl); this.stats.vit = randInt(0, this.lvl); }
            if(mul > 1.2) this.stats.str = (this.stats.str||0) + randInt(1, this.lvl);
            if(mul > 1.5) this.stats.vit = (this.stats.vit||0) + randInt(1, this.lvl);
        }
    }
}

class PlayerClass {
    constructor(raceKey, gender) {
        this.raceKey = raceKey; this.race = RACES[raceKey]; this.gender = gender;
        this.x = 0; this.y = 0; this.lvl = 1; this.xp = 0; this.pts = 0;
        this.baseStats = { ...this.race.stats }; 
        this.stats = { ...this.baseStats, atk: 0, def: 0 };
        this.hp = 100; this.maxHp = 100; this.mp = 50; this.maxMp = 50; this.gold = 200; 
        this.icon = this.gender === 'MALE' ? this.race.iconM : this.race.iconF;
        this.inv = []; 
        this.stash = []; 
        this.equip = { helm:null, necklace:null, earring1:null, earring2:null, armor:null, mainhand:null, offhand:null, ring1:null, ring2:null, pants:null, boots:null, gloves:null };
        
        if(this.race.startWeapon) {
            let weapon = new ItemClass(1, 0, 0, false, true); 
            weapon.type = this.race.startWeapon;
            weapon.name = ITEM_TYPES[weapon.type].name;
            weapon.stats.atk = 10;
            if(weapon.type.includes('2H') || weapon.type === 'SPEAR') weapon.stats.atk = Math.floor(weapon.stats.atk * 1.6);
            this.equip.mainhand = weapon;
        }

        this.hotbar = new Array(8).fill(null);
        this.hotbar[0] = {type:'POTION', name:'生命藥水', count:2};
        this.hotbar[1] = {type:'MANA_POTION', name:'魔力藥水', count:1};
        this.hotbar[2] = {type:'SCROLL_TP', name:'回城卷軸', count:1};

        this.spells = JSON.parse(JSON.stringify(this.race.startSpells));
        const sKeys = Object.keys(this.spells);
        if(sKeys.length > 0) this.hotbar[4] = sKeys[0];
        if(sKeys.length > 1) this.hotbar[5] = sKeys[1];
        
        this.activeSpell = sKeys.length > 0 ? sKeys[0] : null;
        this.atkCd = 0; this.cooldowns = {}; // FIX: Added individual spell cooldowns
        this.path = []; this.targetEntity = null; this.attackRequested = false; 
        this.attackAnimTimer = 0;
        this.moveSpeed = 90; 
        this.buffs = [];
        this.confusedTimer = 0; 
        this.recalc();
    }
    recalc() {
        this.stats = { str: this.baseStats.str, dex: this.baseStats.dex, mag: this.baseStats.mag, vit: this.baseStats.vit, atk: 0, def: 0 };
        let bonusSpeed = 0;
        for (let key in this.equip) {
            if (this.equip[key]) {
                const s = this.equip[key].stats;
                if(s.atk) this.stats.atk += s.atk; 
                if(s.def) this.stats.def += s.def; 
                if(s.mag) this.stats.mag += s.mag; 
                if(s.str) this.stats.str += s.str; 
                if(s.vit) this.stats.vit += s.vit; 
                if(s.dex) this.stats.dex += s.dex;
                if(this.equip[key].effects) { this.equip[key].effects.forEach(e => { if(e.type==='加速') bonusSpeed += e.val; }); }
            }
        }
        this.buffs.forEach(b => {
            if(b.type === 'speed') bonusSpeed += 50;
            if(b.type === 'atk') this.stats.atk += 20;
            if(b.type === 'def') this.stats.def += 20;
        });
        this.stats.atk += this.stats.str * 2; 
        this.maxHp = 50 + this.stats.vit * 10 + this.lvl * 10; this.maxMp = 20 + this.stats.mag * 8 + this.lvl * 5;
        this.critChance = 0.05 + this.stats.str * 0.005 + (this.race.critBonus/100);
        this.killChance = 0.00 + (this.stats.str + this.stats.dex) * 0.001 + (this.race.killBonus/100);
        this.evasion = Math.min(0.60, 0.0 + this.stats.dex * 0.005); 
        this.blockChance = 0;
        if (this.equip.offhand && this.equip.offhand.type === 'SHIELD') { this.blockChance = Math.min(0.50, 0.05 + this.stats.str * 0.005); }
        this.moveSpeed = 90 + (this.stats.dex * 1.5) + bonusSpeed;
    }
    
    tryGiveOrDrop(item) {
        if(this.inv.length < 40) this.inv.push(item);
        else {
            game.items.push({...item, x:this.x, y:this.y});
            spawnText(this.x, this.y, "背包已滿，物品掉落!", "#f00");
        }
    }

    equipItem(it, invIdx, targetSlot = null) {
        if(it.type === 'POTION') { this.hp = Math.min(this.maxHp, this.hp + 50); if(invIdx!==null) this.inv.splice(invIdx, 1); AudioSys.sfx('coin'); game.uiDirty = true; return true; }
        if(it.type === 'MANA_POTION') { this.mp = Math.min(this.maxMp, this.mp + 50); if(invIdx!==null) this.inv.splice(invIdx, 1); AudioSys.sfx('coin'); game.uiDirty = true; return true; }
        if(it.type === 'SCROLL_TP') { useTownPortal(false); if(invIdx!==null) this.inv.splice(invIdx, 1); AudioSys.sfx('coin'); game.uiDirty = true; return true; }
        if(it.type === 'SPELL_BOOK') {
            if(this.spells[it.spellKey]) { this.spells[it.spellKey] = Math.min(100, this.spells[it.spellKey] + 1); spawnText(this.x, this.y, `法術升級! Lv ${this.spells[it.spellKey]}`, "#0af"); }
            else { this.spells[it.spellKey] = 1; if(!this.activeSpell) this.activeSpell = it.spellKey; spawnText(this.x, this.y, `習得 ${SPELLS[it.spellKey].name}!`, "#0af"); }
            if(invIdx!==null) this.inv.splice(invIdx, 1); AudioSys.sfx('level'); game.uiDirty = true; return true;
        }
        
        let slot = targetSlot || ITEM_TYPES[it.type].slot;
        if (!slot) return false;
        
        if (ITEM_TYPES[it.type].hands === 2) {
             let reqStr = it.lvl * 3;
             if (this.stats.str < reqStr) { alert(`力量不足! 需要: ${reqStr}`); return false; }
        }

        if (slot === 'ring' && !targetSlot) { slot = !this.equip.ring1 ? 'ring1' : (!this.equip.ring2 ? 'ring2' : 'ring1'); }
        if (slot === 'earring' && !targetSlot) { slot = !this.equip.earring1 ? 'earring1' : (!this.equip.earring2 ? 'earring2' : 'earring1'); }

        let unequippedItem = this.equip[slot];
        
        if (ITEM_TYPES[it.type].hands === 2) { 
             if((it.type === 'BOW' || it.type === 'CROSSBOW') && this.equip.offhand && this.equip.offhand.type === 'DAGGER') {
             } else {
                 if(this.equip.offhand) { 
                     this.tryGiveOrDrop(this.equip.offhand);
                     this.equip.offhand = null; 
                 }
             }
             if(slot === 'offhand') slot = 'mainhand'; 
        }
        
        if (slot === 'offhand' && this.equip.mainhand && ITEM_TYPES[this.equip.mainhand.type].hands === 2) {
             if (!((this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW') && it.type === 'DAGGER')) {
                 this.tryGiveOrDrop(this.equip.mainhand);
                 this.equip.mainhand = null;
             }
        }
        
        if (!targetSlot && ITEM_TYPES[it.type].hands === 1 && slot === 'mainhand' && this.equip.mainhand && !this.equip.offhand && it.type !== 'SHIELD') { slot = 'offhand'; unequippedItem = this.equip[slot]; }
        if (!targetSlot && it.type === 'DAGGER' && this.equip.mainhand && (this.equip.mainhand.type === 'BOW' || this.equip.mainhand.type === 'CROSSBOW')) { slot = 'offhand'; unequippedItem = this.equip[slot]; }

        this.equip[slot] = it; 
        
        if (invIdx !== null) {
            this.inv.splice(invIdx, 1);
            if (unequippedItem) this.tryGiveOrDrop(unequippedItem);
        } else {
            if (unequippedItem) this.tryGiveOrDrop(unequippedItem);
        }
        
        this.recalc(); game.uiDirty = true; AudioSys.sfx('coin');
        return true;
    }
}

function randInt(min,max){return Math.floor(Math.random()*(max-min)+min);}
function isSolid(x,y){ const tx=Math.floor(x/40), ty=Math.floor(y/40); if(tx<0||tx>=game.mapW||ty<0||ty>=game.mapH) return true; return game.map[ty][tx]===1; }
function hasLineOfSight(x1, y1, x2, y2) { if (x1<0||x1>=game.mapW||y1<0||y1>=game.mapH||x2<0||x2>=game.mapW||y2<0||y2>=game.mapH) return false; let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1); let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1; let err = dx - dy; let maxIter = 200; while (maxIter-- > 0) { if (x1 === x2 && y1 === y2) return true; if (game.map[y1][x1] === 1) return false; let e2 = 2 * err; if (e2 > -dy) { err -= dy; x1 += sx; } if (e2 < dx) { err += dx; y1 += sy; } if (x1<0||x1>=game.mapW||y1<0||y1>=game.mapH) return false; } return false; }
function isBlocked(x, y, self) { if(isSolid(x, y)) return true; return false; }
function findPath(sx, sy, tx, ty) { let startNode = {x: Math.floor(sx/40), y: Math.floor(sy/40)}; let endNode = {x: Math.floor(tx/40), y: Math.floor(ty/40)}; if (endNode.x < 0 || endNode.x >= game.mapW || endNode.y < 0 || endNode.y >= game.mapH) return []; if (game.map[endNode.y][endNode.x] === 1) { let best = null; let minD = 999; [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d=>{ let nx=endNode.x+d.x, ny=endNode.y+d.y; if(nx>=0 && nx<game.mapW && ny>=0 && ny<game.mapH && game.map[ny][nx] !== 1) { let d = Math.hypot(nx-startNode.x, ny-startNode.y); if(d < minD) { minD = d; best = {x:nx, y:ny}; } } }); if(best) { endNode = best; } else return []; } if (hasLineOfSight(startNode.x, startNode.y, endNode.x, endNode.y)) { return [{x: endNode.x*40+20, y: endNode.y*40+20}]; } let queue = [startNode]; let cameFrom = {}; let key = (n) => n.x + ',' + n.y; cameFrom[key(startNode)] = null; let current = null; let maxSteps = 2000; while(queue.length > 0 && maxSteps-- > 0) { current = queue.shift(); if (current.x === endNode.x && current.y === endNode.y) break; [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].forEach(d => { let next = {x: current.x + d.x, y: current.y + d.y}; if (next.x >= 0 && next.x < game.mapW && next.y >= 0 && next.y < game.mapH && game.map[next.y][next.x] !== 1) { if (cameFrom[key(next)] === undefined) { queue.push(next); cameFrom[key(next)] = current; } } }); } if (!current || (current.x !== endNode.x && current.y !== endNode.y)) return []; let path = []; let curr = endNode; while (curr && (curr.x !== startNode.x || curr.y !== startNode.y)) { path.push({x: curr.x * 40 + 20, y: curr.y * 40 + 20}); curr = cameFrom[key(curr)]; if(!curr && path.length > 0) break; } return path.reverse(); }
function computeFOV(px, py, radius) { let visible = []; for(let y=0; y<game.mapH; y++) visible[y] = []; if(px>=0 && px<game.mapW && py>=0 && py<game.mapH) visible[py][px] = true; const rays = 360; for (let i = 0; i < rays; i++) { let angle = (i * Math.PI) / 180; let dx = Math.cos(angle); let dy = Math.sin(angle); let ox = px + 0.5, oy = py + 0.5; for (let j = 0; j < radius; j++) { ox += dx; oy += dy; let tx = Math.floor(ox), ty = Math.floor(oy); if (tx < 0 || tx >= game.mapW || ty < 0 || ty >= game.mapH) break; visible[ty][tx] = true; if (game.map[ty][tx] === 1) break; } } return visible; }

function createRoomsAndCorridors(lvl, w, h) {
    let map = []; for(let y=0;y<h;y++){ let r=[]; for(let x=0;x<w;x++) r.push(1); map.push(r); }
    let rooms = []; const numRooms = Math.floor(w * h / 100) + 5;
    for (let i = 0; i < numRooms; i++) {
        let rw = randInt(6, 14); let rh = randInt(6, 14); let x = randInt(2, w - rw - 2); let y = randInt(2, h - rh - 2);
        let overlap = false; for (let r of rooms) { if (x < r.x + r.w + 1 && x + rw + 1 > r.x && y < r.y + r.h + 1 && y + rh + 1 > r.y) { overlap = true; break; } }
        if (!overlap) { rooms.push({x, y, w:rw, h:rh, cx: Math.floor(x + rw / 2), cy: Math.floor(y + rh / 2)}); for (let ry = y; ry < y + rh; ry++) for (let rx = x; rx < x + rw; rx++) map[ry][rx] = 0; }
    }
    for (let i = 1; i < rooms.length; i++) {
        let r1 = rooms[i-1], r2 = rooms[i]; let cx1 = r1.cx, cy1 = r1.cy, cx2 = r2.cx, cy2 = r2.cy;
        if (Math.random() < 0.5) {
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy1][x] = 0; map[cy1+1][x] = 0; }
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx2] = 0; map[y][cx2+1] = 0; }
        } else {
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx1] = 0; map[y][cx1+1] = 0; }
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy2][x] = 0; map[cy2+1][x] = 0; }
        }
    }
    return {map, rooms};
}

function createCaves(w, h) {
    let map = [];
    for(let y=0;y<h;y++) {
        let row = [];
        for(let x=0;x<w;x++) {
            if(x===0 || x===w-1 || y===0 || y===h-1) row.push(1);
            else row.push(Math.random() < 0.45 ? 1 : 0);
        }
        map.push(row);
    }
    for(let i=0; i<5; i++) {
        let newMap = JSON.parse(JSON.stringify(map));
        for(let y=1;y<h-1;y++) {
            for(let x=1;x<w-1;x++) {
                let neighbors = 0;
                for(let ny=y-1;ny<=y+1;ny++) for(let nx=x-1;nx<=x+1;nx++) if(map[ny][nx]===1) neighbors++;
                if(neighbors > 4) newMap[y][x] = 1;
                else if(neighbors < 4) newMap[y][x] = 0;
            }
        }
        map = newMap;
    }
    let rooms = [];
    for(let i=0; i<10; i++) {
        let rx = randInt(5, w-5), ry = randInt(5, h-5);
        if(map[ry][rx] === 0) rooms.push({cx:rx, cy:ry, x:rx-2, y:ry-2, w:4, h:4});
    }
    if(rooms.length < 2) return createRoomsAndCorridors(0, w, h); 
    for (let i = 1; i < rooms.length; i++) {
        let r1 = rooms[i-1], r2 = rooms[i]; let cx1 = r1.cx, cy1 = r1.cy, cx2 = r2.cx, cy2 = r2.cy;
        if (Math.random() < 0.5) {
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy1][x] = 0; map[cy1+1][x] = 0; }
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx2] = 0; map[y][cx2+1] = 0; }
        } else {
            for (let y = Math.min(cy1, cy2); y <= Math.max(cy1, cy2); y++) { map[y][cx1] = 0; map[y][cx1+1] = 0; }
            for (let x = Math.min(cx1, cx2); x <= Math.max(cx1, cx2); x++) { map[cy2][x] = 0; map[cy2+1][x] = 0; }
        }
    }
    return {map, rooms};
}

function genFloor(lvl) {
    lvl = parseInt(lvl); if(isNaN(lvl)) lvl = 0; game.floor = lvl;
    game.map=[]; game.visited=[]; game.visibleTiles=[]; game.entities=[]; game.items=[]; game.projs=[];
    game.transitionCooldown = 2.0; game.bossActive = (lvl > 0 && lvl % 5 === 0);
    game.currentShopInventory = []; 
    for(let i=0;i<8;i++){ let it=new ItemClass(Math.max(1, lvl + randInt(0,3)), 0, 0); it.price = Math.floor(it.price * (0.8 + Math.random() * 0.4)); game.currentShopInventory.push(it); }
    let isSafeZone = (lvl > 0 && lvl % 3 === 0);
    if (lvl === 0) { game.mapW = 100; game.mapH = 100; }
    else if (lvl === 1) { game.mapW = 40; game.mapH = 40; }
    else if (lvl === 2) { game.mapW = 60; game.mapH = 60; }
    else if (lvl === 3) { game.mapW = 80; game.mapH = 80; }
    else { game.mapW = randInt(60, 100); game.mapH = randInt(60, 100); }
    const themes = [{f:'#181818', w:'#222'}, {f:'#1a1f1a', w:'#203020'}, {f:'#221010', w:'#331111'}, {f:'#111122', w:'#222233'}];
    let themeIdx = Math.floor((lvl-1)/3); if(themeIdx < 0) themeIdx = 0; game.theme = themes[themeIdx % 4];
    for(let y=0;y<game.mapH;y++){ let v=[]; let vt=[]; for(let x=0;x<game.mapW;x++) { v.push(false); vt.push(false); } game.visited.push(v); game.visibleTiles.push(vt); }
    if(lvl===0){ 
        for(let y=0;y<game.mapH;y++){ let r=[]; for(let x=0;x<game.mapW;x++) r.push(1); game.map.push(r); }
        for(let y=40;y<60;y++) for(let x=40;x<60;x++) game.map[y][x]=0;
        if(game.savedPlayerPos) { game.player.x=game.savedPlayerPos.x; game.player.y=game.savedPlayerPos.y; game.savedPlayerPos = null; } else { game.player.x=50*40+20; game.player.y=50*40+20; }
        game.entities.push({x:45*40+20,y:45*40+20,size:22,type:'NPC_ELDER',icon:'👴',name:'長老', dead:false});
        game.entities.push({x:55*40+20,y:45*40+20,size:22,type:'NPC_GENERAL',icon:'👳‍♂️',name:'商人', dead:false});
        game.entities.push({x:48*40+20,y:42*40+20,type:'STORAGE',icon:'📦',name:'儲藏箱', dead:false, size:30});
        if(game.dungeonCache) { game.entities.push({x:50*40+20, y:48*40+20, type:'PORTAL_DUNGEON', icon:'🌀', name:'回城傳送門', dead:false, size:30}); }
        game.map[55][50]=2; spawnText(game.player.x, game.player.y - 50, "城鎮", "#ffd700");
    } else {
        let dungeon; if (Math.random() < 0.4 && lvl > 3) { dungeon = createCaves(game.mapW, game.mapH); } else { dungeon = createRoomsAndCorridors(lvl, game.mapW, game.mapH); }
        game.map = dungeon.map; const rooms = dungeon.rooms;
        let startRoom = rooms[0]; let sx = startRoom.cx, sy = startRoom.cy;
        if (game.map[sy][sx] === 1) { for(let y=2; y<game.mapH-2; y++) for(let x=2; x<game.mapW-2; x++) if(game.map[y][x] === 0) { sx=x; sy=y; break; } }
        game.map[sy][sx] = 6;
        if(game.savedPlayerPos) { game.player.x=game.savedPlayerPos.x; game.player.y=game.savedPlayerPos.y; game.savedPlayerPos = null; } else { game.player.x = sx * 40 + 20; game.player.y = sy * 40 + 20; }
        let endRoom = rooms[rooms.length - 1]; let ex = endRoom.cx, ey = endRoom.cy;
        if (game.map[ey][ex] === 1) { for(let y=game.mapH-3; y>2; y--) for(let x=game.mapW-3; x>2; x--) if(game.map[y][x] === 0) { ex=x; ey=y; break; } }
        if (isSafeZone) {
            game.entities.push({x:ex*40+60, y:ey*40+20, type:'NPC_GENERAL', icon:'👳‍♂️', name:'地下商人', dead:false, size:22});
            game.entities.push({x:ex*40+20, y:ey*40+60, type:'CHECKPOINT', icon:'💎', name:'靈魂水晶', dead:false, size:30});
            game.entities.push({x:ex*40-40, y:ey*40+20, type:'STORAGE', icon:'📦', name:'儲藏箱', dead:false, size:30});
        }
        if (game.bossActive) {
            let bossKey = lvl >= 10 ? 'DRAGON' : 'DEMON'; let template = MONSTERS[bossKey];
            game.entities.push({ x: ex*40+20, y: ey*40+20, isEnemy: true, isBoss: true, hp: template.hp + lvl * 100, maxHp: template.hp + lvl * 100, dmg: template.dmg + lvl * 5, def: template.def + lvl, icon: template.icon, name: template.name, ranged: template.ranged, projIcon: template.projIcon, dead: false, size: 40 });
            spawnText(game.player.x, game.player.y - 100, `警告：${template.name} 出現！`, "#f00");
        } else { game.map[ey][ex] = 2; }
        if (game.dungeonCache && game.dungeonCache.floor === lvl) { game.entities.push({x:game.dungeonCache.x, y:game.dungeonCache.y, type:'PORTAL_TOWN', icon:'🌀', name:'前往城鎮', dead:false, size:30}); }
        for (let i = 1; i < rooms.length - 1; i++) {
            let r = rooms[i];
            if(Math.random() < 0.2) { let tx, ty, tries=0; do { tx = randInt(r.x, r.x+r.w) * 40 + 20; ty = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(tx, ty) && tries < 50); game.entities.push({x:tx, y:ty, type:'TRAP', icon:'⚠️', name:'陷阱', dead:false, size:20, hidden:true, triggered:false}); }
            let numMobs = randInt(2, 5 + Math.floor(lvl/3)); 
            for(let m=0; m<numMobs; m++) {
                let mx, my, tries=0; do { mx = randInt(r.x, r.x+r.w) * 40 + 20; my = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(mx, my) && tries < 50);
                let maxTier = 1; if (lvl <= 2) maxTier = 1; else if (lvl <= 5) maxTier = 2; else if (lvl <= 10) maxTier = 3; else maxTier = Math.min(6, Math.floor((lvl + 1) / 2));
                let mKeys = Object.keys(MONSTERS).filter(k => MONSTERS[k].tier <= maxTier && MONSTERS[k].tier >= (lvl > 5 ? maxTier - 2 : 1)); if (mKeys.length === 0) mKeys = ['RAT'];
                let mKey = mKeys[randInt(0, mKeys.length)]; let template = MONSTERS[mKey];
                let isElite = false; let eliteRarity = 0;
                if (lvl >= 3 && Math.random() < (0.05 + lvl * 0.015)) { isElite = true; let r = Math.random(); if(r < 0.3) eliteRarity = 0; else if(r < 0.55) eliteRarity = 1; else if(r < 0.75) eliteRarity = 2; else if(r < 0.88) eliteRarity = 3; else if(r < 0.95) eliteRarity = 4; else if(r < 0.98) eliteRarity = 5; else if(r < 0.995) eliteRarity = 6; else eliteRarity = 7; }
                let scale = 1.0 + lvl * 0.15; if (lvl === 1) scale = 0.6; 
                let hp = Math.floor(template.hp * scale); let dmg = Math.floor(template.dmg * scale); let def = Math.floor((template.def || 0) + lvl * 0.5);
                if (isElite) { let mult = 1.5 + (eliteRarity * 0.5); hp = Math.floor(hp * mult); dmg = Math.floor(dmg * (1 + eliteRarity * 0.2)); def += (eliteRarity * 2); }
                game.entities.push({ x:mx, y:my, isEnemy:true, hp:hp, maxHp:hp, dmg:dmg, def:def, icon:template.icon, subIcon:template.subIcon, name:template.name, ranged: template.ranged, projIcon: template.projIcon, range: template.range || 50, speed: template.speed || 75, dead:false, size:20, lvl: lvl, pushX: 0, pushY: 0, isElite: isElite, eliteRarity: eliteRarity, poison: template.poison, special: template.special, tier: template.tier });
            }
            if (Math.random() < 0.3) { let cx, cy, tries=0; do { cx = randInt(r.x, r.x+r.w) * 40 + 20; cy = randInt(r.y, r.y+r.h) * 40 + 20; tries++; } while(isSolid(cx, cy) && tries < 50); let isTrapped = Math.random() < 0.25; game.entities.push({x:cx, y:cy, type:'CHEST', icon:'📦', name:'寶箱', dead:false, size:20, trapped: isTrapped}); }
        }
        let floorMsg = "進入 地下第 " + lvl + " 層"; if(isSafeZone) floorMsg += " (安全區)"; spawnText(game.player.x, game.player.y - 50, floorMsg, isSafeZone ? "#0f0" : "#f00");
    }
    game.visibleTiles = computeFOV(Math.floor(game.player.x/40), Math.floor(game.player.y/40), 10);
    for(let y=0; y<game.mapH; y++) for(let x=0; x<game.mapW; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;
    game.uiDirty = true; updateUI();
}

function update() {
    try {
        if(game.dead) return;
        if(!game.running) return;
        const p=game.player; const dt=0.016; 
        p.atkCd-=dt; p.attackAnimTimer -= dt;
        
        // FIX: Decrease individual spell cooldowns
        for(let k in p.cooldowns) {
            p.cooldowns[k] -= dt;
            if(p.cooldowns[k] <= 0) delete p.cooldowns[k];
        }

        if(game.transitionCooldown > 0) game.transitionCooldown -= dt;
        if(p.confusedTimer > 0) p.confusedTimer -= dt;

        const tx=Math.floor(p.x/40), ty=Math.floor(p.y/40);
        game.visibleTiles = computeFOV(tx, ty, 10);
        for(let y=0; y<game.mapH; y++) for(let x=0; x<game.mapW; x++) if(game.visibleTiles[y] && game.visibleTiles[y][x]) game.visited[y][x] = true;

        let regenMult = (p.path.length > 0 || joystick.active) ? 0.2 : 1.0; 
        let hpRegenBase = p.maxHp * 0.002 * regenMult; let mpRegenBase = p.maxMp * 0.005;
        p.hp = Math.min(p.maxHp, p.hp + hpRegenBase * (1 + p.stats.vit * 0.2) * dt);
        p.mp = Math.min(p.maxMp, p.mp + mpRegenBase * (1 + p.stats.mag * 0.2) * dt);
        p.regenInfo = { hp: hpRegenBase * (1 + p.stats.vit * 0.2), mp: mpRegenBase * (1 + p.stats.mag * 0.2) };
        
        for(let i=p.buffs.length-1; i>=0; i--) {
            p.buffs[i].time -= dt;
            if(p.buffs[i].type === 'regen') { let val = p.buffs[i].val || 5; p.hp = Math.min(p.maxHp, p.hp + val * dt); }
            if(p.buffs[i].type === 'mana_shield' && p.mp <= 0) { p.buffs[i].time = 0; spawnText(p.x, p.y-40, "魔力盾破裂!", "#aaf"); }
            if(p.buffs[i].time <= 0) { p.buffs.splice(i, 1); p.recalc(); }
        }

        if(p.poisonTimer > 0) {
            p.poisonTimer -= dt; p.hp -= p.poisonDmg * dt;
            if(Math.random() < 0.05) spawnText(p.x, p.y-30, "中毒!", "#0f0");
            if(p.poisonTimer <= 0) p.poisonDmg = 0;
        }

        let inputVec = {x:0, y:0};
        if(joystick.active) { inputVec = {...joystick.vector}; }
        if(p.confusedTimer > 0) {
            if(Math.random() < 0.1) { inputVec.x = (Math.random() - 0.5) * 2; inputVec.y = (Math.random() - 0.5) * 2; } else { inputVec.x *= -1; inputVec.y *= -1; }
        }

        if(joystick.active || p.confusedTimer > 0) {
            let speed=p.moveSpeed; 
            if (p.confusedTimer > 0 && !joystick.active && p.path.length === 0) speed = 0; 
            let nx=p.x + (inputVec.x * speed) * dt; let ny=p.y + (inputVec.y * speed) * dt;
            if(!isBlocked(nx,p.y,p)) p.x=nx; if(!isBlocked(p.x,ny,p)) p.y=ny; 
            p.path=[]; p.targetEntity=null; 
            if(inputVec.x!==0 || inputVec.y!==0) p.facing=Math.atan2(inputVec.y,inputVec.x);
        } else if(p.targetEntity && !p.targetEntity.dead) {
            const dist=Math.hypot(p.targetEntity.x-p.x, p.targetEntity.y-p.y);
            p.facing = Math.atan2(p.targetEntity.y - p.y, p.targetEntity.x - p.x);
            let dx=p.targetEntity.x-p.x, dy=p.targetEntity.y-p.y; 
            
            if (!p.targetEntity.isEnemy && !p.targetEntity.charmed) {
                 if(dist < 40) {
                    if(p.targetEntity.type === 'CHEST') openChest(p.targetEntity);
                    else if(p.targetEntity.type === 'CHECKPOINT') interactCheckpoint(p.targetEntity);
                    else if(p.targetEntity.type === 'STORAGE') toggleStash();
                    else if(p.targetEntity.type && p.targetEntity.type.startsWith('NPC')) interactNPC(p.targetEntity); 
                    else if(p.targetEntity.type === 'PORTAL_TOWN') useTownPortal(false); 
                    else if(p.targetEntity.type === 'PORTAL_DUNGEON') useTownPortal(true); 
                    else if(p.targetEntity.isItem) pickup(p.targetEntity);
                    p.targetEntity = null; p.path = [];
                 } else {
                    let moveS = p.moveSpeed*dt; let mx = (dx/dist*moveS); let my = (dy/dist*moveS);
                    if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                 }
            } else if (p.targetEntity.isEnemy && !p.targetEntity.charmed) {
                let range = (p.equip.mainhand ? ITEM_TYPES[p.equip.mainhand.type].range : 35);
                if (dist <= range) {
                     if(p.attackRequested) { 
                         if (p.atkCd <= 0) { attack(p.targetEntity); p.attackRequested = false; }
                     }
                     p.path = [];
                } else {
                     let moveS = p.moveSpeed*dt; let mx = (dx/dist*moveS); let my = (dy/dist*moveS);
                     if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                }
            }
        } else if(p.path.length>0) {
            let next=p.path[0]; let dx=next.x-p.x, dy=next.y-p.y; let dist=Math.sqrt(dx*dx+dy*dy);
            if(dist<8) p.path.shift(); else { 
                let s=p.moveSpeed; let mx = (dx/dist*s)*dt; let my = (dy/dist*s)*dt;
                if(!isBlocked(p.x+mx, p.y, p)) p.x+=mx; if(!isBlocked(p.x, p.y+my, p)) p.y+=my; 
                if(dx!==0||dy!==0) p.facing=Math.atan2(dy,dx); 
            }
        }

        game.entities.forEach(e=>{
            if(e.type === 'TRAP' && !e.triggered && Math.hypot(e.x-p.x, e.y-p.y) < 20) { e.triggered = true; e.hidden = false; e.icon = '🩸'; let dmg = 25 + game.floor * 10; p.hp -= dmg; spawnText(p.x, p.y, `陷阱! -${dmg}`, "red"); AudioSys.sfx('hit'); }
            if(e.slowTimer > 0) e.slowTimer -= dt;
            if(e.poisonTimer > 0) { e.poisonTimer -= dt; e.hp -= e.poisonDmg * dt; if(Math.random() < 0.05) spawnText(e.x, e.y, "中毒!", "#0f0"); if(e.poisonTimer <= 0) e.poisonDmg = 0; if(e.hp<=0) killEnemy(e); }
            if(e.effectTimer > 0) { 
                e.effectTimer -= dt;
                if(e.effectType === 'confused') {
                     let victim = null; let nearest = 9999; let d = Math.hypot(p.x - e.x, p.y - e.y); if (d < 150) { victim = p; nearest = d; }
                     game.entities.forEach(other => { if (other !== e && !other.dead && !other.hidden) { let d2 = Math.hypot(other.x - e.x, other.y - e.y); if (d2 < 150 && d2 < nearest) { victim = other; nearest = d2; } } });
                     if(victim && Math.random() < 0.1) { e.target = victim; let ang = Math.atan2(victim.y - e.y, victim.x - e.x); game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*250, vy:Math.sin(ang)*250, life:1.0, dmg:e.dmg, enemyProj:true}); }
                     e.vx = (Math.random()-0.5)*100; e.vy = (Math.random()-0.5)*100; let nx = e.x + e.vx * dt; let ny = e.y + e.vy * dt; if(!isBlocked(nx, ny, e)) { e.x = nx; e.y = ny; }
                }
                if(e.effectTimer <= 0) { e.effectType = null; if(e.charmed) { e.charmed = false; e.isEnemy = true; } }
            }
            if(e.isEnemy && !e.dead && !e.charmed && e.effectType !== 'confused'){
                let aggroDist = (game.floor === 1) ? 150 : 300; if (game.floor === 1 && Math.random() < 0.05) return; 
                const dist = Math.hypot(p.x-e.x,p.y-e.y); const ex = Math.floor(e.x/40), ey = Math.floor(e.y/40); const playerVisible = hasLineOfSight(ex, ey, tx, ty);
                if (e.hp < e.maxHp && !e.target) e.target = p; 
                let isFleeing = false;
                if (e.hp < e.maxHp * 0.2 && Math.random() < 0.02) { e.target = null; let ang = Math.atan2(e.y - p.y, e.x - p.x); let fleeX = Math.cos(ang) * 100 * dt; let fleeY = Math.sin(ang) * 100 * dt; if(!isBlocked(e.x + fleeX, e.y + fleeY, e)) { e.x += fleeX; e.y += fleeY; } isFleeing = true; }
                if(!isFleeing && ((playerVisible && dist < aggroDist) || e.target === p)) {
                    let stopDist = e.ranged ? (e.range || 200) * 0.8 : 45; 
                    if (dist > stopDist) { const a=Math.atan2(p.y-e.y,p.x-e.x); let currentSpeed = (e.speed || 75) * (e.slowTimer > 0 ? 0.5 : 1); let nx=e.x+Math.cos(a)*currentSpeed*dt, ny=e.y+Math.sin(a)*currentSpeed*dt; if(!isBlocked(nx,e.y, e)) e.x=nx; if(!isBlocked(e.x,ny, e)) e.y=ny; }
                    if (e.ranged && dist < (e.range || 200)) {
                        e.atkCd = (e.atkCd || 0) - dt;
                        if (e.atkCd <= 0) {
                            let ang = Math.atan2(p.y - e.y, p.x - e.x); let isArrow = e.projIcon === '➳' || e.projIcon === '🏹';
                            game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*250, vy:Math.sin(ang)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:e.projIcon, poison: e.poison, isArrow: isArrow});
                            e.atkCd = 2.0; if(e.special === 'magic') { game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang+0.3)*250, vy:Math.sin(ang+0.3)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:'🟣'}); game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang-0.3)*250, vy:Math.sin(ang-0.3)*250, life:2.0, dmg:e.dmg, enemyProj:true, icon:'🟣'}); }
                        }
                    } else if (!e.ranged && dist < 60) {
                         e.atkCd = (e.atkCd || 0) - dt;
                         if (e.atkCd <= 0) {
                             if (Math.random() < p.evasion) { spawnText(p.x, p.y-40, "閃避!", "#6d6"); } 
                             else if (Math.random() < p.blockChance) { spawnText(p.x, p.y-40, "格擋!", "#fff"); AudioSys.sfx('hit'); }
                             else {
                                 let incDmg = Math.max(1, e.dmg-p.stats.def); let hasShield = p.buffs.find(b=>b.type==='shield'); if(hasShield) { if(p.mp >= incDmg) { p.mp -= incDmg; incDmg = 0; } else { incDmg -= p.mp; p.mp = 0; } }
                                 if(incDmg > 0) { p.hp-=incDmg; AudioSys.sfx('hit'); spawnText(p.x,p.y-30,"-"+Math.floor(incDmg),"red"); if(e.poison) { p.poisonTimer = 5.0; p.poisonDmg = 5; spawnText(p.x, p.y, "中毒!", "#0f0"); } if(e.special === 'lifesteal') { e.hp = Math.min(e.maxHp, e.hp + incDmg); spawnText(e.x, e.y, "+"+incDmg, "#f00"); } } else { spawnText(p.x,p.y-30,"吸收", "#0af"); }
                             }
                             game.uiDirty=true; e.atkCd = 1.0;
                         }
                    }
                } else if (!isFleeing && !e.isBoss && !e.target && Math.random() < 0.005) { let ang = Math.random() * 6.28; e.vx = Math.cos(ang) * 20; e.vy = Math.sin(ang) * 20; e.wanderTime = 1.0 + Math.random(); }
                if(e.wanderTime > 0) { let nx = e.x + e.vx * dt; let ny = e.y + e.vy * dt; if(!isBlocked(nx, ny, e)) { e.x = nx; e.y = ny; } e.wanderTime -= dt; }
            }
            if((e.type === 'MINION' || e.charmed || e.type === 'TURRET') && !e.dead) {
                if(e.type === 'MINION' || e.type === 'TURRET') { e.life -= dt; if(e.life <= 0) e.dead = true; }
                let target = game.entities.find(t => t.isEnemy && !t.dead && !t.charmed && Math.hypot(t.x-e.x, t.y-e.y) < (e.type==='TURRET'?300:300) && game.visibleTiles[Math.floor(t.y/40)][Math.floor(t.x/40)]);
                if(e.type === 'TURRET') { 
                    if(target) {
                        e.atkCd = (e.atkCd || 0) - dt;
                        if(e.atkCd <= 0) { let ang = Math.atan2(target.y - e.y, target.x - e.x); game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*350, vy:Math.sin(ang)*350, life:1.5, dmg:15 + e.lvl*5, isFireball:true, icon:'🔥'}); e.atkCd = 0.8; }
                    }
                } else {
                    let isRangedMinion = e.name.includes('射手') || e.name.includes('巫妖') || e.name.includes('精靈');
                    if(target) { 
                        let dx = target.x - e.x, dy = target.y - e.y; let d = Math.hypot(dx,dy); let stopDist = isRangedMinion ? 150 : 30;
                        if(d > stopDist) { e.x += dx/d * 90 * dt; e.y += dy/d * 90 * dt; } else { e.atkCd = (e.atkCd || 0) - dt; if(e.atkCd <= 0) { if (isRangedMinion) { let ang = Math.atan2(target.y - e.y, target.x - e.x); game.projs.push({x:e.x, y:e.y, vx:Math.cos(ang)*300, vy:Math.sin(ang)*300, life:1.5, dmg:(e.dmg||15), isArrow: true}); } else { target.hp -= (e.dmg || 10); spawnText(target.x, target.y, (e.dmg||10), "#eee"); if(target.hp<=0) killEnemy(target); } e.atkCd = 1.0; } } 
                    } else { let dx = p.x - e.x, dy = p.y - e.y; let d = Math.hypot(dx,dy); if(d > 80) { e.x += dx/d * 100 * dt; e.y += dy/d * 100 * dt; } }
                }
            }
        });

        for(let i=game.projs.length-1;i>=0;i--){ 
            const pr=game.projs[i]; 
            if(pr.delay) { pr.delay -= dt; if(pr.delay <= 0) { pr.delay = 0; pr.life = 0.2; AudioSys.sfx('hit'); game.entities.forEach(e => { if(e.isEnemy && !e.dead && Math.hypot(e.x-pr.x, e.y-pr.y) < 60) { e.hp -= pr.dmg; spawnText(e.x, e.y, pr.dmg, "#f00"); if(e.hp<=0) killEnemy(e); } }); } continue; }
            if(pr.isStatic) { pr.life -= dt; if(pr.life<=0) game.projs.splice(i,1); else { game.entities.forEach(e => { if(e.isEnemy && !e.dead && Math.hypot(e.x-pr.x, e.y-pr.y) < 30 && Math.random() < 0.1) { e.hp -= pr.dmg; spawnText(e.x, e.y, pr.dmg, "#f60"); if(e.hp<=0) killEnemy(e); } }); } continue; }
            pr.x+=pr.vx*dt; pr.y+=pr.vy*dt; pr.life-=dt; 
            if(pr.life<=0||isSolid(pr.x,pr.y)){game.projs.splice(i,1);continue;} 
            if (pr.enemyProj) {
                if (Math.hypot(p.x - pr.x, p.y - pr.y) < 20) {
                     if (Math.random() < p.evasion) { spawnText(p.x, p.y-40, "閃避!", "#6d6"); }
                     else if (Math.random() < p.blockChance) { spawnText(p.x, p.y-40, "格擋!", "#fff"); AudioSys.sfx('hit'); }
                     else { p.hp -= Math.max(1, pr.dmg - p.stats.def); spawnText(p.x, p.y-30, "-"+Math.floor(Math.max(1, pr.dmg - p.stats.def)), "red"); if(pr.icon === '❤️') { p.confusedTimer = 4.0; spawnText(p.x, p.y-50, "魅惑!", "#f0f"); } if(pr.poison) { p.poisonTimer = 5.0; p.poisonDmg = pr.poisonDmg || 5; spawnText(p.x, p.y, "中毒!", "#0f0"); } AudioSys.sfx('hit'); game.uiDirty=true; } game.projs.splice(i,1);
                } else {
                    let hit=game.entities.find(e=>e.isEnemy && !e.dead && Math.hypot(e.x-pr.x,e.y-pr.y)<35);
                    if(hit) { let finalDmg = Math.max(1, pr.dmg - (hit.def || 0)); hit.hp-=finalDmg; spawnText(hit.x,hit.y-30,Math.floor(finalDmg), "#fff"); if(hit.hp<=0) killEnemy(hit); game.projs.splice(i,1); }
                }
            } else {
                let hit=game.entities.find(e=>e.isEnemy && !e.charmed && !e.dead && Math.hypot(e.x-pr.x,e.y-pr.y)<35); 
                if(hit){ 
                    let finalDmg = pr.dmg; if(pr.isArrow) { if(Math.random() < p.critChance) { finalDmg *= 2; spawnText(hit.x, hit.y-50, "爆擊!", "#ff0"); } if(!hit.isBoss && Math.random() < p.killChance) { finalDmg = hit.hp + 999; spawnText(hit.x, hit.y-60, "必殺!", "#f00"); } }
                    finalDmg = Math.max(1, finalDmg - (hit.def || 0)); hit.hp-=finalDmg; hit.target = p; 
                    if(pr.isIce) hit.slowTimer = 3.0; if(pr.effect === 'poison') { hit.poisonTimer = 5.0; hit.poisonDmg = pr.poisonDmg || 5; } if(pr.effect === 'confused') { hit.effectType = 'confused'; hit.effectTimer = 5.0; spawnText(hit.x, hit.y-40, "混亂!", "#f0f"); } if(pr.effect === 'charmed') { hit.effectType = 'charmed'; hit.charmed = true; hit.isEnemy = false; hit.effectTimer = 8.0; spawnText(hit.x, hit.y-40, "魅惑!", "#f66"); if(game.player.targetEntity === hit) { game.player.targetEntity = null; game.player.path = []; } }
                    if(pr.effects) { pr.effects.forEach(eff => { if(Math.random() < eff.chance) { if(eff.type === '緩速') { hit.slowTimer = eff.duration; spawnText(hit.x, hit.y-40, "緩速!", "#0af"); } if(eff.type === '暈眩') { hit.atkCd += eff.duration; spawnText(hit.x, hit.y-40, "暈眩!", "#ff0"); } if(eff.type === '中毒') { hit.poisonTimer = eff.duration; hit.poisonDmg = eff.val; spawnText(hit.x, hit.y, "中毒!", "#0f0"); } if(eff.type === '燃燒') { hit.hp -= eff.val; spawnText(hit.x, hit.y, "燃燒!", "#f60"); } } }); }
                    AudioSys.sfx('hit'); spawnText(hit.x,hit.y-30,Math.floor(finalDmg), pr.isIce?"#0af":"#fff"); if(hit.hp<=0) killEnemy(hit); game.projs.splice(i,1); 
                } 
            }
        }
        if(p.hp <= 0 && !game.dead) { handlePlayerDeath(); }
        game.cam.x+=(p.x-game.cam.x)*0.12; game.cam.y+=(p.y-game.cam.y)*0.12; 
        updateUI(); 
        
        let hover = getTargetAt(mouse.wx, mouse.wy);
        if (hover && hover.isEnemy) {
            gameCanvas.style.cursor = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' style='font-size:24px'><text y='24'>⚔️</text></svg>") 16 16, auto`;
        } else {
            gameCanvas.style.cursor = 'crosshair';
        }

        if(typeof drawMinimap === 'function') drawMinimap();
    } catch(e) { console.log(e); }
}

function drawMinimap() {
    if(!minimapCtx || !game.running) return;
    minimapCtx.fillStyle = '#000'; 
    minimapCtx.fillRect(0,0,150,150); 
    const cw = 150/60; 
    let pcx = Math.floor(game.player.x / 40);
    let pcy = Math.floor(game.player.y / 40);
    let startX = pcx - 30;
    let startY = pcy - 30;
    
    for(let dy=0; dy<60; dy++) {
        for(let dx=0; dx<60; dx++) {
            let tx = startX + dx;
            let ty = startY + dy;
            if(tx >= 0 && tx < game.mapW && ty >= 0 && ty < game.mapH) {
                if(game.visited[ty] && game.visited[ty][tx]) { 
                    if(game.map[ty][tx] === 1) minimapCtx.fillStyle = '#444'; 
                    else minimapCtx.fillStyle = '#888'; 
                    if(game.map[ty][tx] === 2) { minimapCtx.fillStyle = '#0f0'; minimapCtx.strokeStyle = '#fff'; minimapCtx.strokeRect(dx*cw, dy*cw, cw, cw); }
                    if(game.map[ty][tx] === 6) { minimapCtx.fillStyle = '#0af'; minimapCtx.strokeStyle = '#fff'; minimapCtx.strokeRect(dx*cw, dy*cw, cw, cw); }
                    minimapCtx.fillRect(dx*cw, dy*cw, cw, cw); 
                }
            }
        }
    }
    
    minimapCtx.fillStyle = '#0af'; minimapCtx.beginPath(); minimapCtx.arc(75, 75, 3, 0, Math.PI*2); minimapCtx.fill();
    
    game.entities.forEach(e => { 
        if (e.hidden) return;
        let ex = Math.floor(e.x/40);
        let ey = Math.floor(e.y/40);
        if(ex >= startX && ex < startX + 60 && ey >= startY && ey < startY + 60) {
            if(!e.dead && game.visited[ey] && game.visited[ey][ex]) { 
                let dcx = (ex - startX) * cw; 
                let dcy = (ey - startY) * cw; 
                if(e.isEnemy && !e.charmed) { minimapCtx.fillStyle = '#f00'; if(e.isBoss) { minimapCtx.fillStyle = '#a0f'; minimapCtx.beginPath(); minimapCtx.arc(dcx,dcy,4,0,Math.PI*2); minimapCtx.fill(); } else minimapCtx.fillRect(dcx-1, dcy-1, 2, 2); } 
                else if(e.type === 'CHEST') { minimapCtx.fillStyle = '#fd0'; minimapCtx.fillRect(dcx-1, dcy-1, 3, 3); } 
                else if(e.type === 'CHECKPOINT') { minimapCtx.fillStyle = '#0ff'; minimapCtx.fillRect(dcx-1, dcy-1, 4, 4); }
                else if(e.type === 'STORAGE') { minimapCtx.fillStyle = '#fa0'; minimapCtx.fillRect(dcx-1, dcy-1, 4, 4); }
                else if(e.type === 'MINION' || e.charmed || e.type === 'TURRET') { minimapCtx.fillStyle = '#0ff'; minimapCtx.fillRect(dcx-1, dcy-1, 2, 2); }
                else if(e.type === 'PORTAL_TOWN' || e.type === 'PORTAL_DUNGEON') { minimapCtx.fillStyle = '#fff'; minimapCtx.beginPath(); minimapCtx.arc(dcx,dcy,3,0,Math.PI*2); minimapCtx.fill(); } 
                else if(e.type && e.type.startsWith('NPC')) { minimapCtx.fillStyle = '#fa0'; minimapCtx.fillRect(dcx-1, dcy-1, 3, 3); }
            } 
        }
    });
}

function draw() {
    try {
        if(!game.running || !gameCtx) return;
        gameCtx.fillStyle = game.floor === 0 ? '#223322' : '#000';
        gameCtx.fillRect(0,0,gameCanvas.width,gameCanvas.height);
        gameCtx.save(); gameCtx.translate(gameCanvas.width/2-game.cam.x, gameCanvas.height/2-game.cam.y);
        for(let y=0;y<game.mapH;y++) for(let x=0;x<game.mapW;x++){
            if(Math.abs(x*40 - game.cam.x) > gameCanvas.width/2 + 60) continue; 
            if(Math.abs(y*40 - game.cam.y) > gameCanvas.height/2 + 60) continue;
            let visible = game.floor === 0 ? true : (game.visibleTiles[y] && game.visibleTiles[y][x]); 
            let visited = game.floor === 0 ? true : (game.visited[y] && game.visited[y][x]);
            if (!visible && !visited) continue; 
            const t=game.map[y][x]; 
            if (visible) {
                if(t===1){ 
                    gameCtx.fillStyle = (game.theme && game.theme.w) ? game.theme.w : '#444'; 
                    gameCtx.beginPath(); gameCtx.arc(x*40+20,y*40+20,24,0,Math.PI*2); gameCtx.fill(); 
                }
                else { 
                    if(game.floor === 0) {
                        gameCtx.fillStyle = (x%2==y%2)?'#284020':'#253a20';
                    } else {
                        gameCtx.fillStyle = (game.theme && game.theme.f) ? game.theme.f : '#222';
                    }
                    gameCtx.fillRect(x*40,y*40,40,40); gameCtx.strokeStyle='#000'; gameCtx.strokeRect(x*40,y*40,40,40); 
                    if(t===2) { gameCtx.font='22px serif'; gameCtx.fillStyle='#aaa'; gameCtx.fillText('⬇️', x*40+5,y*40+30); } 
                    if(t===6) { gameCtx.font='22px serif'; gameCtx.fillStyle='#aaa'; gameCtx.fillText('⬆️', x*40+5,y*40+30); } 
                }
            } else if (visited) {
                if(t===1){ gameCtx.fillStyle='#111'; gameCtx.beginPath(); gameCtx.arc(x*40+20,y*40+20,24,0,Math.PI*2); gameCtx.fill(); }
                else { gameCtx.fillStyle='#050505'; gameCtx.fillRect(x*40,y*40,40,40); gameCtx.strokeStyle='#111'; gameCtx.strokeRect(x*40,y*40,40,40); }
            }
        }
        game.items.forEach(i=>{ if(game.floor===0 || (game.visibleTiles[Math.floor(i.y/40)] && game.visibleTiles[Math.floor(i.y/40)][Math.floor(i.x/40)])) { gameCtx.font='22px serif'; gameCtx.fillStyle='#fd0'; gameCtx.fillText(i.type==='GOLD'?'💰':ITEM_TYPES[i.type].icon, i.x-10, i.y+5); } });
        game.entities.forEach(e=>{ 
            if(e.hidden) return;
            let ex = Math.floor(e.x/40), ey = Math.floor(e.y/40);
            if(!e.dead && (game.floor === 0 || (game.visibleTiles[ey] && game.visibleTiles[ey][ex]))){ 
                if (e.isElite) {
                    const eliteColors = ['#999', '#0f0', '#0af', '#ff0', '#f00', '#ffd700', '#a0f', '#000'];
                    let col = eliteColors[e.eliteRarity || 0];
                    gameCtx.save();
                    if (e.eliteRarity === 7) { 
                        gameCtx.shadowColor = '#fff'; gameCtx.shadowBlur = 15;
                    }
                    gameCtx.fillStyle = col; gameCtx.globalAlpha = 0.4;
                    gameCtx.beginPath(); gameCtx.arc(e.x, e.y, 25, 0, Math.PI * 2); gameCtx.fill();
                    if (e.eliteRarity === 7) { gameCtx.strokeStyle = '#fff'; gameCtx.lineWidth = 1; gameCtx.stroke(); }
                    gameCtx.restore();
                }

                gameCtx.font=(e.size?e.size+4:26)+'px serif'; gameCtx.fillText(e.icon, e.x-13,e.y+9); 
                if(e.subIcon) { gameCtx.font='14px serif'; gameCtx.fillText(e.subIcon, e.x+5, e.y+15); } 
                if(e.slowTimer > 0) { gameCtx.globalAlpha = 0.5; gameCtx.fillStyle = '#0af'; gameCtx.beginPath(); gameCtx.arc(e.x,e.y,20,0,Math.PI*2); gameCtx.fill(); gameCtx.globalAlpha = 1; } 
                if(e.effectType === 'confused') { gameCtx.font='16px serif'; gameCtx.fillText('?', e.x, e.y-30); }
                if(e.effectType === 'charmed') { gameCtx.font='16px serif'; gameCtx.fillText('❤️', e.x, e.y-30); }
                if(e.isEnemy && !e.charmed){ gameCtx.fillStyle='red'; gameCtx.fillRect(e.x-15,e.y-25,30,4); gameCtx.fillStyle='#0f0'; gameCtx.fillRect(e.x-15,e.y-25,30*(e.hp/e.maxHp),4); } 
                else { gameCtx.fillStyle='#fff'; gameCtx.font='12px serif'; gameCtx.fillText(e.name, e.x-15, e.y-25); }
                if(e.type === 'MINION' || e.charmed || e.type === 'TURRET' || e.type === 'CHECKPOINT' || e.type === 'STORAGE') { gameCtx.fillStyle='#0ff'; gameCtx.fillRect(e.x-10,e.y-20,20,3); }
            } 
        });
        if(game.player) {
            let p = game.player;
            gameCtx.save(); gameCtx.translate(p.x, p.y);
            
            // Player Aura based on Weapon Rarity
            let weapon = p.equip.mainhand;
            if (weapon && weapon.rarity.col) {
                gameCtx.shadowColor = weapon.rarity.col;
                // Shadow blur intensity
                let tier = weapon.rarity.tier || 0;
                gameCtx.shadowBlur = tier > 0 ? (tier * 4 + 5) : 0;
                // Special check for black aura (World Ender)
                if (weapon.rarity.tier === 8) { 
                    gameCtx.shadowColor = '#000'; 
                    gameCtx.shadowBlur = 15;
                    // Double stroke for visibility
                    gameCtx.strokeStyle = '#fff';
                    gameCtx.lineWidth = 1;
                    gameCtx.beginPath(); gameCtx.arc(0,0,28,0,Math.PI*2); gameCtx.stroke();
                }
            } else {
                 gameCtx.shadowBlur = 0;
            }

            gameCtx.font='32px serif'; gameCtx.fillText(p.icon, -16, 12);
            gameCtx.shadowBlur = 0; // Reset shadow

            if(p.equip.helm) { 
                gameCtx.font='16px serif'; gameCtx.fillText("🧢", -10, -18);
            }
            if(p.confusedTimer > 0) { gameCtx.font='16px serif'; gameCtx.fillText('💫', 0, -40); }
            if(p.buffs.length > 0) { gameCtx.font='10px serif'; p.buffs.forEach((b, i) => { gameCtx.fillText(b.icon, -20 + i*12, -30); }); }

            let mainHand = p.equip.mainhand; let offHand = p.equip.offhand;
            if(mainHand) {
                gameCtx.save(); let handOffset = 15;
                gameCtx.rotate(p.facing); gameCtx.translate(handOffset, 5); 
                if (p.attackAnimTimer > 0) { gameCtx.rotate(Math.sin(p.attackAnimTimer * 20) * 1.5); }
                let type = mainHand.type;
                if(type !== 'DAGGER') { gameCtx.rotate(-p.facing - Math.PI/2); if(p.attackAnimTimer > 0) gameCtx.rotate(Math.PI / 4); } else { gameCtx.rotate(Math.PI / 4); }
                let scale = ITEM_TYPES[mainHand.type].scale || 1.0;
                gameCtx.scale(scale, scale); gameCtx.font='20px serif'; gameCtx.fillStyle = mainHand.rarity.col || '#fff'; gameCtx.fillText(ITEM_TYPES[mainHand.type].icon, -10, 5); gameCtx.restore();
            }
            if(offHand) {
                gameCtx.save(); gameCtx.rotate(p.facing); gameCtx.translate(10, -5); 
                if (offHand.type === 'DAGGER' && p.attackAnimTimer > 0 && p.targetEntity && Math.hypot(p.targetEntity.x-p.x, p.targetEntity.y-p.y) < 60) { gameCtx.rotate(-Math.sin(p.attackAnimTimer * 20) * 1.5); }
                let type = offHand.type;
                if(type !== 'DAGGER' && type !== 'SHIELD') { gameCtx.rotate(-p.facing - Math.PI/2); } else if (type === 'SHIELD') { gameCtx.rotate(-p.facing - Math.PI/2); } else { gameCtx.rotate(Math.PI / 4); }
                let scale = ITEM_TYPES[offHand.type].scale || 1.0;
                gameCtx.scale(scale, scale); gameCtx.font='18px serif'; gameCtx.fillText(ITEM_TYPES[offHand.type].icon, -10, 5); gameCtx.restore();
            }
            if(p.attackAnimTimer > 0) {
                gameCtx.rotate(p.facing); gameCtx.fillStyle = 'rgba(255,255,255,0.3)'; 
                gameCtx.beginPath(); gameCtx.arc(0, 0, 50, -0.5, 0.5); gameCtx.lineTo(0,0); gameCtx.fill(); 
            }
            if(p.targetEntity) { gameCtx.strokeStyle = 'rgba(255,0,0,0.3)'; gameCtx.beginPath(); gameCtx.moveTo(0, 0); gameCtx.lineTo(p.targetEntity.x - p.x, p.targetEntity.y - p.y); gameCtx.stroke(); }
            gameCtx.restore();
        }
        game.projs.forEach(p=>{ 
            if(game.floor===0 || (game.visibleTiles[Math.floor(p.y/40)] && game.visibleTiles[Math.floor(p.y/40)][Math.floor(p.x/40)])) {
                if(p.delay) { gameCtx.fillStyle='rgba(255,0,0,0.3)'; gameCtx.beginPath(); gameCtx.arc(p.x,p.y,60,0,Math.PI*2); gameCtx.fill(); } 
                else if (p.isStatic) { gameCtx.fillStyle='rgba(255,100,0,0.6)'; gameCtx.beginPath(); gameCtx.arc(p.x,p.y,20,0,Math.PI*2); gameCtx.fill(); } 
                else { 
                    if (p.icon) { 
                        gameCtx.save(); gameCtx.translate(p.x, p.y);
                        if(p.isFireball) { gameCtx.rotate(Math.atan2(p.vy, p.vx) - Math.PI/2); } else if (p.isArrow) { gameCtx.rotate(Math.atan2(p.vy, p.vx) + Math.PI*0.75); }
                        gameCtx.font='20px serif'; gameCtx.fillText(p.icon, -10, 5); gameCtx.restore();
                    }
                    else if (p.isArrow) { gameCtx.save(); gameCtx.translate(p.x, p.y); gameCtx.rotate(Math.atan2(p.vy, p.vx)); gameCtx.font='20px serif'; gameCtx.fillText('➳', 0, 0); gameCtx.restore(); }
                    else if (p.isIce) { gameCtx.fillStyle='#0af';gameCtx.beginPath();gameCtx.arc(p.x,p.y,5,0,Math.PI*2);gameCtx.fill(); }
                    else { gameCtx.fillStyle='#fa0';gameCtx.beginPath();gameCtx.arc(p.x,p.y,5,0,Math.PI*2);gameCtx.fill(); }
                } 
            }
        });
        
        let hoverTarget = getTargetAt(mouse.wx, mouse.wy);
        let hud = document.getElementById('monster-hud');
        if (hoverTarget && hoverTarget.isEnemy) {
            hud.style.display = 'block';
            let eliteText = hoverTarget.isElite ? "<span style='color:#d0f'>(菁英)</span> " : "";
            let defText = hoverTarget.def > 0 ? ` [防${hoverTarget.def}]` : "";
            hud.innerHTML = `${eliteText}${hoverTarget.name} - HP: ${Math.floor(hoverTarget.hp)}/${hoverTarget.maxHp}${defText}`;
        } else {
            hud.style.display = 'none';
        }
        drawMinimap();
        gameCtx.restore();
    } catch(e) { console.log(e); }
}

function getTargetAt(x,y){ 
    let tx = Math.floor(x/40); let ty = Math.floor(y/40);
    if (tx<0||tx>=game.mapW||ty<0||ty>=game.mapH) return null;
    if(game.floor > 0 && (!game.visibleTiles[ty] || !game.visibleTiles[ty][tx])) return null;
    
    // FIX #4: Prioritize Enemies over friendly minions
    // Gather all entities near the mouse cursor
    let candidates = game.entities.filter(e => !e.dead && !e.hidden && Math.hypot(e.x - x, e.y - y) < 45);
    
    // Sort candidates: Enemies first, then by distance
    candidates.sort((a, b) => {
        let aIsEnemy = (a.isEnemy && !a.charmed) ? 1 : 0;
        let bIsEnemy = (b.isEnemy && !b.charmed) ? 1 : 0;
        if (aIsEnemy !== bIsEnemy) return bIsEnemy - aIsEnemy; // Enemy comes first
        
        let distA = Math.hypot(a.x - x, a.y - y);
        let distB = Math.hypot(b.x - x, b.y - y);
        return distA - distB; // Closer comes first
    });

    if (candidates.length > 0) return candidates[0];

    // Finally check for items (lowest priority)
    let i = game.items.find(i => Math.hypot(i.x - x, i.y - y) < 40);
    return i;
}

function handleDragStart(e, source, index) {
    const data = { source: source, index: index };
    e.dataTransfer.setData('application/json', JSON.stringify(data));
    e.dataTransfer.effectAllowed = "move";
}

function handleDropUnified(e, targetType, targetIndex) {
    e.preventDefault();
    const rawData = e.dataTransfer.getData('application/json');
    if (!rawData) return;
    let data;
    try { data = JSON.parse(rawData); } catch(err) { return; }
    
    const p = game.player;
    const srcType = data.source;
    const srcIdx = data.index;

    // Check hotbar spell drag
    if (data.source === 'spellbook' && targetType === 'hotbar' && targetIndex >= 4) {
        game.player.hotbar[targetIndex] = data.key;
        game.uiDirty = true; AudioSys.sfx('coin');
        return;
    }

    if (targetType === 'hotbar') {
        if (targetIndex >= 0 && targetIndex <= 3) {
            if (srcType === 'inv') {
                let it = p.inv[srcIdx];
                if (!it) return;
                if (['POTION', 'MANA_POTION', 'SCROLL_TP'].includes(it.type)) {
                    if (p.hotbar[targetIndex] && p.hotbar[targetIndex].type === it.type) { p.hotbar[targetIndex].count += (it.count || 1); } 
                    else { if(p.hotbar[targetIndex]) { alert("目標欄位已有物品"); return; } p.hotbar[targetIndex] = {type:it.type, name:it.name, count:(it.count||1)}; }
                    p.inv.splice(srcIdx, 1); game.uiDirty = true; AudioSys.sfx('coin');
                } else { alert("此欄位只能放置消耗品"); }
            } else if (srcType === 'hotbar' && srcIdx >= 0 && srcIdx <= 3) {
                let temp = p.hotbar[targetIndex]; p.hotbar[targetIndex] = p.hotbar[srcIdx]; p.hotbar[srcIdx] = temp; game.uiDirty = true; AudioSys.sfx('coin');
            }
        }
        else if (targetIndex >= 4 && targetIndex <= 7) {
             if (srcType === 'hotbar' && srcIdx >= 4 && srcIdx <= 7) {
                let temp = p.hotbar[targetIndex]; p.hotbar[targetIndex] = p.hotbar[srcIdx]; p.hotbar[srcIdx] = temp; game.uiDirty = true; AudioSys.sfx('coin');
            }
        }
    }
    
    else if (targetType === 'inv') {
        if (srcType === 'equip') { unequip(srcIdx); } 
        else if (srcType === 'shop') { buyItem(srcIdx); }
        else if (srcType === 'stash') { 
            let it = p.stash[srcIdx];
            if(p.inv.length < 40) { p.inv.push(it); p.stash.splice(srcIdx,1); game.uiDirty=true; updateStashUI(); AudioSys.sfx('coin'); }
        }
    }

    else if (targetType === 'shop-sell') {
        if (srcType === 'inv') {
            let it = p.inv[srcIdx];
            if(it) {
                p.gold += Math.floor(it.price/2); game.currentShopInventory.push(it);
                p.inv.splice(srcIdx, 1); openShop({name:'商人', type:'NPC_GENERAL'}); game.uiDirty = true; AudioSys.sfx('coin');
            }
        }
    }
    
    else if (targetType === 'equip') {
        if (srcType === 'inv') { let it = p.inv[srcIdx]; if(it) p.equipItem(it, srcIdx, targetIndex); }
        else if (srcType === 'stash') {
             // Drag from stash to equip
             let it = p.stash[srcIdx];
             if(it) {
                 // Check if it can be equipped
                 let slot = targetIndex || ITEM_TYPES[it.type].slot;
                 if(slot) {
                    if (p.equipItem(it, null, slot)) { 
                        p.stash.splice(srcIdx, 1);
                        updateStashUI();
                    }
                 }
             }
        }
    }

    else if (targetType === 'stash') {
        if (srcType === 'inv') {
             let it = p.inv[srcIdx];
             if(p.stash.length < 100) { p.stash.push(it); p.inv.splice(srcIdx,1); game.uiDirty=true; updateStashUI(); AudioSys.sfx('coin'); }
             else alert("儲藏室已滿");
        } else if (srcType === 'equip') {
             // Drag from equip to stash
             let it = p.equip[srcIdx];
             if (p.stash.length < 100) { p.stash.push(it); p.equip[srcIdx] = null; p.recalc(); game.uiDirty=true; updateStashUI(); AudioSys.sfx('coin'); }
             else alert("儲藏室已滿");
        }
    }
}

function renderSpellBook() {
    let g = document.getElementById('spell-grid'); g.innerHTML = '';
    const categories = { 'ATK': '攻擊系', 'REC': '回復系', 'EFF': '效果/召喚', 'SUP': '輔助系' };
    let grouped = {};
    Object.keys(game.player.spells).forEach(k => {
        let s = SPELLS[k]; let cat = s.cat || 'SUP';
        if(s.type === 'buff') cat = 'SUP'; 
        if(!grouped[cat]) grouped[cat] = [];
        grouped[cat].push(k);
    });
    
    Object.keys(grouped).forEach(cat => {
        let header = document.createElement('div'); header.className = 'spell-category'; header.innerText = categories[cat] || '其他'; g.appendChild(header);
        grouped[cat].forEach(k => {
            let d = document.createElement('div'); d.className = 'spell-icon'; 
            d.innerHTML = `${SPELLS[k].icon}<div class="s-name">${SPELLS[k].name}</div>`;
            let lv = document.createElement('div'); lv.className = 'spell-lvl'; lv.innerText = game.player.spells[k];
            d.appendChild(lv); d.draggable = true;
            d.ondragstart = (e) => { e.dataTransfer.setData('application/json', JSON.stringify({ source: 'spellbook', key: k })); };
            d.onclick = () => { game.player.activeSpell = k; game.uiDirty = true; };
            d.oncontextmenu = (e) => {
                e.preventDefault();
                for(let i=4; i<8; i++) { if(!game.player.hotbar[i]) { game.player.hotbar[i] = k; game.uiDirty=true; return; } }
                game.player.hotbar[4] = k; game.uiDirty=true;
            };
            d.onmouseenter = (e) => showSpellTip(k, e, true); d.onmouseleave = hideTip; g.appendChild(d);
        });
    });
}

function handleDropToWorld(e) { 
    e.preventDefault();
    const rawData = e.dataTransfer.getData('application/json'); if(!rawData) return;
    try {
        const data = JSON.parse(rawData);
        if(data.source === 'inv') {
            const it = game.player.inv[data.index];
            game.items.push({...it, x:game.player.x, y:game.player.y});
            game.player.inv.splice(data.index, 1); game.uiDirty = true;
        }
    } catch(e) {}
}

function buyItem(idx) { 
    // FIX #2: Remove item from shop after purchase
    let it = game.shopItems[idx]; 
    if(game.player.gold >= it.price && game.player.inv.length < 40){ 
        game.player.gold -= it.price; 
        game.player.inv.push(JSON.parse(JSON.stringify(it))); 
        
        // Remove from inventory list
        game.currentShopInventory.splice(idx, 1);
        // Refresh shop UI immediately
        openShop(game.activeShopNPC); 
        
        game.uiDirty=true; 
        AudioSys.sfx('coin'); 
    } else { 
        alert('金幣不足或背包已滿'); 
    } 
}

function handleShopDragStart(e, idx) { handleDragStart(e, 'shop', idx); }
function killEnemy(e){ 
    if(e.dead) return;
    e.dead=true; AudioSys.sfx('die'); 
    let xpReq = 100 * Math.pow(2.0, game.player.lvl-1); 
    let levelDiff = Math.max(0, game.player.lvl - (e.lvl||1));
    let xpMult = Math.max(0.1, 1.0 - levelDiff * 0.2);
    let xpGain = (30 + (e.maxHp/3)) * xpMult;
    game.player.xp += xpGain; 
    spawnText(e.x, e.y, "+"+Math.floor(xpGain)+" XP", "#0af"); 
    if(game.player.xp >= xpReq){ game.player.lvl++; game.player.xp=0; game.player.pts+=5; game.player.hp = game.player.maxHp; game.player.mp = game.player.maxMp; game.player.recalc(); AudioSys.sfx('level'); spawnText(game.player.x, game.player.y, "升級!", "#fd0"); } 
    game.items.push({x:e.x,y:e.y,type:'GOLD',val:randInt(15,40), isItem:true}); 
    
    // FIX #3: Lower drop rate (0.30 -> 0.08)
    if(e.isElite) { 
        game.items.push(new ItemClass(game.floor, e.x, e.y, true)); spawnText(e.x, e.y - 20, "菁英掉落!", "#d0f"); 
    } else if(Math.random()<0.08 || e.isBoss) { // Reduced from 0.30 to 0.08
        game.items.push(new ItemClass(game.floor,e.x,e.y)); 
    }
    
    if(e.isBoss) { spawnText(e.x, e.y, "BOSS 擊殺！", "#f0f"); let bx = Math.floor(e.x/40), by = Math.floor(e.y/40); game.map[by][bx] = 2; } 
    game.uiDirty = true; 
}
function openChest(e) { if(e.dead) return; e.dead = true; e.icon = '📭'; if (e.trapped) { let dmg = 50 + game.floor * 10; game.player.hp -= dmg; spawnText(game.player.x, game.player.y, `爆炸! -${dmg}`, "red"); AudioSys.sfx('hit'); game.projs.push({x:e.x, y:e.y, vx:0, vy:0, life:0.5, dmg:0, isStatic:true, icon:'💥'}); } else { AudioSys.sfx('coin'); spawnText(e.x, e.y, "開啟寶箱!", "#fd0"); } game.items.push({x:e.x,y:e.y,type:'GOLD',val:randInt(50,150), isItem:true}); game.items.push(new ItemClass(game.floor,e.x,e.y)); game.items.push(new ItemClass(game.floor,e.x+10,e.y)); }
function interactCheckpoint(e) {
    if(e.dead) return;
    game.checkpoint = {
        floor: game.floor, x: game.player.x, y: game.player.y, stats: game.player.stats, baseStats: game.player.baseStats,
        lvl: game.player.lvl, xp: game.player.xp, raceKey: game.player.raceKey, gender: game.player.gender,
        gold: game.player.gold, inv: game.player.inv, stash: game.player.stash, equip: game.player.equip,
        spells: game.player.spells, hotbar: game.player.hotbar, timestamp: Date.now(), mapW: game.mapW, mapH: game.mapH
    };
    localStorage.setItem('inf_checkpoint', JSON.stringify(game.checkpoint));
    spawnText(e.x, e.y - 40, "進度已保存!", "#0ff"); AudioSys.sfx('level');
}

function pickup(it){ 
    if(it.type==='GOLD') { game.player.gold+=it.val; AudioSys.sfx('coin'); game.items=game.items.filter(x=>x!==it); game.uiDirty=true; return; } 
    const stackables = ['POTION','MANA_POTION','SCROLL_TP'];
    if(stackables.includes(it.type)) {
        for(let i=0; i<4; i++) { if(game.player.hotbar[i] && game.player.hotbar[i].type === it.type) { game.player.hotbar[i].count += (it.count || 1); spawnText(game.player.x, game.player.y, `${it.name} x${it.count||1} (快捷)`, "#fff"); game.items = game.items.filter(x=>x!==it); AudioSys.sfx('coin'); game.uiDirty = true; return; } }
        for(let i=0; i<4; i++) { if(!game.player.hotbar[i]) { game.player.hotbar[i] = {type:it.type, name:it.name, count:(it.count||1)}; spawnText(game.player.x, game.player.y, `${it.name} (快捷)`, "#fff"); game.items = game.items.filter(x=>x!==it); AudioSys.sfx('coin'); game.uiDirty = true; return; } }
        let existing = game.player.inv.find(x => x.type === it.type);
        if(existing) { existing.count = (existing.count || 1) + (it.count || 1); spawnText(game.player.x, game.player.y, `${it.name} x${it.count||1}`, "#fff"); game.items = game.items.filter(x=>x!==it); AudioSys.sfx('coin'); game.uiDirty = true; return; }
    }
    if(game.player.inv.length >= 40) { spawnText(game.player.x, game.player.y, "背包已滿!", "#f55"); return; } 
    if(!it.count) it.count = 1; game.player.inv.push(it); AudioSys.sfx('coin'); game.items=game.items.filter(x=>x!==it); game.uiDirty=true; 
}
function attack(e){ 
    if(game.player.atkCd > 0) return; 
    let p=game.player; 
    let mainHand = p.equip.mainhand; let offHand = p.equip.offhand;
    let dist = Math.hypot(e.x - p.x, e.y - p.y);
    let weapon = mainHand; let useDagger = false;
    if (mainHand && (mainHand.type === 'BOW' || mainHand.type === 'CROSSBOW')) { if (dist < 60) { if (offHand && offHand.type === 'DAGGER') { useDagger = true; weapon = offHand; } else { spawnText(p.x, p.y-30, "太近了(需匕首)", "#aaa"); return; } } }
    let isRanged = mainHand && (mainHand.type === 'BOW' || mainHand.type === 'CROSSBOW') && !useDagger;
    if(isRanged) AudioSys.sfx('step'); else AudioSys.sfx('hit');
    let speed = weapon ? (ITEM_TYPES[weapon.type].speed || 0.5) : 0.4;
    p.atkCd = speed; p.attackAnimTimer = 0.2; 
    
    // Calculate Effects to apply
    let effectsToApply = [];
    for(let key in p.equip) { 
        if(p.equip[key] && p.equip[key].effects) { 
            p.equip[key].effects.forEach(eff => { effectsToApply.push(eff); });
        } 
    }

    if(isRanged) { 
        let ang = Math.atan2(e.y - p.y, e.x - p.x); 
        // Pass effects to projectile
        game.projs.push({
            x:p.x, y:p.y, vx:Math.cos(ang)*400, vy:Math.sin(ang)*400, life:1.5, dmg:p.stats.atk, isArrow:true, 
            effects: effectsToApply
        }); 
    } 
    else if(e) { 
        let dmg = p.stats.atk;
        if (useDagger) { let rangedAtk = (mainHand && mainHand.stats.atk) || 0; let daggerAtk = (offHand && offHand.stats.atk) || 0; dmg = Math.max(1, p.stats.atk - rangedAtk + Math.floor(daggerAtk * 0.5)); }
        if(Math.random() < p.critChance) { dmg *= 2; spawnText(e.x, e.y-40, "爆擊!", "#ff0"); }
        if(!e.isBoss && Math.random() < p.killChance) { dmg = 9999; spawnText(e.x, e.y-50, "必殺!", "#f00"); }
        let actualDmg = Math.max(1, dmg - (e.def || 0)); e.hp -= actualDmg; spawnText(e.x, e.y-20, Math.floor(actualDmg), "#fff"); 
        
        // Apply effects immediately for melee
        effectsToApply.forEach(eff => {
             if(Math.random() < eff.chance) {
                 if(eff.type === '緩速') { e.slowTimer = eff.duration; spawnText(e.x, e.y-40, "緩速!", "#0af"); }
                 if(eff.type === '暈眩') { e.atkCd += eff.duration; spawnText(e.x, e.y-40, "暈眩!", "#ff0"); }
                 if(eff.type === '中毒') { e.poisonTimer = eff.duration; e.poisonDmg = eff.val; spawnText(e.x, e.y, "中毒!", "#0f0"); }
                 if(eff.type === '燃燒') { e.hp -= eff.val; spawnText(e.x, e.y, "燃燒!", "#f60"); }
             }
        });

        if(e.hp<=0) killEnemy(e); 
    } 
}

function useHotbar(idx) {
    if(idx >= 0 && idx <= 3) { 
        let item = game.player.hotbar[idx];
        if(item && item.count > 0) {
            if(item.type === 'POTION') game.player.hp = Math.min(game.player.maxHp, game.player.hp + 50);
            if(item.type === 'MANA_POTION') game.player.mp = Math.min(game.player.maxMp, game.player.mp + 50);
            if(item.type === 'SCROLL_TP') useTownPortal(false);
            item.count--; if(item.count <= 0) game.player.hotbar[idx] = null; game.uiDirty = true; AudioSys.sfx('coin');
        }
    } else if(idx >= 4 && idx <= 7) { 
        let spellKey = game.player.hotbar[idx]; if(spellKey) { game.player.activeSpell = spellKey; game.uiDirty = true; }
    }
}

function unequip(s){ let p=game.player; if(p.equip[s] && p.inv.length < 40){ p.inv.push(p.equip[s]); p.equip[s]=null; p.recalc(); game.uiDirty=true; } }
function addStat(s){ if(game.player.pts>0){ game.player.baseStats[s]++; game.player.pts--; game.player.recalc(); game.uiDirty=true; } }
function toggleInventory(){ let w=document.getElementById('inventory-window'); w.style.display=w.style.display==='flex'?'none':'flex'; game.uiDirty=true; if(w.style.display==='none') document.getElementById('tooltip').style.display='none'; document.getElementById('shop-window').style.display='none'; document.getElementById('spellbook-window').style.display='none'; document.getElementById('stash-window').style.display='none'; }
function toggleSpellBook(){ let w=document.getElementById('spellbook-window'); w.style.display=w.style.display==='block'?'none':'block'; if(w.style.display==='block') renderSpellBook(); else document.getElementById('tooltip').style.display='none'; }
function toggleStash(){ 
    let w=document.getElementById('stash-window'); 
    if(w.style.display === 'flex') { w.style.display='none'; } 
    else { 
        w.style.display='flex'; 
        let inv = document.getElementById('inventory-window'); if(inv.style.display !== 'flex') inv.style.display = 'flex';
        updateStashUI();
    }
}
function updateStashUI() {
    const p=game.player; const g=document.getElementById('stash-grid'); g.innerHTML='';
    p.stash.forEach((it,i)=>{ 
        const el=document.createElement('div'); el.className='inv-slot'; 
        el.style.borderColor = (it.rarity && it.rarity.col) ? it.rarity.col : '#fff';
        let content = it.type==='SPELL_BOOK'?'📘':(it.type==='HELM'?`<img src="${HELM_ICON_SRC}" style="width:32px;height:32px;">`:ITEM_TYPES[it.type].icon); 
        if(it.count > 1) content += `<span class="inv-qty">${it.count}</span>`;
        el.innerHTML = content; el.draggable=true; 
        el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; 
        el.ondragstart=(e)=>handleDragStart(e, 'stash', i);
        el.ondblclick=()=>{ if(p.inv.length<40) { p.inv.push(it); p.stash.splice(i,1); updateStashUI(); game.uiDirty=true; AudioSys.sfx('coin'); } };
        g.appendChild(el); 
    });
}

function openShop(t){ 
    game.shopOpen=t; game.activeShopNPC = t; // Store active shop NPC
    document.getElementById('shop-window').style.display='flex'; document.getElementById('shop-title').innerText = t.name + "的商店"; 
    let inv = document.getElementById('inventory-window'); if(inv.style.display !== 'flex') inv.style.display = 'flex';
    let s=document.getElementById('shop-items'); s.innerHTML=''; game.shopItems = game.currentShopInventory; 
    game.shopItems.forEach((it, i) => {
        let d=document.createElement('div'); d.className='shop-item'; d.draggable=true; d.ondragstart=(e)=>handleShopDragStart(e, i); d.ondblclick=()=>buyItem(i); d.onmouseenter=(e)=>showTip(it,e); d.onmouseleave=hideTip; 
        d.innerHTML=`<span style="color:${it.rarity.col}">${ITEM_TYPES[it.type].icon} ${it.name}</span><span>${it.price} G</span>`; s.appendChild(d); 
    });
}
function closeShop(){ game.shopOpen=null; game.activeShopNPC = null; document.getElementById('shop-window').style.display='none'; document.getElementById('tooltip').style.display='none'; }
function updateUI() { 
    const p=game.player; if(!p)return; 
    document.getElementById('hp-fill').style.height=(Math.max(0, p.hp)/p.maxHp*100)+'%'; document.getElementById('hp-text').innerText=Math.floor(Math.max(0, p.hp)); 
    document.getElementById('mp-fill').style.height=(Math.max(0, p.mp)/p.maxMp*100)+'%'; document.getElementById('mp-text').innerText=Math.floor(Math.max(0, p.mp)); 
    document.getElementById('xp-bar-fill').style.width=(Math.min(100, (p.xp / (100 * Math.pow(2.0, p.lvl-1))) * 100))+'%'; document.getElementById('ui-level').innerText=p.lvl; 
    for(let i=0; i<4; i++) { let it = p.hotbar[i]; document.getElementById(`hb-icon-${i}`).innerText = it ? ITEM_TYPES[it.type].icon : ""; document.getElementById(`hb-qty-${i}`).innerText = (it && it.count > 1) ? it.count : ""; }
    
    // Spell hotbar updates
    for(let i=4; i<8; i++) { 
        let sk = p.hotbar[i]; 
        let el = document.getElementById(`slot-spell-${i-4}`); 
        document.getElementById(`hb-icon-${i}`).innerText = sk ? SPELLS[sk].icon : ""; 
        document.getElementById(`hb-lvl-${i}`).innerText = sk ? `Lv${p.spells[sk]}` : ""; 
        if(p.activeSpell === sk && sk) el.classList.add('active-spell'); else el.classList.remove('active-spell'); 
        
        // FIX: Visual feedback for spell cooldown
        if(sk && p.cooldowns[sk] > 0) { el.style.opacity = '0.4'; } else { el.style.opacity = '1.0'; }
    }
    
    if(p.activeSpell) {
        document.getElementById('active-spell-icon').innerText = SPELLS[p.activeSpell].icon;
        // Also dim main button
        if(p.cooldowns[p.activeSpell] > 0) document.getElementById('spell-btn').style.opacity = '0.4'; 
        else document.getElementById('spell-btn').style.opacity = '1.0';
    } else {
        document.getElementById('active-spell-icon').innerText = "🚫";
    }

    if(game.uiDirty) updateInventoryUI(); 
}
function updateInventoryUI() { 
    const p=game.player; const g=document.getElementById('inventory-grid'); g.innerHTML=''; 
    p.inv.forEach((it,i)=>{ 
        const el=document.createElement('div'); el.className='inv-slot'; el.style.borderColor = (it.rarity && it.rarity.col) ? it.rarity.col : '#fff';
        let content = it.type==='SPELL_BOOK'?'📘':(it.type==='HELM'?`<img src="${HELM_ICON_SRC}" style="width:32px;height:32px;">`:ITEM_TYPES[it.type].icon); 
        if(it.count > 1) content += `<span class="inv-qty">${it.count}</span>`;
        el.innerHTML = content; el.draggable=true; el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; el.ondragstart=(e)=>handleDragStart(e, 'inv', i); el.ondblclick=()=>p.equipItem(it,i); g.appendChild(el); 
    }); 
    ['str','dex','mag','vit'].forEach(k=>{ document.getElementById('stat-'+k).innerText=p.stats[k]; let btn = document.getElementById('plus-'+k); btn.onclick = null; if(p.pts>0) { btn.classList.add('active'); btn.onclick = () => addStat(k); } else { btn.classList.remove('active'); } }); 
    document.getElementById('stat-hpregen').innerText = p.regenInfo ? p.regenInfo.hp.toFixed(1) : 0; document.getElementById('stat-mpregen').innerText = p.regenInfo ? p.regenInfo.mp.toFixed(1) : 0; 
    document.getElementById('stat-points').innerText=p.pts; document.getElementById('stat-atk').innerText=p.stats.atk; document.getElementById('stat-def').innerText=p.stats.def; 
    document.getElementById('stat-crit').innerText=Math.floor(p.critChance*100); document.getElementById('stat-kill').innerText=(p.killChance*100).toFixed(1); 
    document.getElementById('stat-block').innerText=Math.floor(p.blockChance*100); document.getElementById('stat-evade').innerText=Math.floor(p.evasion*100);
    document.getElementById('ui-gold-inv').innerText=p.gold; document.getElementById('inv-count').innerText=p.inv.length; 
    for(let k in p.equip){ 
        let el=document.getElementById('slot-'+k), it=p.equip[k]; 
        if(it){
            if(k==='helm') el.innerHTML = `<img src="${HELM_ICON_SRC}" style="width:32px;height:32px;">`; else el.innerText=ITEM_TYPES[it.type].icon;
            let rCol = (it.rarity && it.rarity.col) ? it.rarity.col : '#fff'; el.style.borderColor = rCol; el.classList.add('equipped'); el.onmouseenter=(e)=>showTip(it,e); el.onmouseleave=hideTip; el.draggable = true; el.ondragstart = (e) => handleDragStart(e, 'equip', k);
        } else {
            el.innerText='';el.style.borderColor='#444';el.classList.remove('equipped'); el.onmouseenter=null; el.draggable = false;
            if(k==='helm') el.innerHTML = '<span class="doll-label">頭部</span>'; if(k==='gloves') el.innerHTML = '<span class="doll-label">手套</span>';
        } 
    } 
    game.uiDirty=false; 
}
function showTip(it,e){ let t=document.getElementById('tooltip'); t.style.display='block'; let left = e.clientX + 15; let top = e.clientY + 15; if (left + 240 > window.innerWidth) left = e.clientX - 250; if (top + 150 > window.innerHeight) top = window.innerHeight - 160; t.style.left=left+'px'; t.style.top=top+'px'; document.getElementById('tip-title').innerText=it.name; document.getElementById('tip-title').style.color=it.rarity.col; 
    let statsText = ''; 
    if(it.type === 'SPELL_BOOK') statsText = '點擊兩下以學習/升級'; else if (['POTION','MANA_POTION','SCROLL_TP'].includes(it.type)) { statsText = '消耗品 (可放置於快捷列 1-4)'; if(it.count > 1) statsText += `\n數量: ${it.count}`; } 
    else { statsText = `等級: ${it.lvl}\n售價: ${it.price}G\n`; if(it.stats.atk) statsText += `攻擊: +${it.stats.atk}\n`; if(it.stats.def) statsText += `防禦: +${it.stats.def}\n`; if(it.stats.mag) statsText += `魔力: +${it.stats.mag}\n`; if(it.stats.str) statsText += `力量: +${it.stats.str}\n`; if(it.stats.vit) statsText += `體質: +${it.stats.vit}\n`; if(it.effects && it.effects.length > 0) { statsText += `\n[特效]:\n`; it.effects.forEach(ef => { statsText += `- ${ef.type} (${Math.floor(ef.chance*100)}%)\n`; }); } } document.getElementById('tip-body').innerText=statsText; }
function showSpellTip(idOrKey, e, isKey=false) {
    let key = isKey ? idOrKey : game.player.hotbar[idOrKey]; if(!key) return;
    let s = SPELLS[key]; let lvl = game.player.spells[key] || 1;
    let t=document.getElementById('tooltip'); t.style.display='block'; let left = e.clientX + 15; let top = e.clientY + 15; if (left + 240 > window.innerWidth) left = e.clientX - 250; if (top + 150 > window.innerHeight) top = window.innerHeight - 160; t.style.left=left+'px'; t.style.top=top+'px'; document.getElementById('tip-title').innerText=s.name + ` (Lv.${lvl})`; document.getElementById('tip-title').style.color='#0af';
    let minDmg = Math.floor(s.dmgBase + s.dmgLvl * lvl); let maxDmg = Math.floor(minDmg * 1.5); let cost = s.cost + lvl * 2;
    let txt = `類型: ${s.cat === 'ATK' ? '攻擊' : (s.cat === 'REC' ? '回復' : (s.cat === 'EFF' ? '效果' : '輔助'))}\n消耗: ${cost} MP\n`;
    if(s.cat === 'ATK') txt += `傷害: ${minDmg} ~ ${maxDmg}\n`; txt += `冷卻: ${s.cd}秒\n\n`; txt += s.desc; document.getElementById('tip-body').innerText=txt;
}
function hideTip(){ document.getElementById('tooltip').style.display='none'; }
function castSpell(){ 
    let p=game.player; if(!p.activeSpell)return; 
    
    // FIX: Check individual cooldown
    if (p.cooldowns[p.activeSpell] > 0) { 
        spawnText(p.x, p.y-50, "冷卻中...", "#888");
        return; 
    }

    let s=SPELLS[p.activeSpell]; let lvl = p.spells[p.activeSpell]; let cost = s.cost + lvl*2; 
    if(p.mp>=cost){ 
        p.mp-=cost; AudioSys.sfx('magic'); 
        
        // FIX: Set individual spell cooldown instead of global atkCd
        p.cooldowns[p.activeSpell] = s.cd;
        
        // Mobile Aiming Logic: If using mouse/touch coordinates that are 0, use player direction
        let a;
        if (mouse.wx === 0 && mouse.wy === 0) {
            a = p.facing;
        } else {
            a = Math.atan2(mouse.wy-p.y,mouse.wx-p.x);
        }

        let powerMin = s.dmgBase + s.dmgLvl * lvl; let powerMax = powerMin * 1.5; let dmg = randInt(powerMin, powerMax); 
        if (s.cat === 'ATK') {
            if(s.type === 'projectile') { let pDmg = (s.effect === 'poison') ? (5 + lvl) : 0; game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*380,vy:Math.sin(a)*380,life:1.8,dmg:dmg, isIce: s.effect==='slow', effect:s.effect, isFireball: s.icon==='🔥', icon: s.icon, poisonDmg: pDmg}); } 
            else if (s.type === 'multishot') { for(let i=-1; i<=1; i++) { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a+i*0.3)*300,vy:Math.sin(a+i*0.3)*300,life:1.0,dmg:dmg}); } } 
            else if (s.type === 'aoe') { game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:99, delay: 1.0, dmg:dmg*2}); } 
            else if (s.type === 'aoe_instant') { game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:0.5, dmg:dmg, isStatic:true, icon:'⚡'}); }
        }
        else if (s.cat === 'REC') {
            if(s.name === '治癒術') { p.hp = Math.min(p.maxHp, p.hp + dmg); spawnText(p.x, p.y, `+${Math.floor(dmg)}`, "#0f0"); }
            if(s.name === '再生術') { let regVal = 5 + lvl; p.buffs.push({type:'regen', time:15, val: regVal, icon:'🌿'}); spawnText(p.x, p.y, "再生", "#0f0"); }
            if(s.name === '淨化') { p.poisonTimer=0; p.slowTimer=0; p.confusedTimer=0; spawnText(p.x, p.y, "淨化", "#fff"); }
            if(s.name === '神聖之光') { p.hp = p.maxHp; spawnText(p.x, p.y, "全癒", "#ffd700"); }
            if(s.name === '魔力轉換') { let costHP = p.maxHp*0.2; if(p.hp > costHP) { p.hp -= costHP; p.mp = Math.min(p.maxMp, p.mp + p.maxMp*0.5); spawnText(p.x, p.y, "轉換", "#00f"); } }
        }
        else if (s.cat === 'EFF') {
            if(s.type === 'summon') {
                if(s.sumType === 'HYDRA') { game.entities.push({x:mouse.wx, y:mouse.wy, type:'TURRET', hp:200+lvl*50, life:20, icon:'🐲', name:s.name, dead:false, lvl: lvl}); spawnText(mouse.wx, mouse.wy, "砲塔召喚!", "#fa0"); } 
                else { let icon = s.sumType==='GOLEM'?'🗿':'💀'; let hp = s.sumType==='GOLEM'?200:50; let minionDmg = 10 + lvl * 2; game.entities.push({x:p.x+20, y:p.y, type:'MINION', hp:hp+lvl*20, dmg: minionDmg, life:40, icon:icon, name:s.name, dead:false, lvl: lvl}); spawnText(p.x, p.y, "召喚!", "#aaa"); }
            }
            else if(s.type === 'ground') { game.projs.push({x:mouse.wx, y:mouse.wy, vx:0, vy:0, life:8.0, dmg:dmg*0.5, isStatic:true}); }
            else if(s.type === 'debuff') { game.projs.push({x:p.x,y:p.y,vx:Math.cos(a)*300,vy:Math.sin(a)*300,life:1.8,dmg:0, effect:s.effect}); }
        }
        else if (s.type === 'buff') { let dur = 20 + lvl*5; p.buffs.push({type:s.buff, time:dur, icon:s.icon}); p.recalc(); spawnText(p.x, p.y, "強化!", "#ff0"); }
    } else { spawnText(p.x, p.y, "魔力不足!", "#00f"); } 
}

function useTownPortal(isDungeon) {
    if(!isDungeon) { if(game.floor === 0) { spawnText(game.player.x, game.player.y, "已在城鎮中", "#fff"); return; } AudioSys.sfx('portal'); game.dungeonCache = { floor: game.floor, x: game.player.x, y: game.player.y }; game.savedPlayerPos = { x: 50*40+20, y: 50*40+20 }; game.floor = 0; genFloor(0); spawnText(game.player.x, game.player.y, "回城卷軸!", "#0af"); } 
    else { if(!game.dungeonCache) { spawnText(game.player.x, game.player.y, "傳送門已失效", "#aaa"); return; } AudioSys.sfx('portal'); game.floor = game.dungeonCache.floor; game.savedPlayerPos = { x: game.dungeonCache.x, y: game.dungeonCache.y }; genFloor(game.floor); }
    game.cam.x = game.player.x; game.cam.y = game.player.y; game.player.path = [];
}

function interactNPC(npc) {
    if (npc.type === 'NPC_GENERAL') openShop(npc);
    else if (npc.type === 'NPC_ELDER') spawnText(npc.x, npc.y - 30, "長老: 歡迎回來，英雄。", "#ffd700");
    else if (npc.type === 'NPC_ADVENTURER') spawnText(npc.x, npc.y - 30, "冒險者: 聽說這裡很危險，小心點。", "#fff");
}

function handlePlayerDeath() {
    game.dead = true; document.getElementById('death-screen').style.display = 'flex';
    const cpBtn = document.getElementById('btn-checkpoint'); const savedCp = localStorage.getItem('inf_checkpoint');
    if (savedCp) { cpBtn.style.display = 'inline-block'; try { const cpData = JSON.parse(savedCp); cpBtn.innerText = `從 ${cpData.floor}F 安全區復活`; } catch(e) { cpBtn.style.display = 'none'; } } else { cpBtn.style.display = 'none'; }
    AudioSys.sfx('die');
}

function resurrect(type) {
    let p = game.player; p.poisonTimer = 0; p.slowTimer = 0; p.confusedTimer = 0; p.buffs = [];
    // Reset cooldowns on resurrect
    p.cooldowns = {}; 
    
    if (type === 'town') {
        p.inv = []; p.stash = []; p.equip = { helm:null, necklace:null, earring1:null, earring2:null, armor:null, mainhand:null, offhand:null, ring1:null, ring2:null, pants:null, boots:null, gloves:null };
        p.hp = p.maxHp; p.mp = p.maxMp; p.recalc(); game.dungeonCache = null; game.savedPlayerPos = null; game.floor = 0; genFloor(0); game.cam.x = p.x; game.cam.y = p.y; 
    } else if (type === 'checkpoint') {
        const savedCp = localStorage.getItem('inf_checkpoint');
        if(savedCp) {
            let d = JSON.parse(savedCp);
            game.player.stats = d.stats; game.player.baseStats = d.baseStats; game.player.lvl = d.lvl; game.player.xp = d.xp; game.player.gold = d.gold; game.player.inv = d.inv; game.player.stash = d.stash || []; game.player.equip = d.equip; game.player.spells = d.spells; game.player.hotbar = d.hotbar;
            game.player.hp = game.player.maxHp; game.player.mp = game.player.maxMp; game.player.recalc();
            game.floor = d.floor; game.savedPlayerPos = { x: d.x, y: d.y };
            genFloor(game.floor); game.cam.x = d.x; game.cam.y = d.y;
        }
    }
    game.dead = false; document.getElementById('death-screen').style.display = 'none'; game.uiDirty = true;
}
function showMainMenu(){ document.getElementById('char-create').style.display='none'; document.getElementById('main-menu').style.display='block'; document.getElementById('start-screen').style.display='flex'; document.getElementById('death-screen').style.display='none'; game.dead=false; game.running=false; }
function showCharCreate(){ document.getElementById('main-menu').style.display='none'; document.getElementById('char-create').style.display='flex'; }
function openGuide() { document.getElementById('guide-modal').style.display='block'; }
function closeGuide() { document.getElementById('guide-modal').style.display='none'; }
function saveGame(){ if(!game.player) return; const saveObj = { stats: game.player.stats, baseStats: game.player.baseStats, lvl: game.player.lvl, xp: game.player.xp, raceKey: game.player.raceKey, gender: game.player.gender, gold: game.player.gold, floor: game.floor, inv: game.player.inv, stash: game.player.stash, equip: game.player.equip, spells: game.player.spells, hotbar: game.player.hotbar }; localStorage.setItem('inf_save_v10', JSON.stringify(saveObj)); alert('遊戲已存檔'); }
function tryLoadGame(){ 
    let d=JSON.parse(localStorage.getItem('inf_save_v10')); 
    if(!d) return alert('無存檔紀錄'); 
    selRace=d.raceKey; selGender=d.gender||'MALE'; startGame(); 
    game.player.lvl = d.lvl; game.player.xp = d.xp; game.player.gold = d.gold; game.player.baseStats = d.baseStats || RACES[selRace].stats; 
    game.player.inv = d.inv || []; game.player.stash = d.stash || []; game.player.equip = d.equip || {}; game.player.spells = d.spells || {}; game.player.hotbar = d.hotbar || new Array(8).fill(null); 
    game.player.cooldowns = {}; // Reset CDs on load
    const sKeys = Object.keys(game.player.spells); game.player.activeSpell = sKeys.length > 0 ? sKeys[0] : null; 
    game.floor = (typeof d.floor === 'number') ? d.floor : 0; genFloor(game.floor); game.player.recalc(); game.uiDirty = true; 
}
function selectRace(k,b){ selRace=k; document.querySelectorAll('.race-btn').forEach(btn=>btn.classList.remove('selected')); if(b) b.classList.add('selected'); let r=RACES[k]; document.getElementById('preview-race').innerText=r.name; document.getElementById('preview-desc').innerText=r.desc; ['str','dex','mag','vit'].forEach(s=>document.getElementById('bar-'+s).style.width=(r.stats[s]*10)+'%'); updatePreviewIcon(); }
function selectGender(g){ selGender=g; document.getElementById('btn-male').className = g==='MALE'?'gender-btn selected':'gender-btn'; document.getElementById('btn-female').className = g==='FEMALE'?'gender-btn selected':'gender-btn'; updatePreviewIcon(); }
function updatePreviewIcon(){ let r=RACES[selRace]; document.getElementById('preview-icon').innerText = selGender==='MALE' ? r.iconM : r.iconF; }
function spawnText(x,y,t,c){ let e=document.createElement('div'); e.className='floating-text'; e.innerText=t; e.style.color=c; e.style.left=(x-game.cam.x+gameCanvas.width/2)+'px'; e.style.top=(y-game.cam.y+gameCanvas.height/2)+'px'; document.getElementById('floating-text-container').appendChild(e); setTimeout(()=>e.remove(),1000); }
function startGame() { 
    AudioSys.init(); document.getElementById('btn-music').innerText = "🔊 音樂"; game.player=new PlayerClass(selRace, selGender); game.floor = 0; genFloor(0); game.cam.x=game.player.x; game.cam.y=game.player.y; game.running=true; game.uiDirty = true; document.getElementById('start-screen').style.display='none'; 
    checkMobile(); // Check mobile controls on start
}

function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        document.exitFullscreen();
    }
}

function checkMobile() {
    // Basic detection for touch devices or small screens
    const isMobile = ('ontouchstart' in window) || (window.innerWidth < 800);
    if (isMobile) {
        document.getElementById('btn-attack').style.display = 'flex';
        document.getElementById('btn-magic').style.display = 'flex';
        document.getElementById('joystick-container').style.display = 'block';
    } else {
        document.getElementById('btn-attack').style.display = 'none';
        document.getElementById('btn-magic').style.display = 'none';
        document.getElementById('joystick-container').style.display = 'none';
    }
}

function getNearestEnemy(range=300) {
    if(!game.player) return null;
    let p = game.player;
    let candidates = game.entities.filter(e => e.isEnemy && !e.dead && !e.charmed && !e.hidden);
    let nearest = null;
    let minDist = range;
    
    candidates.forEach(e => {
        let d = Math.hypot(e.x - p.x, e.y - p.y);
        if(d < minDist) {
            minDist = d;
            nearest = e;
        }
    });
    return nearest;
}

function handleMobileAttack(e) {
    e.preventDefault();
    if(!game.running) return;
    let range = 60; // Base Melee
    if(game.player.equip.mainhand && (game.player.equip.mainhand.type.includes('BOW') || game.player.equip.mainhand.type.includes('CROSSBOW'))) {
        range = 350; // Bow range
    }
    
    let target = getNearestEnemy(range);
    
    if(target) {
        attack(target);
    } else {
        // Just animation if missed
        if(game.player.atkCd <= 0) {
            game.player.atkCd = 0.3;
            game.player.attackAnimTimer = 0.2; 
            AudioSys.sfx('step');
        }
    }
}

function handleMobileMagic(e) {
    e.preventDefault();
    if(!game.running) return;
    
    let target = getNearestEnemy(300);
    if(target) {
        mouse.wx = target.x;
        mouse.wy = target.y;
    } else {
        // Cast in facing direction
        mouse.wx = game.player.x + Math.cos(game.player.facing) * 100;
        mouse.wy = game.player.y + Math.sin(game.player.facing) * 100;
    }
    castSpell();
}

function init() { 
    gameCanvas = document.getElementById('gameCanvas'); gameCtx = gameCanvas.getContext('2d'); minimapCanvas = document.getElementById('minimap'); minimapCtx = minimapCanvas.getContext('2d'); const rl = document.getElementById('race-list'); rl.innerHTML = ''; Object.keys(RACES).forEach(k=>{ const b = document.createElement('button'); b.className = 'race-btn'; b.innerText = RACES[k].name; b.onclick = () => selectRace(k, b); rl.appendChild(b); }); selectRace('HUMAN', rl.firstChild); 
    
    window.addEventListener('resize', ()=>{ gameCanvas.width=window.innerWidth; gameCanvas.height=window.innerHeight-140; checkMobile(); }); 
    window.dispatchEvent(new Event('resize')); 
    
    gameCanvas.addEventListener('mousemove', e => { mouse.wx = e.clientX - gameCanvas.width/2 + game.cam.x; mouse.wy = e.clientY - gameCanvas.height/2 + game.cam.y; }); 
    
    window.addEventListener('keydown', e => { 
        if(!game.running) return; 
        if(e.key >= '1' && e.key <= '8') useHotbar(parseInt(e.key)-1);
        if(e.key === 'i' || e.key === 'I') toggleInventory(); 
        if(e.key === 'k' || e.key === 'K') toggleSpellBook(); 
    });
    document.getElementById('minimap-container').addEventListener('mousedown', e => {
        if(!game.running) return;
        const rect = e.target.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const cw = 150/60; const dx = (mx - 75) / cw; const dy = (my - 75) / cw; 
        game.player.targetEntity = null; game.player.path = findPath(game.player.x, game.player.y, game.player.x + dx * 40, game.player.y + dy * 40);
    });
    gameCanvas.addEventListener('mousedown', e=>{ 
        if(!game.running) return; 
        const wx=e.clientX-gameCanvas.width/2+game.cam.x; const wy=e.clientY-gameCanvas.height/2+game.cam.y; mouse.wx = wx; mouse.wy = wy; 
        if(e.button===0){ 
            let tx = Math.floor(wx / 40); let ty = Math.floor(wy / 40);
            if (game.map[ty] && (game.map[ty][tx] === 2 || game.map[ty][tx] === 6)) {
                 if (Math.hypot(game.player.x - (tx * 40 + 20), game.player.y - (ty * 40 + 20)) < 60) {
                     if (game.map[ty][tx] === 2) { game.floor++; genFloor(game.floor); game.cam.x=game.player.x; game.cam.y=game.player.y; game.player.path=[]; return; }
                     if (game.map[ty][tx] === 6 && game.floor > 0) { game.floor--; genFloor(game.floor); game.cam.x=game.player.x; game.cam.y=game.player.y; game.player.path=[]; return; }
                 }
            }
            let t = getTargetAt(wx,wy); let p = game.player; let closeEnemy = (t && t.isEnemy) ? t : null;
            if(closeEnemy) {
                // FIX: Always target enemy to queue attack
                game.player.targetEntity = closeEnemy; 
                game.player.attackRequested = true; 
                game.player.path = [];
            } else { 
                if(t && !t.isEnemy) { 
                    game.player.targetEntity = t; game.player.path = []; 
                } else { 
                    game.player.targetEntity=null; 
                    game.player.path=findPath(game.player.x,game.player.y,wx,wy); 
                } 
            }
        } 
        if(e.button===2) { e.preventDefault(); castSpell(); } 
    }); 
    gameCanvas.addEventListener('contextmenu', event => event.preventDefault()); 
    const joy=document.getElementById('joystick-container'); 
    joy.addEventListener('touchstart',e=>{ joystick.active=true; let t=e.touches[0]; joystick.startX=t.clientX; joystick.startY=t.clientY; }); 
    
    // Bind Mobile Buttons
    document.getElementById('btn-attack').addEventListener('touchstart', handleMobileAttack);
    document.getElementById('btn-magic').addEventListener('touchstart', handleMobileMagic);

    window.addEventListener('touchmove',e=>{ if(!joystick.active)return; let t=e.touches[0]; let dx=t.clientX-joystick.startX,dy=t.clientY-joystick.startY; let d=Math.min(50,Math.sqrt(dx*dx+dy*dy)); let a=Math.atan2(dy,dx); joystick.vector={x:Math.cos(a)*(d/50),y:Math.sin(a)*(d/50)}; document.getElementById('joystick-knob').style.left=(50+Math.cos(a)*50*(d/50))+'%'; document.getElementById('joystick-knob').style.top=(50+Math.sin(a)*50*(d/50))+'%'; }); window.addEventListener('touchend',()=>{ joystick.active=false; joystick.vector={x:0,y:0}; document.getElementById('joystick-knob').style.left='50%'; document.getElementById('joystick-knob').style.top='50%'; if(game.player) { game.player.path = []; game.player.targetEntity = null; } }); 
    
    checkMobile();
    setInterval(update, 16); requestAnimationFrame(function tick(){ if(typeof draw === 'function') draw(); requestAnimationFrame(tick); }); 
}
</script>
</body>
</html>